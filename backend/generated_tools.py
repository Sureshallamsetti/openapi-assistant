"""Auto-generated API tools from OpenAPI specification."""
from langchain.tools import tool
from typing import Any, Dict, Optional
import os
import json
import requests
from urllib.parse import urljoin

# Default headers including required X-CLIENT-ID
DEFAULT_HEADERS = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}

@tool
def connectivity_check(engine_id: str, host: str, port: int, use_engine_public_key: Optional[bool] = None, os_name: Optional[str] = None, staging_environment: Optional[str] = None, username: Optional[str] = None, password: Optional[str] = None, vault_id: Optional[str] = None, hashicorp_vault_engine: Optional[str] = None, hashicorp_vault_secret_path: Optional[str] = None, hashicorp_vault_username_key: Optional[str] = None, hashicorp_vault_secret_key: Optional[str] = None, azure_vault_name: Optional[str] = None, azure_vault_username_key: Optional[str] = None, azure_vault_secret_key: Optional[str] = None, cyberark_vault_query_string: Optional[str] = None, use_kerberos_authentication: Optional[bool] = None) -> dict:
    """
    POST /connectivity/check

    Args:
    engine_id (str): The ID of the engine to check. (in: query)
    use_engine_public_key (bool): Whether to use public key authentication. (in: query)
    os_name (str): Operating system type of the environment. (in: query)
    staging_environment (str): Id of the connector environment which is used to connect to this source environment. (in: query)
    host (str): The hostname of the remote host machine to check. (in: query)
    port (int): The port of the remote host machine to check. For Windows, port on which Delphix connector is running. (in: query)
    username (str): The username of the remote host machine to check. Username is mandatory input with password/use_engine_public_key/kerberos_authentication. (in: query)
    password (str): The password of the remote host machine to check. (in: query)
    vault_id (str): The DCT id or name of the vault from which to read the host credentials. (in: query)
    hashicorp_vault_engine (str): Vault engine name where the credential is stored. (in: query)
    hashicorp_vault_secret_path (str): Path in the vault engine where the credential is stored. (in: query)
    hashicorp_vault_username_key (str): Key for the username in the key-value store. (in: query)
    hashicorp_vault_secret_key (str): Key for the password in the key-value store. (in: query)
    azure_vault_name (str): Azure key vault name (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    azure_vault_username_key (str): Azure vault key for the username in the key-value store (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    azure_vault_secret_key (str): Azure vault key for the password in the key-value store (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    cyberark_vault_query_string (str): Query to find a credential in the CyberArk vault. (in: query)
    use_kerberos_authentication (bool): Whether to use kerberos authentication. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"connectivity/check"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"engine_id": engine_id, "use_engine_public_key": use_engine_public_key, "os_name": os_name, "staging_environment": staging_environment, "host": host, "port": port, "username": username, "password": password, "vault_id": vault_id, "hashicorp_vault_engine": hashicorp_vault_engine, "hashicorp_vault_secret_path": hashicorp_vault_secret_path, "hashicorp_vault_username_key": hashicorp_vault_username_key, "hashicorp_vault_secret_key": hashicorp_vault_secret_key, "azure_vault_name": azure_vault_name, "azure_vault_username_key": azure_vault_username_key, "azure_vault_secret_key": azure_vault_secret_key, "cyberark_vault_query_string": cyberark_vault_query_string, "use_kerberos_authentication": use_kerberos_authentication}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def database_connectivity_check(credentials_type: str, source_id: str, username: Optional[str] = None, password: Optional[str] = None, vault: Optional[str] = None, hashicorp_vault_engine: Optional[str] = None, hashicorp_vault_secret_path: Optional[str] = None, hashicorp_vault_username_key: Optional[str] = None, hashicorp_vault_secret_key: Optional[str] = None, azure_vault_name: Optional[str] = None, azure_vault_username_key: Optional[str] = None, azure_vault_secret_key: Optional[str] = None, cyberark_vault_query_string: Optional[str] = None, environment_id: Optional[str] = None, environment_user: Optional[str] = None) -> dict:
    """
    POST /database/connectivity/check

    Args:
    credentials_type (str): The type of credentials. (in: query)
    source_id (str): Source database config Id. (in: query)
    username (str): Database username (Not applicable for MSSQL_ENVIRONMENT_USER). (in: query)
    password (str): Database password (Not applicable for MSSQL_ENVIRONMENT_USER and mutually exclusive with vault attributes). (in: query)
    vault (str): The name or reference of the vault from which to read the database credentials (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    hashicorp_vault_engine (str): Vault engine name where the credential is stored (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    hashicorp_vault_secret_path (str): Path in the vault engine where the credential is stored (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    hashicorp_vault_username_key (str): Hashicorp vault key for the username in the key-value store (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    hashicorp_vault_secret_key (str): Hashicorp vault key for the password in the key-value store (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    azure_vault_name (str): Azure key vault name (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    azure_vault_username_key (str): Azure vault key for the username in the key-value store (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    azure_vault_secret_key (str): Azure vault key for the password in the key-value store (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    cyberark_vault_query_string (str): Query to find a credential in the CyberArk vault (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    environment_id (str): Id of the environment to which environment user belongs (MSSQL_ENVIRONMENT_USER only). (in: query)
    environment_user (str): Reference to the environment user (MSSQL_ENVIRONMENT_USER only). (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"database/connectivity/check"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"credentials_type": credentials_type, "source_id": source_id, "username": username, "password": password, "vault": vault, "hashicorp_vault_engine": hashicorp_vault_engine, "hashicorp_vault_secret_path": hashicorp_vault_secret_path, "hashicorp_vault_username_key": hashicorp_vault_username_key, "hashicorp_vault_secret_key": hashicorp_vault_secret_key, "azure_vault_name": azure_vault_name, "azure_vault_username_key": azure_vault_username_key, "azure_vault_secret_key": azure_vault_secret_key, "cyberark_vault_query_string": cyberark_vault_query_string, "environment_id": environment_id, "environment_user": environment_user}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def netbackup_connectivity_check(environment_id: str, environment_user_id: str, master_server_name: str, source_client_name: str) -> dict:
    """
    POST /netbackup/connectivity/check

    Args:
    environment_id (str): Id of the target environment to test NetBackup connectivity from. (in: query)
    environment_user_id (str): Id of the environment user. (in: query)
    master_server_name (str): The name of the NetBackup master server to attempt to connect to. (in: query)
    source_client_name (str): The name of the NetBackup client to attempt to connect with. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"netbackup/connectivity/check"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"environment_id": environment_id, "environment_user_id": environment_user_id, "master_server_name": master_server_name, "source_client_name": source_client_name}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def commvault_connectivity_check(environment_id: str, environment_user_id: str, commserve_host_name: str, source_client_name: str, staging_client_name: str) -> dict:
    """
    POST /commvault/connectivity/check

    Args:
    environment_id (str): Id of the target environment to test Commvault connectivity from. (in: query)
    environment_user_id (str): Id of the environment user. (in: query)
    commserve_host_name (str): The hostname of the CommServe server to connect to. (in: query)
    source_client_name (str): The name of the Source Client in CommServe. (in: query)
    staging_client_name (str): The name of the Staging Client in CommServe. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"commvault/connectivity/check"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"environment_id": environment_id, "environment_user_id": environment_user_id, "commserve_host_name": commserve_host_name, "source_client_name": source_client_name, "staging_client_name": staging_client_name}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_data_layouts(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /data-layouts

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-layouts"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_data_layouts(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /data-layouts/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-layouts/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_data_layout_by_id(dataLayoutId: str) -> dict:
    """
    GET /data-layouts/{dataLayoutId}

    Args:
    dataLayoutId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-layouts/{dataLayoutId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_data_layout_tags(dataLayoutId: str) -> dict:
    """
    GET /data-layouts/{dataLayoutId}/tags

    Args:
    dataLayoutId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-layouts/{dataLayoutId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_data_layout_tags(dataLayoutId: str, tags: Any) -> dict:
    """
    POST /data-layouts/{dataLayoutId}/tags

    Args:
    dataLayoutId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-layouts/{dataLayoutId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_data_layout_tags(dataLayoutId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /data-layouts/{dataLayoutId}/tags/delete

    Args:
    dataLayoutId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-layouts/{dataLayoutId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def convert_and_drop_bookmarks(dataLayoutId: str, skip_account_import: Optional[bool] = None) -> dict:
    """
    POST /data-layouts/{dataLayoutId}/convert-and-drop

    Args:
    dataLayoutId (str): Path parameter
    skip_account_import (bool): Skip running the account import process. If this flag is not set, then accounts from self-service will overwrite existing accounts if any. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-layouts/{dataLayoutId}/convert-and-drop"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"skip_account_import": skip_account_import}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def import_engine_accounts(data_layout_ids: Optional[Any] = None, engine_ids: Optional[Any] = None, import_all: Optional[bool] = None) -> dict:
    """
    POST /data-layouts/import-engine-accounts

    Args:
    data_layout_ids (Any): List of data-layout ids for which accounts should be imported to DCT. This is mutually exclusive with `engine_ids` and `import_all`. (in: query)
    engine_ids (Any): List of engine ids for which accounts should be imported to DCT. This is mutually exclusive with `data_layout_ids` and `import_all`. (in: query)
    import_all (bool): All self-service accounts across engines should imported to DCT. This is mutually exclusive with `data_layout_ids` and `engine_ids`. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-layouts/import-engine-accounts"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"data_layout_ids": data_layout_ids, "engine_ids": engine_ids, "import_all": import_all}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_bookmarks(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /bookmarks

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"bookmarks"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_bookmark(name: str, vdb_ids: Optional[Any] = None, vdb_group_id: Optional[str] = None, snapshot_ids: Optional[Any] = None, timeflow_ids: Optional[Any] = None, timestamp: Optional[str] = None, timestamp_in_database_timezone: Optional[str] = None, location: Optional[str] = None, retention: Optional[int] = None, expiration: Optional[str] = None, retain_forever: Optional[bool] = None, tags: Optional[Any] = None, bookmark_type: Optional[str] = None, make_current_account_owner: Optional[bool] = None, inherit_parent_vdb_tags: Optional[bool] = None, inherit_parent_tags: Optional[bool] = None) -> dict:
    """
    POST /bookmarks

    Args:
    name (str): The user-defined name of this bookmark. (in: query)
    vdb_ids (Any): The IDs of the VDBs to create the Bookmark on. This parameter is mutually exclusive with snapshot_ids and timeflow_ids. (in: query)
    vdb_group_id (str): The ID of the VDB group to create the Bookmark on. This parameter is mutually exclusive with vdb_ids. (in: query)
    snapshot_ids (Any): The IDs of the snapshots that will be part of the Bookmark. This parameter is mutually exclusive with vdb_ids, timestamp, timestamp_in_database_timezone, location and timeflow_ids. (in: query)
    timeflow_ids (Any): The array of timeflow Id. Only allowed to set when timestamp, timestamp_in_database_timezone or location is provided. (in: query)
    timestamp (str): The point in time from which to execute the operation. Mutually exclusive with snapshot_ids, timestamp_in_database_timezone and location. (in: query)
    timestamp_in_database_timezone (str): The point in time from which to execute the operation, expressed as a date-time in the timezone of the source database. Mutually exclusive with snapshot_ids, timestamp and location. (in: query)
    location (str): The location to create bookmark from. Mutually exclusive with snapshot_ids, timestamp, and timestamp_in_database_timezone. (in: query)
    retention (int): The retention policy for this bookmark, in days. A value of -1 indicates the bookmark should be kept forever. Deprecated in favor of expiration and retain_forever. (in: query)
    expiration (str): The expiration for this bookmark. Mutually exclusive with retention and retain_forever. (in: query)
    retain_forever (bool): Indicates that the bookmark should be retained forever. (in: query)
    tags (Any): The tags to be created for this Bookmark. (in: query)
    bookmark_type (str): Type of the bookmark, either PUBLIC or PRIVATE. (in: query)
    make_current_account_owner (bool): Whether the account creating this bookmark must be configured as owner of the bookmark. (in: query)
    inherit_parent_vdb_tags (bool): This field has been deprecated in favour of new field 'inherit_parent_tags'. (in: query)
    inherit_parent_tags (bool): Whether this bookmark should inherit tags from the parent dataset. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"bookmarks"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "vdb_ids": vdb_ids, "vdb_group_id": vdb_group_id, "snapshot_ids": snapshot_ids, "timeflow_ids": timeflow_ids, "timestamp": timestamp, "timestamp_in_database_timezone": timestamp_in_database_timezone, "location": location, "retention": retention, "expiration": expiration, "retain_forever": retain_forever, "tags": tags, "bookmark_type": bookmark_type, "make_current_account_owner": make_current_account_owner, "inherit_parent_vdb_tags": inherit_parent_vdb_tags, "inherit_parent_tags": inherit_parent_tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_bookmarks(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /bookmarks/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"bookmarks/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_bookmark_by_id(bookmarkId: str) -> dict:
    """
    GET /bookmarks/{bookmarkId}

    Args:
    bookmarkId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"bookmarks/{bookmarkId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_bookmark(bookmarkId: str) -> dict:
    """
    DELETE /bookmarks/{bookmarkId}

    Args:
    bookmarkId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"bookmarks/{bookmarkId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_bookmark(bookmarkId: str, name: Optional[str] = None, expiration: Optional[str] = None, retain_forever: Optional[bool] = None, bookmark_type: Optional[str] = None) -> dict:
    """
    PATCH /bookmarks/{bookmarkId}

    Args:
    bookmarkId (str): Path parameter
    name (str): The user-defined name of this bookmark. (in: query)
    expiration (str): The expiration for this Bookmark. Mutually exclusive with retain_forever. (in: query)
    retain_forever (bool): Indicates that the Bookmark should be retained forever. (in: query)
    bookmark_type (str): Type of the bookmark, either PUBLIC or PRIVATE. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"bookmarks/{bookmarkId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "expiration": expiration, "retain_forever": retain_forever, "bookmark_type": bookmark_type}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_vdb_groups_by_bookmark(bookmarkId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /bookmarks/{bookmarkId}/vdb-groups

    Args:
    bookmarkId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"bookmarks/{bookmarkId}/vdb-groups"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_vdb_groups_by_bookmark(bookmarkId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /bookmarks/{bookmarkId}/vdb-groups/search

    Args:
    bookmarkId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"bookmarks/{bookmarkId}/vdb-groups/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_bookmark_tags(bookmarkId: str) -> dict:
    """
    GET /bookmarks/{bookmarkId}/tags

    Args:
    bookmarkId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"bookmarks/{bookmarkId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_bookmark_tags(bookmarkId: str, tags: Any) -> dict:
    """
    POST /bookmarks/{bookmarkId}/tags

    Args:
    bookmarkId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"bookmarks/{bookmarkId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_bookmark_tags(bookmarkId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /bookmarks/{bookmarkId}/tags/delete

    Args:
    bookmarkId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"bookmarks/{bookmarkId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def import_engine_bookmarks(engineId: str) -> dict:
    """
    POST /bookmarks/import-engine-bookmarks/{engineId}

    Args:
    engineId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"bookmarks/import-engine-bookmarks/{engineId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_sources(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /sources

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"sources"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_oracle_source(oracle_config_type: str, repository_id: str, engine_id: Optional[str] = None, environment_id: Optional[str] = None, database_name: Optional[str] = None, instances: Optional[Any] = None, unique_name: Optional[str] = None, instance_name: Optional[str] = None) -> dict:
    """
    POST /sources/oracle

    Args:
    oracle_config_type (str): oracle_config_type (in: query)
    engine_id (str): The ID of the engine to create the source on. (in: query)
    environment_id (str): The ID of the environment to create the source on. (in: query)
    database_name (str): The name of the database. (in: query)
    repository_id (str): The id of the containing repository where this database is created. (in: query)
    instances (Any): The instances of this RAC database. (in: query)
    unique_name (str): The unique name of this database. (in: query)
    instance_name (str): The instance name of this single instance database. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"sources/oracle"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"oracle_config_type": oracle_config_type, "engine_id": engine_id, "environment_id": environment_id, "database_name": database_name, "repository_id": repository_id, "instances": instances, "unique_name": unique_name, "instance_name": instance_name}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_oracle_source_by_id(sourceId: str, oracle_services: Optional[Any] = None, user: Optional[str] = None, password: Optional[str] = None, linking_enabled: Optional[bool] = None) -> dict:
    """
    PATCH /sources/oracle/{sourceId}

    Args:
    sourceId (str): Path parameter
    oracle_services (Any): List of jdbc connection strings which are used to connect with the database. (in: query)
    user (str): Database user for accessing this source. (in: query)
    password (str): Password for the database user. (in: query)
    linking_enabled (bool): Whether this source should be used for linking. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"sources/oracle/{sourceId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"oracle_services": oracle_services, "user": user, "password": password, "linking_enabled": linking_enabled}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def verify_source_jdbc_connection_string(sourceId: str, database_username: str, database_password: str, jdbc_connection_string: str) -> dict:
    """
    POST /sources/{sourceId}/jdbc-check

    Args:
    sourceId (str): Path parameter
    database_username (str): oracle database username. (in: query)
    database_password (str): oracle database password. (in: query)
    jdbc_connection_string (str): Oracle jdbc connection string to validate. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"sources/{sourceId}/jdbc-check"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"database_username": database_username, "database_password": database_password, "jdbc_connection_string": jdbc_connection_string}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_postgres_source(name: str, repository_id: Optional[str] = None, engine_id: Optional[str] = None, environment_id: Optional[str] = None) -> dict:
    """
    POST /sources/postgres

    Args:
    name (str): The name of the source. (in: query)
    repository_id (str): The ID of the Repository onto which the source will be created. (in: query)
    engine_id (str): The ID of the engine to create the source on. (in: query)
    environment_id (str): The ID of the environment to create the source on. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"sources/postgres"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "repository_id": repository_id, "engine_id": engine_id, "environment_id": environment_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_app_data_source(type: str, name: str, repository_id: str, linking_enabled: Optional[bool] = None, environment_user: Optional[str] = None, parameters: Optional[Any] = None, path: Optional[str] = None, environment_id: Optional[str] = None, engine_id: Optional[str] = None) -> dict:
    """
    POST /sources/appdata

    Args:
    type (str): The type of source to create. Default is DIRECT. (in: query)
    name (str): The name of the source. (in: query)
    repository_id (str): The ID of the Repository onto which the source will be created. (in: query)
    linking_enabled (bool): Whether this source should be used for linking. (in: query)
    environment_user (str): The environment user reference. (in: query)
    parameters (Any): The JSON payload conforming to the DraftV4 schema based on the type of application data being manipulated. (in: query)
    path (str): The path to the data to be synced. This should only be passed for type=DIRECT. (in: query)
    environment_id (str): The ID of the environment to create the source on. (in: query)
    engine_id (str): The ID of the engine to create the source on. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"sources/appdata"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"type": type, "name": name, "repository_id": repository_id, "linking_enabled": linking_enabled, "environment_user": environment_user, "parameters": parameters, "path": path, "environment_id": environment_id, "engine_id": engine_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_postgres_source_by_id(sourceId: str, name: Optional[str] = None) -> dict:
    """
    PATCH /sources/postgres/{sourceId}

    Args:
    sourceId (str): Path parameter
    name (str): The name of the source. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"sources/postgres/{sourceId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_sources(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /sources/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"sources/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_source_by_id(sourceId: str) -> dict:
    """
    GET /sources/{sourceId}

    Args:
    sourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"sources/{sourceId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_source(sourceId: str) -> dict:
    """
    DELETE /sources/{sourceId}

    Args:
    sourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"sources/{sourceId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_source_by_id(sourceId: str, oracle_services: Optional[Any] = None) -> dict:
    """
    PATCH /sources/{sourceId}/update

    Args:
    sourceId (str): Path parameter
    oracle_services (Any): List of jdbc connection strings which are used to connect with the database. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"sources/{sourceId}/update"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"oracle_services": oracle_services}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_source_tags(sourceId: str) -> dict:
    """
    GET /sources/{sourceId}/tags

    Args:
    sourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"sources/{sourceId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_source_tags(sourceId: str, tags: Any) -> dict:
    """
    POST /sources/{sourceId}/tags

    Args:
    sourceId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"sources/{sourceId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_source_compatible_repo(sourceId: str) -> dict:
    """
    GET /sources/{sourceId}/staging_compatible_repositories

    Args:
    sourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"sources/{sourceId}/staging_compatible_repositories"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_source_tags(sourceId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /sources/{sourceId}/tags/delete

    Args:
    sourceId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"sources/{sourceId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_staging_sources(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /staging-sources

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"staging-sources"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_staging_sources(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /staging-sources/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"staging-sources/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_staging_source_by_id(stagingSourceId: str) -> dict:
    """
    GET /staging-sources/{stagingSourceId}

    Args:
    stagingSourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"staging-sources/{stagingSourceId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_staging_source_by_id(stagingSourceId: str, oracle_services: Optional[Any] = None) -> dict:
    """
    PATCH /staging-sources/{stagingSourceId}/update

    Args:
    stagingSourceId (str): Path parameter
    oracle_services (Any): List of jdbc connection strings which are used to connect with the database. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"staging-sources/{stagingSourceId}/update"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"oracle_services": oracle_services}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_staging_source_tags(stagingSourceId: str) -> dict:
    """
    GET /staging-sources/{stagingSourceId}/tags

    Args:
    stagingSourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"staging-sources/{stagingSourceId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_staging_source_tags(stagingSourceId: str, tags: Any) -> dict:
    """
    POST /staging-sources/{stagingSourceId}/tags

    Args:
    stagingSourceId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"staging-sources/{stagingSourceId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_staging_source_tags(stagingSourceId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /staging-sources/{stagingSourceId}/tags/delete

    Args:
    stagingSourceId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"staging-sources/{stagingSourceId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_dsources(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, permission: Optional[str] = None) -> dict:
    """
    GET /dsources

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    permission (str): Restrict the objects, which are allowed. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort, "permission": permission}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def link_oracle_database(args: Optional[dict] = None) -> dict:
    """
    POST /dsources/oracle

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/oracle"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_oracle_dsource_linking_defaults(source_id: str) -> dict:
    """
    POST /dsources/oracle/defaults

    Args:
    source_id (str): The ID of the source to be linked. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/oracle/defaults"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"source_id": source_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def detach_oracle_dsource(dsourceId: str) -> dict:
    """
    POST /dsources/oracle/{dsourceId}/detachSource

    Args:
    dsourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/oracle/{dsourceId}/detachSource"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def attach_oracle_dsource(dsourceId: str, source_id: str) -> dict:
    """
    POST /dsources/oracle/{dsourceId}/attachSource

    Args:
    dsourceId (str): Path parameter
    source_id (str): Id of the source to attach. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/oracle/{dsourceId}/attachSource"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"source_id": source_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def link_oracle_staging_push_database(args: Optional[dict] = None) -> dict:
    """
    POST /dsources/oracle/staging-push

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/oracle/staging-push"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_oracle_staging_push_dsource_linking_defaults(environment_id: str, container_type: Optional[str] = None) -> dict:
    """
    POST /dsources/oracle/staging-push/defaults

    Args:
    environment_id (str): The ID of the environment to be linked. (in: query)
    container_type (str): The container type of this database.If not provided the request would be considered for a PDB database. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/oracle/staging-push/defaults"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"environment_id": environment_id, "container_type": container_type}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_oracle_dsource_by_id(dsourceId: str, name: Optional[str] = None, db_username: Optional[str] = None, db_password: Optional[str] = None, validate_db_credentials: Optional[bool] = None, environment_user_id: Optional[str] = None, backup_level_enabled: Optional[bool] = None, rman_channels: Optional[int] = None, files_per_set: Optional[int] = None, check_logical: Optional[bool] = None, encrypted_linking_enabled: Optional[bool] = None, compressed_linking_enabled: Optional[bool] = None, bandwidth_limit: Optional[int] = None, number_of_connections: Optional[int] = None, validate_by_opening_db_in_read_only_mode: Optional[bool] = None, pre_provisioning_enabled: Optional[bool] = None, diagnose_no_logging_faults: Optional[bool] = None, rac_max_instance_lag: Optional[int] = None, allow_auto_staging_restart_on_host_reboot: Optional[bool] = None, physical_standby: Optional[bool] = None, external_file_path: Optional[str] = None, hooks: Optional[Any] = None, custom_env_variables_pairs: Optional[Any] = None, custom_env_variables_paths: Optional[Any] = None, staging_database_config_params: Optional[Any] = None, template_id: Optional[str] = None, logsync_enabled: Optional[bool] = None, logsync_mode: Optional[str] = None, logsync_interval: Optional[int] = None) -> dict:
    """
    PATCH /dsources/oracle/{dsourceId}

    Args:
    dsourceId (str): Path parameter
    name (str): The unique name of the dSource within a group. (in: query)
    db_username (str): The username of the database user. (in: query)
    db_password (str): The password of the database user. (in: query)
    validate_db_credentials (bool): Whether db_username and db_password must be validated, if present, against the dSource. This must be set to false when credentials validation is not possible, for instance if the dSource is known to be disabled. (in: query)
    environment_user_id (str): The environment user ID to use to connect to the target environment. (in: query)
    backup_level_enabled (bool): Boolean value indicates whether LEVEL-based incremental backups can be used on the source database. (in: query)
    rman_channels (int): Number of parallel channels to use. (in: query)
    files_per_set (int): Number of data files to include in each RMAN backup set. (in: query)
    check_logical (bool): True if extended block checking should be used for this dSource. (in: query)
    encrypted_linking_enabled (bool): True if SnapSync data from the source should be retrieved through an encrypted connection. Enabling this feature can decrease the performance of SnapSync from the source but has no impact on the performance of VDBs created from the retrieved data. (in: query)
    compressed_linking_enabled (bool): True if SnapSync data from the source should be compressed over the network. Enabling this feature will reduce network bandwidth consumption and may significantly improve throughput, especially over slow network. (in: query)
    bandwidth_limit (int): Bandwidth limit (MB/s) for SnapSync and LogSync network traffic. A value of 0 means no limit. (in: query)
    number_of_connections (int): Total number of transport connections to use during SnapSync. (in: query)
    validate_by_opening_db_in_read_only_mode (bool): Whether the snaphots of this dSource's staging database will be validated by opening it in read-only mode. (in: query)
    pre_provisioning_enabled (bool): Boolean flag indicating whether or not pre-provisioning is turned on for this dSource. (in: query)
    diagnose_no_logging_faults (bool): If true, NOLOGGING operations on this dSource are treated as faults and cannot be resolved manually. (in: query)
    rac_max_instance_lag (int): Maximum number of log sequences to allow a RAC instance to lag before considering the instance offline. (in: query)
    allow_auto_staging_restart_on_host_reboot (bool): Allow auto restart of staging source on host reboot. (in: query)
    physical_standby (bool): If true, convert this dSource's staging database to a physical standby. (in: query)
    external_file_path (str): External file path. (in: query)
    hooks (Any): DSource operation hooks. (in: query)
    custom_env_variables_pairs (Any): An array of name value pair of environment variables. (in: query)
    custom_env_variables_paths (Any): An array of strings of whitespace-separated parameters to be passed to the source command. The first parameter must be an absolute path to a file that exists on the target environment. Every subsequent parameter will be treated as an argument interpreted by the environment file. (in: query)
    staging_database_config_params (Any): Database configuration parameter overrides. (in: query)
    template_id (str): The template ID of the target Oracle Staging Push dSource. (in: query)
    logsync_enabled (bool): True if LogSync is enabled for this dSource. (in: query)
    logsync_mode (str): LogSync operation mode for this dSource. (in: query)
    logsync_interval (int): Interval between LogSync requests, in seconds. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/oracle/{dsourceId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "db_username": db_username, "db_password": db_password, "validate_db_credentials": validate_db_credentials, "environment_user_id": environment_user_id, "backup_level_enabled": backup_level_enabled, "rman_channels": rman_channels, "files_per_set": files_per_set, "check_logical": check_logical, "encrypted_linking_enabled": encrypted_linking_enabled, "compressed_linking_enabled": compressed_linking_enabled, "bandwidth_limit": bandwidth_limit, "number_of_connections": number_of_connections, "validate_by_opening_db_in_read_only_mode": validate_by_opening_db_in_read_only_mode, "pre_provisioning_enabled": pre_provisioning_enabled, "diagnose_no_logging_faults": diagnose_no_logging_faults, "rac_max_instance_lag": rac_max_instance_lag, "allow_auto_staging_restart_on_host_reboot": allow_auto_staging_restart_on_host_reboot, "physical_standby": physical_standby, "external_file_path": external_file_path, "hooks": hooks, "custom_env_variables_pairs": custom_env_variables_pairs, "custom_env_variables_paths": custom_env_variables_paths, "staging_database_config_params": staging_database_config_params, "template_id": template_id, "logsync_enabled": logsync_enabled, "logsync_mode": logsync_mode, "logsync_interval": logsync_interval}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def upgrade_oracle_dsource(dsourceId: str, repository_id: str, environment_user_id: str) -> dict:
    """
    This API is marked as deprecated in favour of generalized API '/dsources/{dsourceId}/upgrade'

    Args:
    dsourceId (str): Path parameter
    repository_id (str): The id of the dSource/VDB repository to upgrade to. (in: query)
    environment_user_id (str): Reference of the environment user to use for dSource/VDB upgrade. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/oracle/{dsourceId}/upgrade"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"repository_id": repository_id, "environment_user_id": environment_user_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def upgrade_dsource(dsourceId: str, repository_id: str, environment_user_id: Optional[str] = None, ppt_repository: Optional[str] = None) -> dict:
    """
    POST /dsources/{dsourceId}/upgrade

    Args:
    dsourceId (str): Path parameter
    repository_id (str): The id of the dSource/VDB repository to upgrade to. (in: query)
    environment_user_id (str): Reference of the environment user to use for dSource/VDB upgrade. (in: query)
    ppt_repository (str): The id of the SQL instance on the PPT environment that we want to use for pre-provisioning (MSSQL only). (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/upgrade"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"repository_id": repository_id, "environment_user_id": environment_user_id, "ppt_repository": ppt_repository}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def link_ase_database(args: Optional[dict] = None) -> dict:
    """
    POST /dsources/ase

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/ase"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_ase_dsource_linking_defaults(source_id: str) -> dict:
    """
    POST /dsources/ase/defaults

    Args:
    source_id (str): The ID of the source to be linked. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/ase/defaults"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"source_id": source_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_ase_dsource_by_id(dsourceId: str, name: Optional[str] = None, description: Optional[str] = None, sync_policy_id: Optional[str] = None, retention_policy_id: Optional[str] = None) -> dict:
    """
    PATCH /dsources/ase/{dsourceId}

    Args:
    dsourceId (str): Path parameter
    name (str): Name of the dSource and container to be updated. (in: query)
    description (str): The notes/description for the dSource. (in: query)
    sync_policy_id (str): The ID of the SnapSync policy for the dSource. (in: query)
    retention_policy_id (str): The ID of the Retention policy for the dSource. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/ase/{dsourceId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description, "sync_policy_id": sync_policy_id, "retention_policy_id": retention_policy_id}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def link_appdata_database(args: Optional[dict] = None) -> dict:
    """
    POST /dsources/appdata

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/appdata"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_appdata_dsource_linking_defaults(source_id: str) -> dict:
    """
    POST /dsources/appdata/defaults

    Args:
    source_id (str): The ID of the source to be linked. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/appdata/defaults"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"source_id": source_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_appdata_dsource_by_id(dsourceId: str, name: Optional[str] = None, description: Optional[str] = None, staging_environment: Optional[str] = None, staging_environment_user: Optional[str] = None, environment_user: Optional[str] = None, parameters: Optional[Any] = None, sync_policy_id: Optional[str] = None, retention_policy_id: Optional[str] = None, ops_pre_sync: Optional[Any] = None, ops_post_sync: Optional[Any] = None) -> dict:
    """
    PATCH /dsources/appdata/{dsourceId}

    Args:
    dsourceId (str): Path parameter
    name (str): Name of the dSource and container to be updated. (in: query)
    description (str): The notes/description for the dSource. (in: query)
    staging_environment (str): The environment used as an intermediate stage to pull data into Delphix [AppDataStaged only]. (in: query)
    staging_environment_user (str): The environment user used to access the staging environment [AppDataStaged only]. (in: query)
    environment_user (str): The OS user to use for linking. (in: query)
    parameters (Any): The JSON payload conforming to the DraftV4 schema based on the type of application data being manipulated. (in: query)
    sync_policy_id (str): The ID of the SnapSync policy for the dSource. (in: query)
    retention_policy_id (str): The ID of the Retention policy for the dSource. (in: query)
    ops_pre_sync (Any): Operations to perform before syncing the created dSource. These operations can quiesce any data prior to syncing. (in: query)
    ops_post_sync (Any): Operations to perform after syncing a created dSource. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/appdata/{dsourceId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description, "staging_environment": staging_environment, "staging_environment_user": staging_environment_user, "environment_user": environment_user, "parameters": parameters, "sync_policy_id": sync_policy_id, "retention_policy_id": retention_policy_id, "ops_pre_sync": ops_pre_sync, "ops_post_sync": ops_post_sync}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def link_mssql_database(args: Optional[dict] = None) -> dict:
    """
    POST /dsources/mssql

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/mssql"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def detach_mssql_database(dsourceId: str) -> dict:
    """
    POST /dsources/mssql/{dsourceId}/detachSource

    Args:
    dsourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/mssql/{dsourceId}/detachSource"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def attach_mssql_database(dsourceId: str, source_id: str, ppt_repository: str, sync_strategy_managed_type: Optional[str] = None, mssql_user_environment_reference: Optional[str] = None, mssql_user_domain_username: Optional[str] = None, mssql_user_domain_password: Optional[str] = None, mssql_user_domain_vault_username: Optional[str] = None, mssql_user_domain_vault: Optional[str] = None, mssql_user_domain_hashicorp_vault_engine: Optional[str] = None, mssql_user_domain_hashicorp_vault_secret_path: Optional[str] = None, mssql_user_domain_hashicorp_vault_username_key: Optional[str] = None, mssql_user_domain_hashicorp_vault_secret_key: Optional[str] = None, mssql_user_domain_azure_vault_name: Optional[str] = None, mssql_user_domain_azure_vault_username_key: Optional[str] = None, mssql_user_domain_azure_vault_secret_key: Optional[str] = None, mssql_user_domain_cyberark_vault_query_string: Optional[str] = None, mssql_database_username: Optional[str] = None, mssql_database_password: Optional[str] = None, delphix_managed_backup_compression_enabled: Optional[bool] = None, delphix_managed_backup_policy: Optional[str] = None, external_managed_validate_sync_mode: Optional[str] = None, external_managed_shared_backup_locations: Optional[Any] = None, external_netbackup_config_master_name: Optional[str] = None, external_netbackup_config_source_client_name: Optional[str] = None, external_netbackup_config_params: Optional[Any] = None, external_netbackup_config_templates: Optional[str] = None, external_commserve_host_name: Optional[str] = None, external_commvault_config_source_client_name: Optional[str] = None, external_commvault_config_staging_client_name: Optional[str] = None, external_commvault_config_params: Optional[Any] = None, external_commvault_config_templates: Optional[str] = None, encryption_key: Optional[str] = None, source_host_user: Optional[str] = None, ppt_host_user: Optional[str] = None, staging_pre_script: Optional[str] = None, staging_post_script: Optional[str] = None, ops_pre_sync: Optional[Any] = None, ops_post_sync: Optional[Any] = None) -> dict:
    """
    POST /dsources/mssql/{dsourceId}/attachSource

    Args:
    dsourceId (str): Path parameter
    source_id (str): Id of the source to link. (in: query)
    ppt_repository (str): Id of the SQL instance on the PPT environment that we want to use for pre-provisioning. (in: query)
    sync_strategy_managed_type (str): MSSQL specific parameters for source based sync strategy.:
* `external` - MSSQL specific parameters for externally managed source based sync strategy.
* `delphix` - MSSQL specific parameters for delphix managed source based sync strategy. (in: query)
    mssql_user_environment_reference (str): Reference to the source environment user to use for linking. (in: query)
    mssql_user_domain_username (str): The username for the source DB user. (in: query)
    mssql_user_domain_password (str): Password for the database user. (in: query)
    mssql_user_domain_vault_username (str): Delphix display name for the vault user. (in: query)
    mssql_user_domain_vault (str): The name or reference of the vault from which to read the database credentials. (in: query)
    mssql_user_domain_hashicorp_vault_engine (str): Vault engine name where the credential is stored. (in: query)
    mssql_user_domain_hashicorp_vault_secret_path (str): Path in the vault engine where the credential is stored. (in: query)
    mssql_user_domain_hashicorp_vault_username_key (str): Hashicorp vault key for the username in the key-value store. (in: query)
    mssql_user_domain_hashicorp_vault_secret_key (str): Hashicorp vault key for the password in the key-value store. (in: query)
    mssql_user_domain_azure_vault_name (str): Azure key vault name. (in: query)
    mssql_user_domain_azure_vault_username_key (str): Azure vault key for the username in the key-value store. (in: query)
    mssql_user_domain_azure_vault_secret_key (str): Azure vault key for the password in the key-value store. (in: query)
    mssql_user_domain_cyberark_vault_query_string (str): Query to find a credential in the CyberArk vault. (in: query)
    mssql_database_username (str): The username for the source DB user. (in: query)
    mssql_database_password (str): Password for the database user. (in: query)
    delphix_managed_backup_compression_enabled (bool): Specify whether the backups taken should be compressed or uncompressed when Delphix managed option is selected. (in: query)
    delphix_managed_backup_policy (str): Specify which node of an availability group to run the copy-only full backup on:
* `primary` - Backups only go to the primary node.
* `secondary_only` - Backups only go to secondary nodes. If secondary nodes are down, backups will fail.
* `prefer_secondary` - Backups go to secondary nodes, but if secondary nodes are down, backups will go to the primary node. (in: query)
    external_managed_validate_sync_mode (str): Specifies the backup types ValidatedSync will use to synchronize the dSource with the source database (in: query)
    external_managed_shared_backup_locations (Any): Shared source database backup locations. (in: query)
    external_netbackup_config_master_name (str): The master server name of this NetBackup configuration. (in: query)
    external_netbackup_config_source_client_name (str): The source's client server name of this NetBackup configuration. (in: query)
    external_netbackup_config_params (Any): NetBackup configuration parameter overrides. (in: query)
    external_netbackup_config_templates (str): Optional config template selection for NetBackup configurations. If set, external_netbackup_config_params will be ignored. (in: query)
    external_commserve_host_name (str): The commserve host name of this Commvault configuration. (in: query)
    external_commvault_config_source_client_name (str): The source client name of this Commvault configuration. (in: query)
    external_commvault_config_staging_client_name (str): The staging client name of this Commvault configuration. (in: query)
    external_commvault_config_params (Any): Commvault configuration parameter overrides. (in: query)
    external_commvault_config_templates (str): Optional config template selection for Commvault configurations. If set, configParams will be ignored. (in: query)
    encryption_key (str): The encryption key to use when restoring encrypted backups. (in: query)
    source_host_user (str): ID or user reference of the host OS user to use for linking. (in: query)
    ppt_host_user (str): Reference of the host OS user on the PPT host to use for linking. (in: query)
    staging_pre_script (str): A user-provided PowerShell script or executable to run prior to restoring from a backup during pre-provisioning. (in: query)
    staging_post_script (str): A user-provided PowerShell script or executable to run after restoring from a backup during pre-provisioning. (in: query)
    ops_pre_sync (Any): Operations to perform before syncing the created dSource. These operations can quiesce any data prior to syncing. (in: query)
    ops_post_sync (Any): Operations to perform after syncing a created dSource. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/mssql/{dsourceId}/attachSource"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"source_id": source_id, "ppt_repository": ppt_repository, "sync_strategy_managed_type": sync_strategy_managed_type, "mssql_user_environment_reference": mssql_user_environment_reference, "mssql_user_domain_username": mssql_user_domain_username, "mssql_user_domain_password": mssql_user_domain_password, "mssql_user_domain_vault_username": mssql_user_domain_vault_username, "mssql_user_domain_vault": mssql_user_domain_vault, "mssql_user_domain_hashicorp_vault_engine": mssql_user_domain_hashicorp_vault_engine, "mssql_user_domain_hashicorp_vault_secret_path": mssql_user_domain_hashicorp_vault_secret_path, "mssql_user_domain_hashicorp_vault_username_key": mssql_user_domain_hashicorp_vault_username_key, "mssql_user_domain_hashicorp_vault_secret_key": mssql_user_domain_hashicorp_vault_secret_key, "mssql_user_domain_azure_vault_name": mssql_user_domain_azure_vault_name, "mssql_user_domain_azure_vault_username_key": mssql_user_domain_azure_vault_username_key, "mssql_user_domain_azure_vault_secret_key": mssql_user_domain_azure_vault_secret_key, "mssql_user_domain_cyberark_vault_query_string": mssql_user_domain_cyberark_vault_query_string, "mssql_database_username": mssql_database_username, "mssql_database_password": mssql_database_password, "delphix_managed_backup_compression_enabled": delphix_managed_backup_compression_enabled, "delphix_managed_backup_policy": delphix_managed_backup_policy, "external_managed_validate_sync_mode": external_managed_validate_sync_mode, "external_managed_shared_backup_locations": external_managed_shared_backup_locations, "external_netbackup_config_master_name": external_netbackup_config_master_name, "external_netbackup_config_source_client_name": external_netbackup_config_source_client_name, "external_netbackup_config_params": external_netbackup_config_params, "external_netbackup_config_templates": external_netbackup_config_templates, "external_commserve_host_name": external_commserve_host_name, "external_commvault_config_source_client_name": external_commvault_config_source_client_name, "external_commvault_config_staging_client_name": external_commvault_config_staging_client_name, "external_commvault_config_params": external_commvault_config_params, "external_commvault_config_templates": external_commvault_config_templates, "encryption_key": encryption_key, "source_host_user": source_host_user, "ppt_host_user": ppt_host_user, "staging_pre_script": staging_pre_script, "staging_post_script": staging_post_script, "ops_pre_sync": ops_pre_sync, "ops_post_sync": ops_post_sync}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def attach_mssql_staging_push_database(dsourceId: str, ppt_repository: str, staging_database_name: str, encryption_key: Optional[str] = None, ppt_host_user: Optional[str] = None, staging_pre_script: Optional[str] = None, staging_post_script: Optional[str] = None, db_state: Optional[str] = None, ops_pre_sync: Optional[Any] = None, ops_post_sync: Optional[Any] = None) -> dict:
    """
    POST /dsources/mssql/staging-push/{dsourceId}/attachSource

    Args:
    dsourceId (str): Path parameter
    encryption_key (str): The encryption key to use when restoring encrypted backups. (in: query)
    ppt_repository (str): Reference of the SQL instance on the PPT environment that we want to use for pre-provisioning. (in: query)
    ppt_host_user (str): Reference of the host OS user on the PPT host to use for linking. (in: query)
    staging_pre_script (str): A user-provided PowerShell script or executable to run prior to restoring from a backup during pre-provisioning. (in: query)
    staging_post_script (str): A user-provided PowerShell script or executable to run after restoring from a backup during pre-provisioning. (in: query)
    staging_database_name (str): The name of the database to create on the staging environment. This property is mutually exclusive to sync_strategy_managed_type (in: query)
    db_state (str): User provided db state that will be used to create staging push db. Default is RESTORING (in: query)
    ops_pre_sync (Any): Operations to perform before syncing the created dSource. These operations can quiesce any data prior to syncing. (in: query)
    ops_post_sync (Any): Operations to perform after syncing a created dSource. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/mssql/staging-push/{dsourceId}/attachSource"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"encryption_key": encryption_key, "ppt_repository": ppt_repository, "ppt_host_user": ppt_host_user, "staging_pre_script": staging_pre_script, "staging_post_script": staging_post_script, "staging_database_name": staging_database_name, "db_state": db_state, "ops_pre_sync": ops_pre_sync, "ops_post_sync": ops_post_sync}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_mssql_dsource_linking_defaults(source_id: str) -> dict:
    """
    POST /dsources/mssql/defaults

    Args:
    source_id (str): The ID of the source to be linked. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/mssql/defaults"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"source_id": source_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def link_mssql_staging_push_database(args: Optional[dict] = None) -> dict:
    """
    POST /dsources/mssql/staging-push

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/mssql/staging-push"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_mssql_staging_push_dsource_linking_defaults(environment_id: str) -> dict:
    """
    POST /dsources/mssql/staging-push/defaults

    Args:
    environment_id (str): The ID of the environment to be linked. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/mssql/staging-push/defaults"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"environment_id": environment_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_dsource(dsource_id: str, force: Optional[bool] = None, oracle_username: Optional[str] = None, oracle_password: Optional[str] = None, delete_all_dependent_vdbs: Optional[bool] = None) -> dict:
    """
    POST /dsources/delete

    Args:
    dsource_id (str): Id of the dSource to delete. (in: query)
    force (bool): Flag indicating whether to continue the operation upon failures. (in: query)
    oracle_username (str): The name of the privileged user to run the delete operation as (Oracle only). (in: query)
    oracle_password (str): Password for privileged user (Oracle only). (in: query)
    delete_all_dependent_vdbs (bool): Flag indicating whether to delete all dependent VDBs before deleting the dSource. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"dsource_id": dsource_id, "force": force, "oracle_username": oracle_username, "oracle_password": oracle_password, "delete_all_dependent_vdbs": delete_all_dependent_vdbs}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_dsources(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, permission: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /dsources/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    permission (str): Restrict the objects, which are allowed. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "permission": permission, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_dsource_by_id(dsourceId: str) -> dict:
    """
    GET /dsources/{dsourceId}

    Args:
    dsourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def enable_dsource(dsourceId: str, attempt_start: Optional[bool] = None) -> dict:
    """
    POST /dsources/{dsourceId}/enable

    Args:
    dsourceId (str): Path parameter
    attempt_start (bool): Whether to attempt a startup of the source after the enable. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/enable"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"attempt_start": attempt_start}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def disable_dsource(dsourceId: str, attempt_cleanup: Optional[bool] = None) -> dict:
    """
    POST /dsources/{dsourceId}/disable

    Args:
    dsourceId (str): Path parameter
    attempt_cleanup (bool): Whether to attempt a cleanup of the database from the environment before the disable. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/disable"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"attempt_cleanup": attempt_cleanup}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_upgrade_compatible_repo_for_dsource(dsourceId: str) -> dict:
    """
    GET /dsources/{dsourceId}/upgrade_compatible_repositories

    Args:
    dsourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/upgrade_compatible_repositories"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_mssql_dsource_by_id(dsourceId: str, name: Optional[str] = None, logsync_enabled: Optional[bool] = None, encryption_key: Optional[str] = None, ppt_repository: Optional[str] = None, ppt_host_user: Optional[str] = None, sync_strategy_managed_type: Optional[str] = None, source_host_user: Optional[str] = None, mssql_user_environment_reference: Optional[str] = None, mssql_user_domain_username: Optional[str] = None, mssql_user_domain_password: Optional[str] = None, mssql_user_domain_vault_username: Optional[str] = None, mssql_user_domain_vault: Optional[str] = None, mssql_user_domain_hashicorp_vault_engine: Optional[str] = None, mssql_user_domain_hashicorp_vault_secret_path: Optional[str] = None, mssql_user_domain_hashicorp_vault_username_key: Optional[str] = None, mssql_user_domain_hashicorp_vault_secret_key: Optional[str] = None, mssql_user_domain_azure_vault_name: Optional[str] = None, mssql_user_domain_azure_vault_username_key: Optional[str] = None, mssql_user_domain_azure_vault_secret_key: Optional[str] = None, mssql_user_domain_cyberark_vault_query_string: Optional[str] = None, mssql_database_username: Optional[str] = None, mssql_database_password: Optional[str] = None, delphix_managed_backup_compression_enabled: Optional[bool] = None, delphix_managed_backup_policy: Optional[str] = None, external_managed_validate_sync_mode: Optional[str] = None, external_managed_shared_backup_locations: Optional[Any] = None, disable_netbackup_config: Optional[bool] = None, external_netbackup_config_master_name: Optional[str] = None, external_netbackup_config_source_client_name: Optional[str] = None, external_netbackup_config_params: Optional[Any] = None, external_netbackup_config_templates: Optional[str] = None, disable_commvault_config: Optional[bool] = None, external_commserve_host_name: Optional[str] = None, external_commvault_config_source_client_name: Optional[str] = None, external_commvault_config_staging_client_name: Optional[str] = None, external_commvault_config_params: Optional[Any] = None, external_commvault_config_templates: Optional[str] = None, hooks: Optional[Any] = None, sync_policy_id: Optional[str] = None, retention_policy_id: Optional[str] = None) -> dict:
    """
    PATCH /dsources/mssql/{dsourceId}

    Args:
    dsourceId (str): Path parameter
    name (str): The unique name of the dSource within a group. (in: query)
    logsync_enabled (bool): Enabled LogSync for this dSource. (in: query)
    encryption_key (str): The encryption key to use when restoring encrypted backups. (in: query)
    ppt_repository (str): Reference of the SQL instance on the PPT environment that we want to use for pre-provisioning. (in: query)
    ppt_host_user (str): Reference of the host OS user on the PPT host to use for linking. (in: query)
    sync_strategy_managed_type (str): MSSQL specific parameters for source based sync strategy.:
* `external` - MSSQL specific parameters for externally managed source based sync strategy.
* `delphix` - MSSQL specific parameters for delphix managed source based sync strategy.
* `staging_push` - MSSQL specific parameters for staging push based sync strategy. (in: query)
    source_host_user (str): ID or user reference of the host OS user to use for linking. (in: query)
    mssql_user_environment_reference (str): Reference to the source environment user to use for linking. (in: query)
    mssql_user_domain_username (str): The username for the source DB user. (in: query)
    mssql_user_domain_password (str): Password for the database user. (in: query)
    mssql_user_domain_vault_username (str): Delphix display name for the vault user. (in: query)
    mssql_user_domain_vault (str): The name or reference of the vault from which to read the database credentials. (in: query)
    mssql_user_domain_hashicorp_vault_engine (str): Vault engine name where the credential is stored. (in: query)
    mssql_user_domain_hashicorp_vault_secret_path (str): Path in the vault engine where the credential is stored. (in: query)
    mssql_user_domain_hashicorp_vault_username_key (str): Hashicorp vault key for the username in the key-value store. (in: query)
    mssql_user_domain_hashicorp_vault_secret_key (str): Hashicorp vault key for the password in the key-value store. (in: query)
    mssql_user_domain_azure_vault_name (str): Azure key vault name. (in: query)
    mssql_user_domain_azure_vault_username_key (str): Azure vault key for the username in the key-value store. (in: query)
    mssql_user_domain_azure_vault_secret_key (str): Azure vault key for the password in the key-value store. (in: query)
    mssql_user_domain_cyberark_vault_query_string (str): Query to find a credential in the CyberArk vault. (in: query)
    mssql_database_username (str): The username for the source DB user. (in: query)
    mssql_database_password (str): Password for the database user. (in: query)
    delphix_managed_backup_compression_enabled (bool): Specify whether the backups taken should be compressed or uncompressed when Delphix managed option is selected. (in: query)
    delphix_managed_backup_policy (str): Specify which node of an availability group to run the copy-only full backup on:
* `primary` - Backups only go to the primary node.
* `secondary_only` - Backups only go to secondary nodes. If secondary nodes are down, backups will fail.
* `prefer_secondary` - Backups go to secondary nodes, but if secondary nodes are down, backups will go to the primary node. (in: query)
    external_managed_validate_sync_mode (str): Specifies the backup types ValidatedSync will use to synchronize the dSource with the source database (in: query)
    external_managed_shared_backup_locations (Any): Shared source database backup locations. (in: query)
    disable_netbackup_config (bool): Disable NetBackup configuration. (in: query)
    external_netbackup_config_master_name (str): The master server name of this NetBackup configuration. (in: query)
    external_netbackup_config_source_client_name (str): The source's client server name of this NetBackup configuration. (in: query)
    external_netbackup_config_params (Any): NetBackup configuration parameter overrides. (in: query)
    external_netbackup_config_templates (str): Optional config template selection for NetBackup configurations. If set, external_netbackup_config_params will be ignored. (in: query)
    disable_commvault_config (bool): Disable Commvault configuration. (in: query)
    external_commserve_host_name (str): The commserve host name of this Commvault configuration. (in: query)
    external_commvault_config_source_client_name (str): The source client name of this Commvault configuration. (in: query)
    external_commvault_config_staging_client_name (str): The staging client name of this Commvault configuration. (in: query)
    external_commvault_config_params (Any): Commvault configuration parameter overrides. (in: query)
    external_commvault_config_templates (str): Optional config template selection for Commvault configurations. If set, configParams will be ignored. (in: query)
    hooks (Any): DSource operation hooks. (in: query)
    sync_policy_id (str): The ID of the SnapSync policy for the dSource. (in: query)
    retention_policy_id (str): The ID of the Retention policy for the dSource. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/mssql/{dsourceId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "logsync_enabled": logsync_enabled, "encryption_key": encryption_key, "ppt_repository": ppt_repository, "ppt_host_user": ppt_host_user, "sync_strategy_managed_type": sync_strategy_managed_type, "source_host_user": source_host_user, "mssql_user_environment_reference": mssql_user_environment_reference, "mssql_user_domain_username": mssql_user_domain_username, "mssql_user_domain_password": mssql_user_domain_password, "mssql_user_domain_vault_username": mssql_user_domain_vault_username, "mssql_user_domain_vault": mssql_user_domain_vault, "mssql_user_domain_hashicorp_vault_engine": mssql_user_domain_hashicorp_vault_engine, "mssql_user_domain_hashicorp_vault_secret_path": mssql_user_domain_hashicorp_vault_secret_path, "mssql_user_domain_hashicorp_vault_username_key": mssql_user_domain_hashicorp_vault_username_key, "mssql_user_domain_hashicorp_vault_secret_key": mssql_user_domain_hashicorp_vault_secret_key, "mssql_user_domain_azure_vault_name": mssql_user_domain_azure_vault_name, "mssql_user_domain_azure_vault_username_key": mssql_user_domain_azure_vault_username_key, "mssql_user_domain_azure_vault_secret_key": mssql_user_domain_azure_vault_secret_key, "mssql_user_domain_cyberark_vault_query_string": mssql_user_domain_cyberark_vault_query_string, "mssql_database_username": mssql_database_username, "mssql_database_password": mssql_database_password, "delphix_managed_backup_compression_enabled": delphix_managed_backup_compression_enabled, "delphix_managed_backup_policy": delphix_managed_backup_policy, "external_managed_validate_sync_mode": external_managed_validate_sync_mode, "external_managed_shared_backup_locations": external_managed_shared_backup_locations, "disable_netbackup_config": disable_netbackup_config, "external_netbackup_config_master_name": external_netbackup_config_master_name, "external_netbackup_config_source_client_name": external_netbackup_config_source_client_name, "external_netbackup_config_params": external_netbackup_config_params, "external_netbackup_config_templates": external_netbackup_config_templates, "disable_commvault_config": disable_commvault_config, "external_commserve_host_name": external_commserve_host_name, "external_commvault_config_source_client_name": external_commvault_config_source_client_name, "external_commvault_config_staging_client_name": external_commvault_config_staging_client_name, "external_commvault_config_params": external_commvault_config_params, "external_commvault_config_templates": external_commvault_config_templates, "hooks": hooks, "sync_policy_id": sync_policy_id, "retention_policy_id": retention_policy_id}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_dsource_snapshots(dsourceId: str, limit: Optional[int] = None, cursor: Optional[str] = None) -> dict:
    """
    GET /dsources/{dsourceId}/snapshots

    Args:
    dsourceId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/snapshots"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def snapshot_dsource(dsourceId: str, drop_and_recreate_devices: Optional[bool] = None, sync_strategy: Optional[str] = None, ase_backup_files: Optional[Any] = None, mssql_backup_uuid: Optional[str] = None, compression_enabled: Optional[bool] = None, availability_group_backup_policy: Optional[str] = None, do_not_resume: Optional[bool] = None, double_sync: Optional[bool] = None, force_full_backup: Optional[bool] = None, skip_space_check: Optional[bool] = None, files_for_partial_full_backup: Optional[Any] = None, appdata_parameters: Optional[Any] = None, rman_rate_in_MB: Optional[int] = None) -> dict:
    """
    POST /dsources/{dsourceId}/snapshots

    Args:
    dsourceId (str): Path parameter
    drop_and_recreate_devices (bool): If this parameter is set to true, older devices will be dropped and new
devices created instead of trying to remap the devices. This might increase
the space utilization on Delphix Engine. (ASE only) (in: query)
    sync_strategy (str): Determines how the Delphix Engine will take a backup:
* `latest_backup` - Use the most recent backup.
* `new_backup` - Delphix will take a new backup of your source database.
* `specific_backup` - Use a specific backup. Using this option requires setting
  `ase_backup_files` for ASE dSources or `mssql_backup_uuid` for MSSql dSources.
Default is `new_backup`.
(ASE, MSSql only) (in: query)
    ase_backup_files (Any): When using the `specific_backup` sync_strategy, determines the backup files. (ASE Only) (in: query)
    mssql_backup_uuid (str): When using the `specific_backup` sync_strategy, determines the Backup Set UUID. (MSSql only) (in: query)
    compression_enabled (bool): When using the `new_backup` sync_strategy, determines if compression must be enabled. Defaults to the configuration of the ingestion strategy configured on the Delphix Engine for this dSource. (MSSql only) (in: query)
    availability_group_backup_policy (str): When using the `new_backup` sync_strategy for an MSSql Availability Group, determines the backup policy:
* `primary` - Backups only go to the primary node.
* `secondary_only` - Backups only go to secondary nodes. If secondary nodes are down, backups will fail.
* `prefer_secondary` - Backups go to secondary nodes, but if secondary nodes are down, backups will go to the primary node.
(MSSql only) (in: query)
    do_not_resume (bool): Indicates whether a fresh SnapSync must be started regardless if it was possible to
resume the current SnapSync. If true, we will not resume but instead ignore previous progress
and backup all datafiles even if already completed from previous failed SnapSync. This does not
force a full backup, if an incremental was in progress this will start a new incremental snapshot.
(Oracle only) (in: query)
    double_sync (bool): Indicates whether two SnapSyncs should be performed in immediate succession to reduce the number
of logs required to provision the snapshot. This may significantly reduce the time necessary to
provision from a snapshot.
(Oracle only). (in: query)
    force_full_backup (bool): Whether or not to take another full backup of the source database. (Oracle only) (in: query)
    skip_space_check (bool): Skip check that tests if there is enough space available to store the database in
the Delphix Engine. The Delphix Engine estimates how much space a database will occupy after
compression and prevents SnapSync if insufficient space is available. This safeguard can be
overridden using this option. This may be useful when linking highly compressible databases.
(Oracle only) (in: query)
    files_for_partial_full_backup (Any): List of datafiles to take a full backup of. This would be useful in situations
where certain datafiles could not be backed up during previous SnapSync due to corruption
or because they went offline.
(Oracle only) (in: query)
    appdata_parameters (Any): The list of parameters specified by the snapshotParametersDefinition schema in the toolkit (AppData only). (in: query)
    rman_rate_in_MB (int): RMAN rate in megabytes to be used. This is the upper limit for bytes read so that 
RMAN does not consume excessive disk bandwidth and degrade online performance. (Oracle only) (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/snapshots"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"drop_and_recreate_devices": drop_and_recreate_devices, "sync_strategy": sync_strategy, "ase_backup_files": ase_backup_files, "mssql_backup_uuid": mssql_backup_uuid, "compression_enabled": compression_enabled, "availability_group_backup_policy": availability_group_backup_policy, "do_not_resume": do_not_resume, "double_sync": double_sync, "force_full_backup": force_full_backup, "skip_space_check": skip_space_check, "files_for_partial_full_backup": files_for_partial_full_backup, "appdata_parameters": appdata_parameters, "rman_rate_in_MB": rman_rate_in_MB}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_dsource_deletion_dependencies(dsourceId: str) -> dict:
    """
    GET /dsources/{dsourceId}/deletion-dependencies

    Args:
    dsourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/deletion-dependencies"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_tags_dsource(dsourceId: str) -> dict:
    """
    GET /dsources/{dsourceId}/tags

    Args:
    dsourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_tags_dsource(dsourceId: str, tags: Any) -> dict:
    """
    POST /dsources/{dsourceId}/tags

    Args:
    dsourceId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_tags_dsource(dsourceId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /dsources/{dsourceId}/tags/delete

    Args:
    dsourceId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_dsource_to_asm_by_snapshot(dsourceId: str) -> dict:
    """
    POST /dsources/{dsourceId}/asm-export-by-snapshot

    Args:
    dsourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/asm-export-by-snapshot"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_dsource_by_snapshot(dsourceId: str) -> dict:
    """
    POST /dsources/{dsourceId}/export-by-snapshot

    Args:
    dsourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/export-by-snapshot"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_dsource_to_asm_by_location(dsourceId: str) -> dict:
    """
    POST /dsources/{dsourceId}/asm-export-by-location

    Args:
    dsourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/asm-export-by-location"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_dsource_to_asm_by_bookmark(dsourceId: str) -> dict:
    """
    POST /dsources/{dsourceId}/asm-export-from-bookmark

    Args:
    dsourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/asm-export-from-bookmark"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_dsource_from_bookmark(dsourceId: str) -> dict:
    """
    POST /dsources/{dsourceId}/export-from-bookmark

    Args:
    dsourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/export-from-bookmark"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_dsource_to_asm_by_timestamp(dsourceId: str) -> dict:
    """
    POST /dsources/{dsourceId}/asm-export-by-timestamp

    Args:
    dsourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/asm-export-by-timestamp"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_dsource_by_timestamp(dsourceId: str) -> dict:
    """
    POST /dsources/{dsourceId}/export-by-timestamp

    Args:
    dsourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/export-by-timestamp"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_dsource_by_location(dsourceId: str) -> dict:
    """
    POST /dsources/{dsourceId}/export-by-location

    Args:
    dsourceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"dsources/{dsourceId}/export-by-location"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_kerberos_config_by_id(kerberosConfigId: str) -> dict:
    """
    GET /kerberos-configs/{kerberosConfigId}

    Args:
    kerberosConfigId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"kerberos-configs/{kerberosConfigId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def list_kerberos_configs(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /kerberos-configs

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"kerberos-configs"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_kerberos_configs(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /kerberos-configs/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"kerberos-configs/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_password_vaults(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /password_vaults

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"password_vaults"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_password_vaults(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /password_vaults/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"password_vaults/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_password_vault_by_id(passwordVaultId: str) -> dict:
    """
    GET /password_vaults/{passwordVaultId}

    Args:
    passwordVaultId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"password_vaults/{passwordVaultId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_dataset_groups(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /groups

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"groups"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_dataset_groups(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /groups/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"groups/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_dataset_group_by_id(groupId: str) -> dict:
    """
    GET /groups/{groupId}

    Args:
    groupId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"groups/{groupId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_toolkits(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /toolkits

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"toolkits"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_toolkits(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /toolkits/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"toolkits/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_toolkit_by_id(toolkitId: str) -> dict:
    """
    GET /toolkits/{toolkitId}

    Args:
    toolkitId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"toolkits/{toolkitId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_toolkit_tags(toolkitId: str) -> dict:
    """
    GET /toolkits/{toolkitId}/tags

    Args:
    toolkitId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"toolkits/{toolkitId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_toolkit_tags(toolkitId: str, tags: Any) -> dict:
    """
    POST /toolkits/{toolkitId}/tags

    Args:
    toolkitId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"toolkits/{toolkitId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_toolkit_tags(toolkitId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /toolkits/{toolkitId}/tags/delete

    Args:
    toolkitId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"toolkits/{toolkitId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_vdbs(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, permission: Optional[str] = None) -> dict:
    """
    GET /vdbs

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    permission (str): Restrict the objects, which are allowed. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort, "permission": permission}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_vdbs(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, permission: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /vdbs/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    permission (str): Restrict the objects, which are allowed. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "permission": permission, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_vdb_by_id(vdbId: str) -> dict:
    """
    GET /vdbs/{vdbId}

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_vdb_by_id(vdbId: str, name: Optional[str] = None, db_username: Optional[str] = None, db_password: Optional[str] = None, validate_db_credentials: Optional[bool] = None, auto_restart: Optional[bool] = None, environment_user_id: Optional[str] = None, template_id: Optional[str] = None, listener_ids: Optional[Any] = None, new_dbid: Optional[bool] = None, cdc_on_provision: Optional[bool] = None, pre_script: Optional[str] = None, post_script: Optional[str] = None, hooks: Optional[Any] = None, custom_env_vars: Optional[Any] = None, custom_env_files: Optional[Any] = None, oracle_rac_custom_env_files: Optional[Any] = None, oracle_rac_custom_env_vars: Optional[Any] = None, parent_tde_keystore_path: Optional[str] = None, parent_tde_keystore_password: Optional[str] = None, tde_key_identifier: Optional[str] = None, target_vcdb_tde_keystore_path: Optional[str] = None, cdb_tde_keystore_password: Optional[str] = None, appdata_source_params: Optional[Any] = None, additional_mount_points: Optional[Any] = None, appdata_config_params: Optional[Any] = None, config_params: Optional[Any] = None, mount_point: Optional[str] = None, oracle_services: Optional[Any] = None, instances: Optional[Any] = None, invoke_datapatch: Optional[bool] = None, mssql_ag_backup_location: Optional[str] = None, mssql_ag_backup_based: Optional[bool] = None) -> dict:
    """
    PATCH /vdbs/{vdbId}

    Args:
    vdbId (str): Path parameter
    name (str): The unique name of the VDB within a group. (in: query)
    db_username (str): The username of the database user (Oracle, ASE Only). (in: query)
    db_password (str): The password of the database user (Oracle, ASE Only). (in: query)
    validate_db_credentials (bool): Whether db_username and db_password must be validated, if present, against the VDB. This must be set to false when credentials validation is not possible, for instance if the VDB is known to be disabled. (in: query)
    auto_restart (bool): Whether to enable VDB restart. (in: query)
    environment_user_id (str): The environment user ID to use to connect to the target environment. (in: query)
    template_id (str): The ID of the target VDB Template (Oracle and MSSql Only). (in: query)
    listener_ids (Any): The listener IDs for this provision operation (Oracle Only). (in: query)
    new_dbid (bool): Whether to enable new DBID for Oracle (in: query)
    cdc_on_provision (bool): Whether to enable CDC on provision for MSSql (in: query)
    pre_script (str): Pre script for MSSql. (in: query)
    post_script (str): Post script for MSSql. (in: query)
    hooks (Any): VDB operation hooks. (in: query)
    custom_env_vars (Any): Environment variable to be set when the engine administers a VDB. See the Engine documentation for the list of allowed/denied environment variables and rules about substitution. Custom environment variables can only be updated while the VDB is disabled. (in: query)
    custom_env_files (Any): Environment files to be sourced when the Engine administers a VDB. This path can be followed by parameters. Paths and parameters are separated by spaces. Custom environment variables can only be updated while the VDB is disabled. (in: query)
    oracle_rac_custom_env_files (Any): Environment files to be sourced when the Engine administers an Oracle RAC VDB. This path can be followed by parameters. Paths and parameters are separated by spaces. Custom environment variables can only be updated while the VDB is disabled. (in: query)
    oracle_rac_custom_env_vars (Any): Environment variable to be set when the engine administers an Oracle RAC VDB. See the Engine documentation for the list of allowed/denied environment variables and rules about substitution. Custom environment variables can only be updated while the VDB is disabled. (in: query)
    parent_tde_keystore_path (str): Path to a copy of the parent's Oracle transparent data encryption keystore on the target host. Required to provision from snapshots containing encrypted database files. (Oracle Multitenant Only) (in: query)
    parent_tde_keystore_password (str): The password of the keystore specified in parentTdeKeystorePath. (Oracle Multitenant Only) (in: query)
    tde_key_identifier (str): ID of the key created by Delphix. (Oracle Multitenant Only) (in: query)
    target_vcdb_tde_keystore_path (str): Path to the keystore of the target vCDB. (Oracle Multitenant Only) (in: query)
    cdb_tde_keystore_password (str): The password for the Transparent Data Encryption keystore associated with the CDB. (Oracle Multitenant Only) (in: query)
    appdata_source_params (Any): The JSON payload conforming to the DraftV4 schema based on the type of application data being manipulated. (in: query)
    additional_mount_points (Any): Specifies additional locations on which to mount a subdirectory of an AppData container. Can only be updated while the VDB is disabled. (in: query)
    appdata_config_params (Any): The parameters specified by the source config schema in the toolkit (in: query)
    config_params (Any): Database configuration parameter overrides. (in: query)
    mount_point (str): Mount point for the VDB (AppData only), can only be updated while the VDB is disabled. (in: query)
    oracle_services (Any): List of jdbc connection strings which are used to connect with the database. (in: query)
    instances (Any): The instances of this RAC database. (in: query)
    invoke_datapatch (bool): Indicates whether datapatch should be invoked. (in: query)
    mssql_ag_backup_location (str): Shared backup location to be used for VDB provision on AG Cluster. (in: query)
    mssql_ag_backup_based (bool): Indicates whether to do fast operations for VDB on AG which will use a healthy secondary replica to recreate the AG or backup based operations which will use the primary replica to recreate the AG using backup and restore process. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "db_username": db_username, "db_password": db_password, "validate_db_credentials": validate_db_credentials, "auto_restart": auto_restart, "environment_user_id": environment_user_id, "template_id": template_id, "listener_ids": listener_ids, "new_dbid": new_dbid, "cdc_on_provision": cdc_on_provision, "pre_script": pre_script, "post_script": post_script, "hooks": hooks, "custom_env_vars": custom_env_vars, "custom_env_files": custom_env_files, "oracle_rac_custom_env_files": oracle_rac_custom_env_files, "oracle_rac_custom_env_vars": oracle_rac_custom_env_vars, "parent_tde_keystore_path": parent_tde_keystore_path, "parent_tde_keystore_password": parent_tde_keystore_password, "tde_key_identifier": tde_key_identifier, "target_vcdb_tde_keystore_path": target_vcdb_tde_keystore_path, "cdb_tde_keystore_password": cdb_tde_keystore_password, "appdata_source_params": appdata_source_params, "additional_mount_points": additional_mount_points, "appdata_config_params": appdata_config_params, "config_params": config_params, "mount_point": mount_point, "oracle_services": oracle_services, "instances": instances, "invoke_datapatch": invoke_datapatch, "mssql_ag_backup_location": mssql_ag_backup_location, "mssql_ag_backup_based": mssql_ag_backup_based}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_vdb_snapshots(vdbId: str, limit: Optional[int] = None, cursor: Optional[str] = None) -> dict:
    """
    GET /vdbs/{vdbId}/snapshots

    Args:
    vdbId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/snapshots"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def snapshot_vdb(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/snapshots

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/snapshots"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_bookmarks_by_vdb(vdbId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /vdbs/{vdbId}/bookmarks

    Args:
    vdbId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/bookmarks"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_bookmarks_by_vdb(vdbId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /vdbs/{vdbId}/bookmarks/search

    Args:
    vdbId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/bookmarks/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_vdb_deletion_dependencies(vdbId: str) -> dict:
    """
    GET /vdbs/{vdbId}/deletion-dependencies

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/deletion-dependencies"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_tags_vdb(vdbId: str) -> dict:
    """
    GET /vdbs/{vdbId}/tags

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_vdb_tags(vdbId: str, tags: Any) -> dict:
    """
    POST /vdbs/{vdbId}/tags

    Args:
    vdbId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_vdb_tags(vdbId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /vdbs/{vdbId}/tags/delete

    Args:
    vdbId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def start_vdb(vdbId: str, instances: Optional[Any] = None) -> dict:
    """
    POST /vdbs/{vdbId}/start

    Args:
    vdbId (str): Path parameter
    instances (Any): List of specific Oracle Virtual Database Instances to start. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/start"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"instances": instances}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def stop_vdb(vdbId: str, instances: Optional[Any] = None, abort: Optional[bool] = None) -> dict:
    """
    POST /vdbs/{vdbId}/stop

    Args:
    vdbId (str): Path parameter
    instances (Any): List of specific Oracle Virtual Database Instances to stop. (in: query)
    abort (bool): Whether to issue 'shutdown abort' to shutdown Oracle Virtual DB instances. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/stop"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"instances": instances, "abort": abort}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def enable_vdb(vdbId: str, attempt_start: Optional[bool] = None, container_mode: Optional[bool] = None, ownership_spec: Optional[str] = None) -> dict:
    """
    POST /vdbs/{vdbId}/enable

    Args:
    vdbId (str): Path parameter
    attempt_start (bool): Whether to attempt a startup of the VDB after the enable. (in: query)
    container_mode (bool): Whether the database is running inside a container. (in: query)
    ownership_spec (str): The uid:gid string that NFS mounts should belong to. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/enable"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"attempt_start": attempt_start, "container_mode": container_mode, "ownership_spec": ownership_spec}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def disable_vdb(vdbId: str, attempt_cleanup: Optional[bool] = None, container_mode: Optional[bool] = None) -> dict:
    """
    POST /vdbs/{vdbId}/disable

    Args:
    vdbId (str): Path parameter
    attempt_cleanup (bool): Whether to attempt a cleanup of the VDB before the disable. (in: query)
    container_mode (bool): Whether the database is running inside a container. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/disable"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"attempt_cleanup": attempt_cleanup, "container_mode": container_mode}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def migrate_vdb(vdbId: str, environment_id: Optional[str] = None, environment_user_ref: Optional[str] = None, repository_id: Optional[str] = None, cdb_id: Optional[str] = None) -> dict:
    """
    POST /vdbs/{vdbId}/migrate

    Args:
    vdbId (str): Path parameter
    environment_id (str): Id of the environment. (in: query)
    environment_user_ref (str): Reference of the environment user. (in: query)
    repository_id (str): Id of the environment repository. (in: query)
    cdb_id (str): Id of the container database. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/migrate"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"environment_id": environment_id, "environment_user_ref": environment_user_ref, "repository_id": repository_id, "cdb_id": cdb_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_migrate_compatible_repo(vdbId: str) -> dict:
    """
    GET /vdbs/{vdbId}/migrate_compatible_repositories

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/migrate_compatible_repositories"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def lock_vdb(vdbId: str, account_id: Optional[int] = None) -> dict:
    """
    POST /vdbs/{vdbId}/lock

    Args:
    vdbId (str): Path parameter
    account_id (int): Id of the account on whose behalf this request is being made. Only accounts having LOCK_FOR_OTHER_ACCOUNT permission can lock VDBs on behalf of other accounts. If this property is not specified then the account id of the authenticated user making the request is used. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/lock"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"account_id": account_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def unlock_vdb(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/unlock

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/unlock"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_vdb(vdbId: str, force: Optional[bool] = None, delete_all_dependent_vdbs: Optional[bool] = None) -> dict:
    """
    POST /vdbs/{vdbId}/delete

    Args:
    vdbId (str): Path parameter
    force (bool): Whether to continue the operation upon failures. (in: query)
    delete_all_dependent_vdbs (bool): Flag indicating whether to delete all dependent VDBs before deleting the VDB. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"force": force, "delete_all_dependent_vdbs": delete_all_dependent_vdbs}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def rollback_vdb_by_timestamp(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/rollback_by_timestamp

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/rollback_by_timestamp"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def rollback_vdb_by_snapshot(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/rollback_by_snapshot

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/rollback_by_snapshot"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def rollback_vdb_from_bookmark(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/rollback_from_bookmark

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/rollback_from_bookmark"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def refresh_vdb_by_timestamp(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/refresh_by_timestamp

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/refresh_by_timestamp"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def refresh_vdb_by_snapshot(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/refresh_by_snapshot

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/refresh_by_snapshot"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def refresh_vdb_from_bookmark(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/refresh_from_bookmark

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/refresh_from_bookmark"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def refresh_vdb_by_location(vdbId: str, location: Optional[str] = None, dataset_id: Optional[str] = None, timeflow_id: Optional[str] = None) -> dict:
    """
    POST /vdbs/{vdbId}/refresh_by_location

    Args:
    vdbId (str): Path parameter
    location (str): The database specific identifier for tracking transactions (SCN, LSN, etc). (in: query)
    dataset_id (str): ID of the dataset to refresh to, mutually exclusive with timeflow_id. (in: query)
    timeflow_id (str): ID of the timeflow to refresh to, mutually exclusive with dataset_id. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/refresh_by_location"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"location": location, "dataset_id": dataset_id, "timeflow_id": timeflow_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def undo_refresh(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/undo_refresh

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/undo_refresh"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def switch_timeflow(vdbId: str, timeflow_id: Optional[str] = None) -> dict:
    """
    POST /vdbs/{vdbId}/switch_timeflow

    Args:
    vdbId (str): Path parameter
    timeflow_id (str): The ID of the timeflow to switch to. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/switch_timeflow"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"timeflow_id": timeflow_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def upgrade_oracle_vdb(vdbId: str, repository_id: str, environment_user_id: str) -> dict:
    """
    This API is marked as deprecated in favour of generalized API '/vdbs/{vdbId}/upgrade'

    Args:
    vdbId (str): Path parameter
    repository_id (str): The id of the dSource/VDB repository to upgrade to. (in: query)
    environment_user_id (str): Reference of the environment user to use for dSource/VDB upgrade. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/oracle/{vdbId}/upgrade"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"repository_id": repository_id, "environment_user_id": environment_user_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def upgrade_vdb(vdbId: str, repository_id: str, environment_user_id: Optional[str] = None, ppt_repository: Optional[str] = None) -> dict:
    """
    POST /vdbs/{vdbId}/upgrade

    Args:
    vdbId (str): Path parameter
    repository_id (str): The id of the dSource/VDB repository to upgrade to. (in: query)
    environment_user_id (str): Reference of the environment user to use for dSource/VDB upgrade. (in: query)
    ppt_repository (str): The id of the SQL instance on the PPT environment that we want to use for pre-provisioning (MSSQL only). (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/upgrade"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"repository_id": repository_id, "environment_user_id": environment_user_id, "ppt_repository": ppt_repository}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_upgrade_compatible_repo_for_vdb(vdbId: str) -> dict:
    """
    GET /vdbs/{vdbId}/upgrade_compatible_repositories

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/upgrade_compatible_repositories"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def verify_vdb_jdbc_connection_string(vdbId: str, database_username: str, database_password: str, jdbc_connection_string: str) -> dict:
    """
    POST /vdbs/{vdbId}/jdbc-check

    Args:
    vdbId (str): Path parameter
    database_username (str): oracle database username. (in: query)
    database_password (str): oracle database password. (in: query)
    jdbc_connection_string (str): Oracle jdbc connection string to validate. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/jdbc-check"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"database_username": database_username, "database_password": database_password, "jdbc_connection_string": jdbc_connection_string}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def provision_vdb_by_timestamp(args: Optional[dict] = None) -> dict:
    """
    POST /vdbs/provision_by_timestamp

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/provision_by_timestamp"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def provision_vdb_by_timestamp_defaults(source_data_id: str, timestamp: Optional[str] = None, timestamp_in_database_timezone: Optional[str] = None, engine_id: Optional[str] = None, timeflow_id: Optional[str] = None) -> dict:
    """
    POST /vdbs/provision_by_timestamp/defaults

    Args:
    timestamp (str): The point in time from which to execute the operation. Mutually exclusive with timestamp_in_database_timezone. If the timestamp is not set, selects the latest point. (in: query)
    timestamp_in_database_timezone (str): The point in time from which to execute the operation, expressed as a date-time in the timezone of the source database. Mutually exclusive with timestamp. (in: query)
    engine_id (str): The ID of the Engine onto which to provision. If the source ID unambiguously identifies a source object, this parameter is unnecessary and ignored. (in: query)
    source_data_id (str): The ID of the source object (dSource or VDB) to provision from. All other objects referenced by the parameters must live on the same engine as the source. (in: query)
    timeflow_id (str): The Timeflow ID. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/provision_by_timestamp/defaults"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"timestamp": timestamp, "timestamp_in_database_timezone": timestamp_in_database_timezone, "engine_id": engine_id, "source_data_id": source_data_id, "timeflow_id": timeflow_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def provision_vdb_by_location(args: Optional[dict] = None) -> dict:
    """
    POST /vdbs/provision_by_location

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/provision_by_location"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def provision_vdb_by_location_defaults(source_data_id: Optional[str] = None, engine_id: Optional[str] = None, location: Optional[str] = None, timeflow_id: Optional[str] = None) -> dict:
    """
    POST /vdbs/provision_by_location/defaults

    Args:
    source_data_id (str): The ID of the source object (dSource or VDB) to provision from. All other objects referenced by the parameters must live on the same engine as the source. (in: query)
    engine_id (str): The ID of the Engine onto which to provision. If the source ID unambiguously identifies a source object, this parameter is unnecessary and ignored. (in: query)
    location (str): The location to get the defaults from. (in: query)
    timeflow_id (str): ID of the timeflow to provision from. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/provision_by_location/defaults"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"source_data_id": source_data_id, "engine_id": engine_id, "location": location, "timeflow_id": timeflow_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def provision_vdb_by_snapshot(args: Optional[dict] = None) -> dict:
    """
    POST /vdbs/provision_by_snapshot

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/provision_by_snapshot"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def provision_vdb_by_snapshot_defaults(snapshot_id: Optional[str] = None, engine_id: Optional[str] = None, source_data_id: Optional[str] = None) -> dict:
    """
    POST /vdbs/provision_by_snapshot/defaults

    Args:
    snapshot_id (str): The ID of the snapshot from which to execute the operation. (in: query)
    engine_id (str): The ID of the Engine onto which to provision. If the source ID unambiguously identifies a source object, this parameter is unnecessary and ignored. (in: query)
    source_data_id (str): The ID of the source object (dSource or VDB) to provision from. If this property is not set, the data_source of the snapshot_id will be used. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/provision_by_snapshot/defaults"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"snapshot_id": snapshot_id, "engine_id": engine_id, "source_data_id": source_data_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def provision_vdb_from_bookmark(args: Optional[dict] = None) -> dict:
    """
    POST /vdbs/provision_from_bookmark

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/provision_from_bookmark"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def provision_vdb_from_bookmark_defaults(bookmark_id: str) -> dict:
    """
    POST /vdbs/provision_from_bookmark/defaults

    Args:
    bookmark_id (str): The ID of the bookmark from which to execute the operation. The bookmark must contain only one VDB. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/provision_from_bookmark/defaults"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"bookmark_id": bookmark_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def oracle_asm_in_place_vdb_export(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/asm-in-place-export

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/asm-in-place-export"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_vdb_in_place(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/in-place-export

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/in-place-export"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_vdb_to_asm_by_snapshot(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/asm-export-by-snapshot

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/asm-export-by-snapshot"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_vdb_to_asm_by_location(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/asm-export-by-location

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/asm-export-by-location"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_vdb_to_asm_by_timestamp(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/asm-export-by-timestamp

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/asm-export-by-timestamp"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_vdb_from_bookmark(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/export-from-bookmark

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/export-from-bookmark"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_vdb_to_asm_by_bookmark(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/asm-export-from-bookmark

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/asm-export-from-bookmark"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_vdb_by_timestamp(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/export-by-timestamp

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/export-by-timestamp"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_vdb_by_snapshot(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/export-by-snapshot

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/export-by-snapshot"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def export_vdb_by_location(vdbId: str) -> dict:
    """
    POST /vdbs/{vdbId}/export-by-location

    Args:
    vdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdbs/{vdbId}/export-by-location"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_vdb_groups(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /vdb-groups

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_vdb_group(name: str, vdb_ids: Optional[Any] = None, vdbs: Optional[Any] = None, tags: Optional[Any] = None, make_current_account_owner: Optional[bool] = None, refresh_immediately: Optional[bool] = None) -> dict:
    """
    POST /vdb-groups

    Args:
    name (str): name (in: query)
    vdb_ids (Any): vdb_ids (in: query)
    vdbs (Any): Dictates order of operations on VDBs. Operations can be performed in parallel <br> for all VDBs or sequentially. Below are possible valid and invalid orderings given an example <br> VDB group with 3 vdbs (A, B, and C).<br> Valid:<br> {"vdb_id":"vdb-1", "order":"1"} {"vdb_id":"vdb-2", order:"1"} {vdb_id:"vdb-3", order:"1"} (parallel)<br> {vdb_id:"vdb-1", order:"1"} {vdb_id:"vdb-2", order:"2"} {vdb_id:"vdb-3", order:"3"} (sequential)<br> Invalid:<br> {vdb_id:"vdb-1", order:"A"} {vdb_id:"vdb-2", order:"B"} {vdb_id:"vdb-3", order:"C"} (sequential)<br><br> In the sequential case the vdbs with priority 1 is the first to be started and the last to<br> be stopped. This value is set on creation of VDB groups. (in: query)
    tags (Any): The tags to be created for VDB Group. (in: query)
    make_current_account_owner (bool): Whether the account creating this VDB group must be configured as owner of the VDB group. (in: query)
    refresh_immediately (bool): If true, VDB Group will be refreshed immediately after creation. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "vdb_ids": vdb_ids, "vdbs": vdbs, "tags": tags, "make_current_account_owner": make_current_account_owner, "refresh_immediately": refresh_immediately}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def provision_vdb_group_from_bookmark(name: str, bookmark_id: str, provision_parameters: Any, tags: Optional[Any] = None, make_current_account_owner: Optional[bool] = None) -> dict:
    """
    POST /vdb-groups/provision_from_bookmark

    Args:
    name (str): Name of the created VDB group name. (in: query)
    bookmark_id (str): ID of a bookmark to provision this VDB Group from. (in: query)
    provision_parameters (Any): Provision parameters for each of the VDBs which will need to be provisioned. The key must be the vdb_id of the corresponding entry from the bookmark, and the value the provision parameters for the VDB which will be cloned from the bookmark. (in: query)
    tags (Any): The tags to be created for VDB Group. (in: query)
    make_current_account_owner (bool): Whether the account provisioning this VDB group must be configured as owner of the VDB group. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/provision_from_bookmark"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "bookmark_id": bookmark_id, "provision_parameters": provision_parameters, "tags": tags, "make_current_account_owner": make_current_account_owner}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_vdb_groups(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /vdb-groups/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_vdb_group(vdbGroupId: str) -> dict:
    """
    GET /vdb-groups/{vdbGroupId}

    Args:
    vdbGroupId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_vdb_group(vdbGroupId: str) -> dict:
    """
    DELETE /vdb-groups/{vdbGroupId}

    Args:
    vdbGroupId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_vdb_group_by_id(vdbGroupId: str, name: Optional[str] = None, vdb_ids: Optional[Any] = None, vdbs: Optional[Any] = None, refresh_immediately: Optional[bool] = None) -> dict:
    """
    PATCH /vdb-groups/{vdbGroupId}

    Args:
    vdbGroupId (str): Path parameter
    name (str): The name of the VDB group. (in: query)
    vdb_ids (Any): vdb_ids (in: query)
    vdbs (Any): Dictates order of operations on VDBs. Operations can be performed in parallel <br> for all VDBs or sequentially. Below are possible valid and invalid orderings given an example <br> VDB group with 3 vdbs (A, B, and C).<br> Valid:<br> {"vdb_id":"vdb-1", "order":"1"} {"vdb_id":"vdb-2", order:"1"} {vdb_id:"vdb-3", order:"1"} (parallel)<br> {vdb_id:"vdb-1", order:"1"} {vdb_id:"vdb-2", order:"2"} {vdb_id:"vdb-3", order:"3"} (sequential)<br> Invalid:<br> {vdb_id:"vdb-1", order:"A"} {vdb_id:"vdb-2", order:"B"} {vdb_id:"vdb-3", order:"C"} (sequential)<br><br> In the sequential case the vdbs with priority 1 is the first to be started and the last to<br> be stopped. This value is set on creation of VDB groups. (in: query)
    refresh_immediately (bool): If true, the VDB Group will be refreshed immediately after the update. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "vdb_ids": vdb_ids, "vdbs": vdbs, "refresh_immediately": refresh_immediately}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_vdb_group_vdbs_latest_snapshots(vdbGroupId: str) -> dict:
    """
    GET /vdb-groups/{vdbGroupId}/latest-snapshots

    Args:
    vdbGroupId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/latest-snapshots"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_vdb_group_timestamp_summary(vdbGroupId: str, timestamp: Optional[str] = None, vdb_ids: Optional[Any] = None, mode: Optional[str] = None) -> dict:
    """
    POST /vdb-groups/{vdbGroupId}/timestamp-summary

    Args:
    vdbGroupId (str): Path parameter
    timestamp (str): The timestamp to get the summary for. (in: query)
    vdb_ids (Any): vdb ids for which summary is needed. (in: query)
    mode (str): Refresh Mode either self or parent, if PARENT then VDB Group is refreshed from parent of each VDB, else refreshed from self. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/timestamp-summary"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"timestamp": timestamp, "vdb_ids": vdb_ids, "mode": mode}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_vdb_group_tags(vdbGroupId: str) -> dict:
    """
    GET /vdb-groups/{vdbGroupId}/tags

    Args:
    vdbGroupId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_vdb_groups_tags(vdbGroupId: str, tags: Any) -> dict:
    """
    POST /vdb-groups/{vdbGroupId}/tags

    Args:
    vdbGroupId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_vdb_group_tags(vdbGroupId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /vdb-groups/{vdbGroupId}/tags/delete

    Args:
    vdbGroupId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def refresh_vdb_group(vdbGroupId: str, bookmark_id: str) -> dict:
    """
    This API is marked as deprecated in favour of renamed API '/vdb-groups/{vdbGroupId}/refresh_from_bookmark'

    Args:
    vdbGroupId (str): Path parameter
    bookmark_id (str): ID of a bookmark to refresh this VDB Group to. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/refresh"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"bookmark_id": bookmark_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def refresh_vdb_group_from_bookmark(vdbGroupId: str, bookmark_id: str) -> dict:
    """
    POST /vdb-groups/{vdbGroupId}/refresh_from_bookmark

    Args:
    vdbGroupId (str): Path parameter
    bookmark_id (str): ID of a bookmark to refresh this VDB Group to. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/refresh_from_bookmark"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"bookmark_id": bookmark_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def refresh_vdb_group_by_snapshot(vdbGroupId: str, vdb_snapshot_mappings: Optional[Any] = None) -> dict:
    """
    POST /vdb-groups/{vdbGroupId}/refresh_by_snapshot

    Args:
    vdbGroupId (str): Path parameter
    vdb_snapshot_mappings (Any): List of the pair of VDB and snapshot to refresh from. If this is not set, all VDBs will be refreshed from latest snapshot of their parent. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/refresh_by_snapshot"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"vdb_snapshot_mappings": vdb_snapshot_mappings}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def refresh_vdb_group_by_timestamp(vdbGroupId: str, vdb_timestamp_mappings: Optional[Any] = None, is_refresh_to_nearest: Optional[bool] = None) -> dict:
    """
    POST /vdb-groups/{vdbGroupId}/refresh_by_timestamp

    Args:
    vdbGroupId (str): Path parameter
    vdb_timestamp_mappings (Any): List of the pair of VDB and timestamp to refresh from. If this is not set, all VDBs will be refreshed from latest timestamp of their parent. (in: query)
    is_refresh_to_nearest (bool): If true, and the provided timestamp is not found for the VDB mapping, the system will attempt to find the nearest previous refresh point. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/refresh_by_timestamp"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"vdb_timestamp_mappings": vdb_timestamp_mappings, "is_refresh_to_nearest": is_refresh_to_nearest}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def rollback_vdb_group(vdbGroupId: str, bookmark_id: str) -> dict:
    """
    This API is marked as deprecated in favour of API '/vdb-groups/{vdbGroupId}/refresh_from_bookmark'

    Args:
    vdbGroupId (str): Path parameter
    bookmark_id (str): ID of a bookmark to rollback this VDB Group to. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/rollback"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"bookmark_id": bookmark_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_bookmarks_by_vdb_group(vdbGroupId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /vdb-groups/{vdbGroupId}/bookmarks

    Args:
    vdbGroupId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/bookmarks"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_bookmarks_by_vdb_group(vdbGroupId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /vdb-groups/{vdbGroupId}/bookmarks/search

    Args:
    vdbGroupId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/bookmarks/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def lock_vdb_group(vdbGroupId: str, account_id: Optional[int] = None) -> dict:
    """
    POST /vdb-groups/{vdbGroupId}/lock

    Args:
    vdbGroupId (str): Path parameter
    account_id (int): Id of the account on whose behalf this request is being made. Only accounts having LOCK_FOR_OTHER_ACCOUNT permission can lock VDB Groups on behalf of other accounts. If this property is not specified then the account id of the authenticated user making the request is used. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/lock"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"account_id": account_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def unlock_vdb_group(vdbGroupId: str) -> dict:
    """
    POST /vdb-groups/{vdbGroupId}/unlock

    Args:
    vdbGroupId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/unlock"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def start_vdb_group(vdbGroupId: str, vdb_start_param_mappings: Optional[Any] = None) -> dict:
    """
    POST /vdb-groups/{vdbGroupId}/start

    Args:
    vdbGroupId (str): Path parameter
    vdb_start_param_mappings (Any): vdb_start_param_mappings (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/start"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"vdb_start_param_mappings": vdb_start_param_mappings}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def stop_vdb_group(vdbGroupId: str, vdb_stop_param_mappings: Optional[Any] = None) -> dict:
    """
    POST /vdb-groups/{vdbGroupId}/stop

    Args:
    vdbGroupId (str): Path parameter
    vdb_stop_param_mappings (Any): vdb_stop_param_mappings (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/stop"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"vdb_stop_param_mappings": vdb_stop_param_mappings}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def enable_vdb_group(vdbGroupId: str, vdb_enable_param_mappings: Optional[Any] = None) -> dict:
    """
    POST /vdb-groups/{vdbGroupId}/enable

    Args:
    vdbGroupId (str): Path parameter
    vdb_enable_param_mappings (Any): vdb_enable_param_mappings (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/enable"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"vdb_enable_param_mappings": vdb_enable_param_mappings}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def disable_vdb_group(vdbGroupId: str, vdb_disable_param_mappings: Optional[Any] = None) -> dict:
    """
    POST /vdb-groups/{vdbGroupId}/disable

    Args:
    vdbGroupId (str): Path parameter
    vdb_disable_param_mappings (Any): vdb_disable_param_mappings (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vdb-groups/{vdbGroupId}/disable"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"vdb_disable_param_mappings": vdb_disable_param_mappings}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_snapshots(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /snapshots

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_snapshot_by_id(snapshotId: str) -> dict:
    """
    GET /snapshots/{snapshotId}

    Args:
    snapshotId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots/{snapshotId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_snapshot(snapshotId: str) -> dict:
    """
    DELETE /snapshots/{snapshotId}

    Args:
    snapshotId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots/{snapshotId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_snapshot(snapshotId: str, expiration: Optional[str] = None, retain_forever: Optional[bool] = None) -> dict:
    """
    PATCH /snapshots/{snapshotId}

    Args:
    snapshotId (str): Path parameter
    expiration (str): The expiration for this snapshot. Mutually exclusive with retain_forever. (in: query)
    retain_forever (bool): Indicates that the snapshot should be retained forever. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots/{snapshotId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"expiration": expiration, "retain_forever": retain_forever}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_snapshot_by_id(snapshotId: str, delete_all_dependencies: Optional[bool] = None) -> dict:
    """
    POST /snapshots/{snapshotId}/delete

    Args:
    snapshotId (str): Path parameter
    delete_all_dependencies (bool): Whether to delete the snapshot along with all of its dependencies. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots/{snapshotId}/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"delete_all_dependencies": delete_all_dependencies}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def unset_snapshot_retention(snapshotId: str) -> dict:
    """
    POST /snapshots/{snapshotId}/unset_expiration

    Args:
    snapshotId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots/{snapshotId}/unset_expiration"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_snapshot_tags(snapshotId: str) -> dict:
    """
    GET /snapshots/{snapshotId}/tags

    Args:
    snapshotId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots/{snapshotId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_snapshot_tags(snapshotId: str, tags: Any) -> dict:
    """
    POST /snapshots/{snapshotId}/tags

    Args:
    snapshotId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots/{snapshotId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_snapshot_tags(snapshotId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /snapshots/{snapshotId}/tags/delete

    Args:
    snapshotId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots/{snapshotId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_snapshots(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /snapshots/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def find_by_location(args: Optional[dict] = None) -> dict:
    """
    GET /snapshots/find_by_location

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots/find_by_location"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def find_by_timestamp(args: Optional[dict] = None) -> dict:
    """
    GET /snapshots/find_by_timestamp

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots/find_by_timestamp"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_snapshot_timeflow_range(snapshotId: str) -> dict:
    """
    GET /snapshots/{snapshotId}/timeflow_range

    Args:
    snapshotId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots/{snapshotId}/timeflow_range"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_snapshot_runtime_by_id(snapshotId: str) -> dict:
    """
    GET /snapshots/{snapshotId}/runtime

    Args:
    snapshotId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots/{snapshotId}/runtime"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_snapshots_capacity_data(args: Optional[dict] = None) -> dict:
    """
    GET /snapshots/capacity

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots/capacity"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_shared_snapshot_space(args: Optional[dict] = None) -> dict:
    """
    GET /snapshots/shared-space

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots/shared-space"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_snapshot_deletion_dependencies(snapshotId: str) -> dict:
    """
    GET /snapshots/{snapshotId}/deletion-dependencies

    Args:
    snapshotId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"snapshots/{snapshotId}/deletion-dependencies"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_timeflows(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /timeflows

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"timeflows"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_timeflow_by_id(timeflowId: str) -> dict:
    """
    GET /timeflows/{timeflowId}

    Args:
    timeflowId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"timeflows/{timeflowId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_timeflow(timeflowId: str, force_delete: Optional[bool] = None) -> dict:
    """
    DELETE /timeflows/{timeflowId}

    Args:
    timeflowId (str): Path parameter
    force_delete (bool): Whether to delete all the dependent Bookmarks. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"timeflows/{timeflowId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"force_delete": force_delete}

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_timeflow(timeflowId: str, name: Optional[str] = None) -> dict:
    """
    PATCH /timeflows/{timeflowId}

    Args:
    timeflowId (str): Path parameter
    name (str): The name of the timeflow. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"timeflows/{timeflowId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_timeflow_snapshot_day_range(timeflowId: str) -> dict:
    """
    GET /timeflows/{timeflowId}/timeflowSnapshotDayRange

    Args:
    timeflowId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"timeflows/{timeflowId}/timeflowSnapshotDayRange"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_timeflow_tags(timeflowId: str) -> dict:
    """
    GET /timeflows/{timeflowId}/tags

    Args:
    timeflowId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"timeflows/{timeflowId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_timeflow_tags(timeflowId: str, tags: Any) -> dict:
    """
    POST /timeflows/{timeflowId}/tags

    Args:
    timeflowId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"timeflows/{timeflowId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_timeflow_tags(timeflowId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /timeflows/{timeflowId}/tags/delete

    Args:
    timeflowId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"timeflows/{timeflowId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_timeflows(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /timeflows/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"timeflows/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def timeflow_repair(timeflowId: str, host: str, username: str, directory: str, start_location: str, end_location: str, port: Optional[int] = None, use_engine_public_key: Optional[bool] = None, password: Optional[str] = None, key_pair_private_key: Optional[str] = None, key_pair_public_key: Optional[str] = None, vault_id: Optional[str] = None, hashicorp_vault_engine: Optional[str] = None, hashicorp_vault_secret_path: Optional[str] = None, hashicorp_vault_username_key: Optional[str] = None, hashicorp_vault_secret_key: Optional[str] = None, azure_vault_name: Optional[str] = None, azure_vault_username_key: Optional[str] = None, azure_vault_secret_key: Optional[str] = None, cyberark_vault_query_string: Optional[str] = None, use_kerberos_authentication: Optional[bool] = None, sshVerificationStrategy: Optional[str] = None) -> dict:
    """
    POST /timeflows/{timeflowId}/repair

    Args:
    timeflowId (str): Path parameter
    host (str): Hostname of the remote host. (in: query)
    port (int): Port to connect to remote host. (in: query)
    username (str): Username to connect to remote host. (in: query)
    directory (str): Location of the missing logs on the host. (in: query)
    start_location (str): The database specific identifier specifying the start location of the missing log. (in: query)
    end_location (str): The database specific identifier specifying the end location of the missing log. (in: query)
    use_engine_public_key (bool): Whether to use public key authentication. (in: query)
    password (str): The password of the user to connect to remote host machine. (in: query)
    key_pair_private_key (str): The private key of the key pair credentials. (in: query)
    key_pair_public_key (str): The public key of the key pair credentials. (in: query)
    vault_id (str): The DCT id or name of the vault from which to read the host credentials. (in: query)
    hashicorp_vault_engine (str): Vault engine name where the credential is stored. (in: query)
    hashicorp_vault_secret_path (str): Path in the vault engine where the credential is stored. (in: query)
    hashicorp_vault_username_key (str): Key for the username in the key-value store. (in: query)
    hashicorp_vault_secret_key (str): Key for the password in the key-value store. (in: query)
    azure_vault_name (str): Azure key vault name (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    azure_vault_username_key (str): Azure vault key for the username in the key-value store (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    azure_vault_secret_key (str): Azure vault key for the password in the key-value store (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    cyberark_vault_query_string (str): Query to find a credential in the CyberArk vault. (in: query)
    use_kerberos_authentication (bool): Whether to use kerberos authentication. (in: query)
    sshVerificationStrategy (str): Mechanism to use for ssh host verification. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"timeflows/{timeflowId}/repair"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"host": host, "port": port, "username": username, "directory": directory, "start_location": start_location, "end_location": end_location, "use_engine_public_key": use_engine_public_key, "password": password, "key_pair_private_key": key_pair_private_key, "key_pair_public_key": key_pair_public_key, "vault_id": vault_id, "hashicorp_vault_engine": hashicorp_vault_engine, "hashicorp_vault_secret_path": hashicorp_vault_secret_path, "hashicorp_vault_username_key": hashicorp_vault_username_key, "hashicorp_vault_secret_key": hashicorp_vault_secret_key, "azure_vault_name": azure_vault_name, "azure_vault_username_key": azure_vault_username_key, "azure_vault_secret_key": azure_vault_secret_key, "cyberark_vault_query_string": cyberark_vault_query_string, "use_kerberos_authentication": use_kerberos_authentication, "sshVerificationStrategy": sshVerificationStrategy}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_environments(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /environments

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_environment(engine_id: str, os_name: str, hostname: str, name: Optional[str] = None, is_cluster: Optional[bool] = None, cluster_home: Optional[str] = None, staging_environment: Optional[str] = None, connector_port: Optional[int] = None, connector_authentication_key: Optional[str] = None, is_target: Optional[bool] = None, ssh_port: Optional[int] = None, toolkit_path: Optional[str] = None, username: Optional[str] = None, password: Optional[str] = None, vault: Optional[str] = None, vault_username: Optional[str] = None, hashicorp_vault_engine: Optional[str] = None, hashicorp_vault_secret_path: Optional[str] = None, hashicorp_vault_username_key: Optional[str] = None, hashicorp_vault_secret_key: Optional[str] = None, cyberark_vault_query_string: Optional[str] = None, azure_vault_name: Optional[str] = None, azure_vault_username_key: Optional[str] = None, azure_vault_secret_key: Optional[str] = None, use_kerberos_authentication: Optional[bool] = None, use_engine_public_key: Optional[bool] = None, nfs_addresses: Optional[Any] = None, ase_db_vault_username: Optional[str] = None, ase_db_username: Optional[str] = None, ase_db_password: Optional[str] = None, ase_db_vault: Optional[str] = None, ase_db_hashicorp_vault_engine: Optional[str] = None, ase_db_hashicorp_vault_secret_path: Optional[str] = None, ase_db_hashicorp_vault_username_key: Optional[str] = None, ase_db_hashicorp_vault_secret_key: Optional[str] = None, ase_db_cyberark_vault_query_string: Optional[str] = None, ase_db_use_kerberos_authentication: Optional[bool] = None, ase_db_azure_vault_name: Optional[str] = None, ase_db_azure_vault_username_key: Optional[str] = None, ase_db_azure_vault_secret_key: Optional[str] = None, java_home: Optional[str] = None, dsp_keystore_path: Optional[str] = None, dsp_keystore_password: Optional[str] = None, dsp_keystore_alias: Optional[str] = None, dsp_truststore_path: Optional[str] = None, dsp_truststore_password: Optional[str] = None, description: Optional[str] = None, tags: Optional[Any] = None, make_current_account_owner: Optional[bool] = None) -> dict:
    """
    POST /environments

    Args:
    name (str): The name of the environment. (in: query)
    engine_id (str): The ID of the Engine onto which to create the environment. (in: query)
    os_name (str): Operating system type of the environment. (in: query)
    is_cluster (bool): Whether the environment to be created is a cluster. (in: query)
    cluster_home (str): Absolute path to cluster home drectory. This parameter is mandatory for UNIX cluster environments. (in: query)
    hostname (str): host address of the machine. (in: query)
    staging_environment (str): Id of the connector environment which is used to connect to this source environment. This is mandatory parameter when creating Windows source environments. (in: query)
    connector_port (int): Specify port on which Delphix connector will run. This is mandatory parameter when creating Windows target environments. (in: query)
    connector_authentication_key (str): Unique per Delphix key used to authenticate with the remote Delphix Connector. (in: query)
    is_target (bool): Whether the environment to be created is a target cluster environment. This property is used only when creating Windows cluster environments. (in: query)
    ssh_port (int): ssh port of the host. (in: query)
    toolkit_path (str): The path for the toolkit that resides on the host. (in: query)
    username (str): Username of the OS. (in: query)
    password (str): Password of the OS. (in: query)
    vault (str): The name or reference of the vault from which to read the host credentials. (in: query)
    vault_username (str): Delphix display name for the vault user (in: query)
    hashicorp_vault_engine (str): Vault engine name where the credential is stored. (in: query)
    hashicorp_vault_secret_path (str): Path in the vault engine where the credential is stored. (in: query)
    hashicorp_vault_username_key (str): Key for the username in the key-value store. (in: query)
    hashicorp_vault_secret_key (str): Key for the password in the key-value store. (in: query)
    cyberark_vault_query_string (str): Query to find a credential in the CyberArk vault. (in: query)
    azure_vault_name (str): Azure key vault name. (in: query)
    azure_vault_username_key (str): Azure vault key for the username in the key-value store. (in: query)
    azure_vault_secret_key (str): Azure vault key for the password in the key-value store. (in: query)
    use_kerberos_authentication (bool): Whether to use kerberos authentication. (in: query)
    use_engine_public_key (bool): Whether to use public key authentication. (in: query)
    nfs_addresses (Any): array of ip address or hostnames (in: query)
    ase_db_vault_username (str): Delphix display name for the vault user (in: query)
    ase_db_username (str): username of the SAP ASE database. (in: query)
    ase_db_password (str): password of the SAP ASE database. (in: query)
    ase_db_vault (str): The name or reference of the vault from which to read the ASE database credentials. (in: query)
    ase_db_hashicorp_vault_engine (str): Vault engine name where the credential is stored. (in: query)
    ase_db_hashicorp_vault_secret_path (str): Path in the vault engine where the credential is stored. (in: query)
    ase_db_hashicorp_vault_username_key (str): Key for the username in the key-value store. (in: query)
    ase_db_hashicorp_vault_secret_key (str): Key for the password in the key-value store. (in: query)
    ase_db_cyberark_vault_query_string (str): Query to find a credential in the CyberArk vault. (in: query)
    ase_db_use_kerberos_authentication (bool): Whether to use kerberos authentication for ASE DB discovery. (in: query)
    ase_db_azure_vault_name (str): Azure key vault name. (in: query)
    ase_db_azure_vault_username_key (str): Azure vault key for the username in the key-value store. (in: query)
    ase_db_azure_vault_secret_key (str): Azure vault key for the password in the key-value store. (in: query)
    java_home (str): The path to the user managed Java Development Kit (JDK). If not specified, then the OpenJDK will be used. (in: query)
    dsp_keystore_path (str): DSP keystore path. (in: query)
    dsp_keystore_password (str): DSP keystore password. (in: query)
    dsp_keystore_alias (str): DSP keystore alias. (in: query)
    dsp_truststore_path (str): DSP truststore path. (in: query)
    dsp_truststore_password (str): DSP truststore password. (in: query)
    description (str): The environment description. (in: query)
    tags (Any): The tags to be created for this environment. (in: query)
    make_current_account_owner (bool): Whether the account creating this environment must be configured as owner of the environment. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "engine_id": engine_id, "os_name": os_name, "is_cluster": is_cluster, "cluster_home": cluster_home, "hostname": hostname, "staging_environment": staging_environment, "connector_port": connector_port, "connector_authentication_key": connector_authentication_key, "is_target": is_target, "ssh_port": ssh_port, "toolkit_path": toolkit_path, "username": username, "password": password, "vault": vault, "vault_username": vault_username, "hashicorp_vault_engine": hashicorp_vault_engine, "hashicorp_vault_secret_path": hashicorp_vault_secret_path, "hashicorp_vault_username_key": hashicorp_vault_username_key, "hashicorp_vault_secret_key": hashicorp_vault_secret_key, "cyberark_vault_query_string": cyberark_vault_query_string, "azure_vault_name": azure_vault_name, "azure_vault_username_key": azure_vault_username_key, "azure_vault_secret_key": azure_vault_secret_key, "use_kerberos_authentication": use_kerberos_authentication, "use_engine_public_key": use_engine_public_key, "nfs_addresses": nfs_addresses, "ase_db_vault_username": ase_db_vault_username, "ase_db_username": ase_db_username, "ase_db_password": ase_db_password, "ase_db_vault": ase_db_vault, "ase_db_hashicorp_vault_engine": ase_db_hashicorp_vault_engine, "ase_db_hashicorp_vault_secret_path": ase_db_hashicorp_vault_secret_path, "ase_db_hashicorp_vault_username_key": ase_db_hashicorp_vault_username_key, "ase_db_hashicorp_vault_secret_key": ase_db_hashicorp_vault_secret_key, "ase_db_cyberark_vault_query_string": ase_db_cyberark_vault_query_string, "ase_db_use_kerberos_authentication": ase_db_use_kerberos_authentication, "ase_db_azure_vault_name": ase_db_azure_vault_name, "ase_db_azure_vault_username_key": ase_db_azure_vault_username_key, "ase_db_azure_vault_secret_key": ase_db_azure_vault_secret_key, "java_home": java_home, "dsp_keystore_path": dsp_keystore_path, "dsp_keystore_password": dsp_keystore_password, "dsp_keystore_alias": dsp_keystore_alias, "dsp_truststore_path": dsp_truststore_path, "dsp_truststore_password": dsp_truststore_password, "description": description, "tags": tags, "make_current_account_owner": make_current_account_owner}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def compatible_repositories_by_snapshot(source_data_id: Optional[str] = None, engine_id: Optional[str] = None, snapshot_id: Optional[str] = None, environment_id: Optional[str] = None) -> dict:
    """
    POST /environments/compatible_repositories_by_snapshot

    Args:
    source_data_id (str): The ID of the source object (dSource or VDB) to get the compatible repos. All other objects referenced by the parameters must live on the same engine as the source. (in: query)
    engine_id (str): The ID of the Engine from where to get the compatible repos. If the source ID unambiguously identifies a source object, this parameter is unnecessary and ignored. (in: query)
    snapshot_id (str): The ID of the snapshot from which to execute the operation. (in: query)
    environment_id (str): The ID or name of the target environment. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/compatible_repositories_by_snapshot"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"source_data_id": source_data_id, "engine_id": engine_id, "snapshot_id": snapshot_id, "environment_id": environment_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def compatible_repositories_by_timestamp(source_data_id: Optional[str] = None, engine_id: Optional[str] = None, timestamp: Optional[str] = None, timeflow_id: Optional[str] = None, environment_id: Optional[str] = None) -> dict:
    """
    POST /environments/compatible_repositories_by_timestamp

    Args:
    source_data_id (str): The ID of the source object (dSource or VDB) to get the compatible repos. All other objects referenced by the parameters must live on the same engine as the source. (in: query)
    engine_id (str): The ID of the Engine from where to get the compatible repos. If the source ID unambiguously identifies a source object, this parameter is unnecessary and ignored. (in: query)
    timestamp (str): The point in time from which to execute the operation. If the timestamp is not set, selects the latest point. (in: query)
    timeflow_id (str): ID of the timeflow from which compatible repos need to be fetched, mutually exclusive with source_data_id. (in: query)
    environment_id (str): The ID or name of the target environment. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/compatible_repositories_by_timestamp"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"source_data_id": source_data_id, "engine_id": engine_id, "timestamp": timestamp, "timeflow_id": timeflow_id, "environment_id": environment_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def compatible_repositories_from_bookmark(bookmark_id: str, environment_id: Optional[str] = None) -> dict:
    """
    POST /environments/compatible_repositories_from_bookmark

    Args:
    bookmark_id (str): The ID of the bookmark from which to execute the operation. The bookmark must contain only one VDB. (in: query)
    environment_id (str): The ID or name of the target environment. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/compatible_repositories_from_bookmark"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"bookmark_id": bookmark_id, "environment_id": environment_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def compatible_repositories_by_location(source_data_id: Optional[str] = None, engine_id: Optional[str] = None, location: Optional[str] = None, timeflow_id: Optional[str] = None, environment_id: Optional[str] = None) -> dict:
    """
    POST /environments/compatible_repositories_by_location

    Args:
    source_data_id (str): The ID of the source object (dSource or VDB) to get the compatible repos. All other objects referenced by the parameters must live on the same engine as the source. (in: query)
    engine_id (str): The ID of the Engine from where to get the compatible repos. If the source ID unambiguously identifies a source object, this parameter is unnecessary and ignored. (in: query)
    location (str): location from where compatible repo to be fetched. (in: query)
    timeflow_id (str): ID of the timeflow from which compatible repos need to be fetched. (in: query)
    environment_id (str): The ID or name of the target environment. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/compatible_repositories_by_location"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"source_data_id": source_data_id, "engine_id": engine_id, "location": location, "timeflow_id": timeflow_id, "environment_id": environment_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_repository(environmentId: str, repositoryId: str) -> dict:
    """
    DELETE /environments/{environmentId}/repository/{repositoryId}

    Args:
    environmentId (str): Path parameter
    repositoryId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/repository/{repositoryId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_repository(environmentId: str, repositoryId: str, allow_provisioning: Optional[bool] = None, is_staging: Optional[bool] = None, version: Optional[str] = None, oracle_base: Optional[str] = None, bits: Optional[int] = None) -> dict:
    """
    PATCH /environments/{environmentId}/repository/{repositoryId}

    Args:
    environmentId (str): Path parameter
    repositoryId (str): Path parameter
    allow_provisioning (bool): Flag indicating whether the repository should be used for provisioning. (in: query)
    is_staging (bool): Flag indicating whether this repository can be used by the Delphix Engine for internal processing. (in: query)
    version (str): Version of the repository. (in: query)
    oracle_base (str): The Oracle base where database binaries are located. (in: query)
    bits (int): 32 or 64 bits. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/repository/{repositoryId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"allow_provisioning": allow_provisioning, "is_staging": is_staging, "version": version, "oracle_base": oracle_base, "bits": bits}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_repository(environmentId: str, database_type: str, bits: Optional[int] = None, installation_home: Optional[str] = None, version: Optional[str] = None, oracle_base: Optional[str] = None, allow_provisioning: Optional[bool] = None, is_staging: Optional[bool] = None, applied_patches: Optional[Any] = None, full_text_installed: Optional[bool] = None, server_name: Optional[str] = None, port: Optional[int] = None, instance_owner: Optional[str] = None, instance_name: Optional[str] = None) -> dict:
    """
    POST /environments/{environmentId}/repository

    Args:
    environmentId (str): Path parameter
    database_type (str): The database type of this repository. (in: query)
    bits (int): 32 or 64 bits. (in: query)
    installation_home (str): The Oracle install or SQL Server instance home. (in: query)
    version (str): Version of the oracle repository or SQL Server instance. (in: query)
    oracle_base (str): The Oracle base where database binaries are located. (in: query)
    allow_provisioning (bool): Flag indicating whether the repository should be used for provisioning. (in: query)
    is_staging (bool): Flag indicating whether this repository can be used by the Delphix Engine for internal processing. (in: query)
    applied_patches (Any): List of Oracle patches that have been applied to this Oracle Home. (in: query)
    full_text_installed (bool): This property determines if the full-text search and semantic search is installed or not (MSSql only). (in: query)
    server_name (str): The Server Name of the SQL Server instance. (in: query)
    port (int): The network port for connecting to the SQL Server instance. (in: query)
    instance_owner (str): Account the SQL Server instance is running as. (in: query)
    instance_name (str): The name of the SQL Server instance. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/repository"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"database_type": database_type, "bits": bits, "installation_home": installation_home, "version": version, "oracle_base": oracle_base, "allow_provisioning": allow_provisioning, "is_staging": is_staging, "applied_patches": applied_patches, "full_text_installed": full_text_installed, "server_name": server_name, "port": port, "instance_owner": instance_owner, "instance_name": instance_name}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_host(environmentId: str, name: Optional[str] = None, hostname: Optional[str] = None, nfs_addresses: Optional[Any] = None, ssh_port: Optional[int] = None, privilege_elevation_profile_reference: Optional[str] = None, dsp_keystore_alias: Optional[str] = None, dsp_keystore_password: Optional[str] = None, dsp_keystore_path: Optional[str] = None, dsp_truststore_password: Optional[str] = None, dsp_truststore_path: Optional[str] = None, java_home: Optional[str] = None, toolkit_path: Optional[str] = None, oracle_jdbc_keystore_password: Optional[str] = None, oracle_tde_keystores_root_path: Optional[str] = None, ssh_verification_strategy: Optional[str] = None, oracle_cluster_node_virtual_ips: Optional[Any] = None) -> dict:
    """
    POST /environments/{environmentId}/hosts

    Args:
    environmentId (str): Path parameter
    name (str): The name to associate with the host. (in: query)
    hostname (str): The hostname or IP address of this host. (in: query)
    nfs_addresses (Any): The list of host/IP addresses to use for NFS export. (in: query)
    ssh_port (int): The port number used to connect to the host via SSH. (in: query)
    privilege_elevation_profile_reference (str): Reference to a profile for escalating user privileges. (in: query)
    dsp_keystore_alias (str): The lowercase alias to use inside the user managed DSP keystore. (in: query)
    dsp_keystore_password (str): The password for the user managed DSP keystore. (in: query)
    dsp_keystore_path (str): The path to the user managed DSP keystore. (in: query)
    dsp_truststore_password (str): The password for the user managed DSP truststore. (in: query)
    dsp_truststore_path (str): The path to the user managed DSP truststore. (in: query)
    java_home (str): The path to the user managed Java Development Kit (JDK). If not specified, then the OpenJDK will be used. (in: query)
    toolkit_path (str): The path for the toolkit that resides on the host. (in: query)
    oracle_jdbc_keystore_password (str): The password for the user managed Oracle JDBC keystore. (in: query)
    oracle_tde_keystores_root_path (str): The path to the root of the Oracle TDE keystores artifact directories. (in: query)
    ssh_verification_strategy (str): Mechanism to use for ssh host verification. (in: query)
    oracle_cluster_node_virtual_ips (Any): The Virtual IP addresses associated with the OracleClusterNode. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/hosts"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "hostname": hostname, "nfs_addresses": nfs_addresses, "ssh_port": ssh_port, "privilege_elevation_profile_reference": privilege_elevation_profile_reference, "dsp_keystore_alias": dsp_keystore_alias, "dsp_keystore_password": dsp_keystore_password, "dsp_keystore_path": dsp_keystore_path, "dsp_truststore_password": dsp_truststore_password, "dsp_truststore_path": dsp_truststore_path, "java_home": java_home, "toolkit_path": toolkit_path, "oracle_jdbc_keystore_password": oracle_jdbc_keystore_password, "oracle_tde_keystores_root_path": oracle_tde_keystores_root_path, "ssh_verification_strategy": ssh_verification_strategy, "oracle_cluster_node_virtual_ips": oracle_cluster_node_virtual_ips}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_host(environmentId: str, hostId: str) -> dict:
    """
    DELETE /environments/{environmentId}/hosts/{hostId}

    Args:
    environmentId (str): Path parameter
    hostId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/hosts/{hostId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_host(environmentId: str, hostId: str, hostname: Optional[str] = None, oracle_cluster_node_name: Optional[str] = None, oracle_cluster_node_enabled: Optional[bool] = None, oracle_cluster_node_virtual_ips: Optional[Any] = None, nfs_addresses: Optional[Any] = None, ssh_port: Optional[int] = None, toolkit_path: Optional[str] = None, java_home: Optional[str] = None, dsp_keystore_path: Optional[str] = None, dsp_keystore_password: Optional[str] = None, dsp_keystore_alias: Optional[str] = None, dsp_truststore_path: Optional[str] = None, dsp_truststore_password: Optional[str] = None, connector_port: Optional[int] = None, oracle_jdbc_keystore_password: Optional[str] = None, oracle_tde_keystores_root_path: Optional[str] = None, ssh_verification_strategy: Optional[str] = None, connector_authentication_key: Optional[str] = None, oracle_tde_okv_home_path: Optional[str] = None, oracle_tde_external_key_manager_credential: Optional[str] = None) -> dict:
    """
    PATCH /environments/{environmentId}/hosts/{hostId}

    Args:
    environmentId (str): Path parameter
    hostId (str): Path parameter
    hostname (str): host address of the machine. (in: query)
    oracle_cluster_node_name (str): The name of the associated OracleClusterNode. (in: query)
    oracle_cluster_node_enabled (bool): Whether the associated OracleClusterNode is enabled. (in: query)
    oracle_cluster_node_virtual_ips (Any): The Virtual IP addresses associated with the OracleClusterNode. (in: query)
    nfs_addresses (Any): array of ip addresses or hostnames (in: query)
    ssh_port (int): ssh port of the host. (in: query)
    toolkit_path (str): The path for the toolkit that resides on the host. (in: query)
    java_home (str): The path to the user managed Java Development Kit (JDK). If not specified, then the OpenJDK will be used. (in: query)
    dsp_keystore_path (str): DSP keystore path. (in: query)
    dsp_keystore_password (str): DSP keystore password. (in: query)
    dsp_keystore_alias (str): DSP keystore alias. (in: query)
    dsp_truststore_path (str): DSP truststore path. (in: query)
    dsp_truststore_password (str): DSP truststore password. (in: query)
    connector_port (int): Specify port on which Delphix connector will run. (in: query)
    oracle_jdbc_keystore_password (str): The password for the user managed Oracle JDBC keystore. (in: query)
    oracle_tde_keystores_root_path (str): The path to the root of the Oracle TDE keystores artifact directories. (in: query)
    ssh_verification_strategy (str): Mechanism to use for ssh host verification. (in: query)
    connector_authentication_key (str): Unique per Delphix key used to authenticate with the remote Delphix Connector. (in: query)
    oracle_tde_okv_home_path (str): The path to the Oracle Key Vault library installation on the database node. (in: query)
    oracle_tde_external_key_manager_credential (str): The credential of the tde keystore external keys management system like Oracle Key Vault or Hardware Security Module. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/hosts/{hostId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"hostname": hostname, "oracle_cluster_node_name": oracle_cluster_node_name, "oracle_cluster_node_enabled": oracle_cluster_node_enabled, "oracle_cluster_node_virtual_ips": oracle_cluster_node_virtual_ips, "nfs_addresses": nfs_addresses, "ssh_port": ssh_port, "toolkit_path": toolkit_path, "java_home": java_home, "dsp_keystore_path": dsp_keystore_path, "dsp_keystore_password": dsp_keystore_password, "dsp_keystore_alias": dsp_keystore_alias, "dsp_truststore_path": dsp_truststore_path, "dsp_truststore_password": dsp_truststore_password, "connector_port": connector_port, "oracle_jdbc_keystore_password": oracle_jdbc_keystore_password, "oracle_tde_keystores_root_path": oracle_tde_keystores_root_path, "ssh_verification_strategy": ssh_verification_strategy, "connector_authentication_key": connector_authentication_key, "oracle_tde_okv_home_path": oracle_tde_okv_home_path, "oracle_tde_external_key_manager_credential": oracle_tde_external_key_manager_credential}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_tags_environment(environmentId: str) -> dict:
    """
    GET /environments/{environmentId}/tags

    Args:
    environmentId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_environment_tags(environmentId: str, tags: Any) -> dict:
    """
    POST /environments/{environmentId}/tags

    Args:
    environmentId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_environment_tags(environmentId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /environments/{environmentId}/tags/delete

    Args:
    environmentId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_environment_by_id(environmentId: str) -> dict:
    """
    GET /environments/{environmentId}

    Args:
    environmentId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_environment(environmentId: str) -> dict:
    """
    DELETE /environments/{environmentId}

    Args:
    environmentId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_environment(environmentId: str, name: Optional[str] = None, staging_environment: Optional[str] = None, cluster_address: Optional[str] = None, cluster_home: Optional[str] = None, ase_db_username: Optional[str] = None, ase_db_password: Optional[str] = None, ase_db_vault: Optional[str] = None, ase_db_vault_username: Optional[str] = None, ase_db_hashicorp_vault_engine: Optional[str] = None, ase_db_hashicorp_vault_secret_path: Optional[str] = None, ase_db_hashicorp_vault_username_key: Optional[str] = None, ase_db_hashicorp_vault_secret_key: Optional[str] = None, ase_db_cyberark_vault_query_string: Optional[str] = None, ase_db_azure_vault_name: Optional[str] = None, ase_db_azure_vault_username_key: Optional[str] = None, ase_db_azure_vault_secret_key: Optional[str] = None, ase_db_use_kerberos_authentication: Optional[bool] = None, encryption_enabled: Optional[bool] = None, description: Optional[str] = None) -> dict:
    """
    PATCH /environments/{environmentId}

    Args:
    environmentId (str): Path parameter
    name (str): The name of the environment. (in: query)
    staging_environment (str): Id of the connector environment which is used to connect to this source environment. (in: query)
    cluster_address (str): Address of the cluster. This property can be modified for Windows cluster only. (in: query)
    cluster_home (str): Absolute path to cluster home directory. This parameter is for UNIX cluster environments. (in: query)
    ase_db_username (str): username of the SAP ASE database. (in: query)
    ase_db_password (str): password of the SAP ASE database. (in: query)
    ase_db_vault (str): The name or reference of the vault from which to read the ASE database credentials. (in: query)
    ase_db_vault_username (str): Delphix display name for the vault user (in: query)
    ase_db_hashicorp_vault_engine (str): Vault engine name where the credential is stored. (in: query)
    ase_db_hashicorp_vault_secret_path (str): Path in the vault engine where the credential is stored. (in: query)
    ase_db_hashicorp_vault_username_key (str): Key for the username in the key-value store. (in: query)
    ase_db_hashicorp_vault_secret_key (str): Key for the password in the key-value store. (in: query)
    ase_db_cyberark_vault_query_string (str): Query to find a credential in the CyberArk vault. (in: query)
    ase_db_azure_vault_name (str): Azure key vault name. (in: query)
    ase_db_azure_vault_username_key (str): Azure vault key for the username in the key-value store. (in: query)
    ase_db_azure_vault_secret_key (str): Azure vault key for the password in the key-value store. (in: query)
    ase_db_use_kerberos_authentication (bool): Whether to use kerberos authentication for ASE DB discovery. (in: query)
    encryption_enabled (bool): Flag indicating whether the data transfer is encrypted or not. (in: query)
    description (str): The environment description. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "staging_environment": staging_environment, "cluster_address": cluster_address, "cluster_home": cluster_home, "ase_db_username": ase_db_username, "ase_db_password": ase_db_password, "ase_db_vault": ase_db_vault, "ase_db_vault_username": ase_db_vault_username, "ase_db_hashicorp_vault_engine": ase_db_hashicorp_vault_engine, "ase_db_hashicorp_vault_secret_path": ase_db_hashicorp_vault_secret_path, "ase_db_hashicorp_vault_username_key": ase_db_hashicorp_vault_username_key, "ase_db_hashicorp_vault_secret_key": ase_db_hashicorp_vault_secret_key, "ase_db_cyberark_vault_query_string": ase_db_cyberark_vault_query_string, "ase_db_azure_vault_name": ase_db_azure_vault_name, "ase_db_azure_vault_username_key": ase_db_azure_vault_username_key, "ase_db_azure_vault_secret_key": ase_db_azure_vault_secret_key, "ase_db_use_kerberos_authentication": ase_db_use_kerberos_authentication, "encryption_enabled": encryption_enabled, "description": description}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_environments(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /environments/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def enable_environment(environmentId: str) -> dict:
    """
    POST /environments/{environmentId}/enable

    Args:
    environmentId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/enable"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def disable_environment(environmentId: str) -> dict:
    """
    POST /environments/{environmentId}/disable

    Args:
    environmentId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/disable"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def refresh_environment(environmentId: str) -> dict:
    """
    POST /environments/{environmentId}/refresh

    Args:
    environmentId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/refresh"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def list_environment_users(environmentId: str) -> dict:
    """
    GET /environments/{environmentId}/users

    Args:
    environmentId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/users"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_environment_user(environmentId: str, username: Optional[str] = None, password: Optional[str] = None, vault: Optional[str] = None, vault_username: Optional[str] = None, hashicorp_vault_engine: Optional[str] = None, hashicorp_vault_secret_path: Optional[str] = None, hashicorp_vault_username_key: Optional[str] = None, hashicorp_vault_secret_key: Optional[str] = None, cyberark_vault_query_string: Optional[str] = None, azure_vault_name: Optional[str] = None, azure_vault_username_key: Optional[str] = None, azure_vault_secret_key: Optional[str] = None, use_kerberos_authentication: Optional[bool] = None, use_engine_public_key: Optional[bool] = None) -> dict:
    """
    POST /environments/{environmentId}/users

    Args:
    environmentId (str): Path parameter
    username (str): Username of the OS. (in: query)
    password (str): Password of the OS. (in: query)
    vault (str): The name or reference of the vault from which to read the host credentials. (in: query)
    vault_username (str): Delphix display name for the vault user (in: query)
    hashicorp_vault_engine (str): Vault engine name where the credential is stored. (in: query)
    hashicorp_vault_secret_path (str): Path in the vault engine where the credential is stored. (in: query)
    hashicorp_vault_username_key (str): Key for the username in the key-value store. (in: query)
    hashicorp_vault_secret_key (str): Key for the password in the key-value store. (in: query)
    cyberark_vault_query_string (str): Query to find a credential in the CyberArk vault. (in: query)
    azure_vault_name (str): Azure key vault name. (in: query)
    azure_vault_username_key (str): Azure vault key for the username in the key-value store. (in: query)
    azure_vault_secret_key (str): Azure vault key for the password in the key-value store. (in: query)
    use_kerberos_authentication (bool): Whether to use kerberos authentication. (in: query)
    use_engine_public_key (bool): Whether to use public key authentication. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/users"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"username": username, "password": password, "vault": vault, "vault_username": vault_username, "hashicorp_vault_engine": hashicorp_vault_engine, "hashicorp_vault_secret_path": hashicorp_vault_secret_path, "hashicorp_vault_username_key": hashicorp_vault_username_key, "hashicorp_vault_secret_key": hashicorp_vault_secret_key, "cyberark_vault_query_string": cyberark_vault_query_string, "azure_vault_name": azure_vault_name, "azure_vault_username_key": azure_vault_username_key, "azure_vault_secret_key": azure_vault_secret_key, "use_kerberos_authentication": use_kerberos_authentication, "use_engine_public_key": use_engine_public_key}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_environment_user(environmentId: str, userRef: str, username: Optional[str] = None, password: Optional[str] = None, vault: Optional[str] = None, vault_username: Optional[str] = None, hashicorp_vault_engine: Optional[str] = None, hashicorp_vault_secret_path: Optional[str] = None, hashicorp_vault_username_key: Optional[str] = None, hashicorp_vault_secret_key: Optional[str] = None, cyberark_vault_query_string: Optional[str] = None, azure_vault_name: Optional[str] = None, azure_vault_username_key: Optional[str] = None, azure_vault_secret_key: Optional[str] = None, use_kerberos_authentication: Optional[bool] = None, use_engine_public_key: Optional[bool] = None) -> dict:
    """
    PUT /environments/{environmentId}/users/{userRef}

    Args:
    environmentId (str): Path parameter
    userRef (str): Path parameter
    username (str): Username of the OS. (in: query)
    password (str): Password of the OS. (in: query)
    vault (str): The name or reference of the vault from which to read the host credentials. (in: query)
    vault_username (str): Delphix display name for the vault user (in: query)
    hashicorp_vault_engine (str): Vault engine name where the credential is stored. (in: query)
    hashicorp_vault_secret_path (str): Path in the vault engine where the credential is stored. (in: query)
    hashicorp_vault_username_key (str): Key for the username in the key-value store. (in: query)
    hashicorp_vault_secret_key (str): Key for the password in the key-value store. (in: query)
    cyberark_vault_query_string (str): Query to find a credential in the CyberArk vault. (in: query)
    azure_vault_name (str): Azure key vault name. (in: query)
    azure_vault_username_key (str): Azure vault key for the username in the key-value store. (in: query)
    azure_vault_secret_key (str): Azure vault key for the password in the key-value store. (in: query)
    use_kerberos_authentication (bool): Whether to use kerberos authentication. (in: query)
    use_engine_public_key (bool): Whether to use public key authentication. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/users/{userRef}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"username": username, "password": password, "vault": vault, "vault_username": vault_username, "hashicorp_vault_engine": hashicorp_vault_engine, "hashicorp_vault_secret_path": hashicorp_vault_secret_path, "hashicorp_vault_username_key": hashicorp_vault_username_key, "hashicorp_vault_secret_key": hashicorp_vault_secret_key, "cyberark_vault_query_string": cyberark_vault_query_string, "azure_vault_name": azure_vault_name, "azure_vault_username_key": azure_vault_username_key, "azure_vault_secret_key": azure_vault_secret_key, "use_kerberos_authentication": use_kerberos_authentication, "use_engine_public_key": use_engine_public_key}

    try:
        response = requests.put(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_environment_user(environmentId: str, userRef: str) -> dict:
    """
    DELETE /environments/{environmentId}/users/{userRef}

    Args:
    environmentId (str): Path parameter
    userRef (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/users/{userRef}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def primary_environment_user(environmentId: str, userRef: str) -> dict:
    """
    POST /environments/{environmentId}/users/{userRef}/primary

    Args:
    environmentId (str): Path parameter
    userRef (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/users/{userRef}/primary"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_oracle_listener(environmentId: str, type: str, name: Optional[str] = None, protocol_addresses: Optional[Any] = None, host_id: Optional[str] = None) -> dict:
    """
    POST /environments/{environmentId}/listeners

    Args:
    environmentId (str): Path parameter
    type (str): type (in: query)
    name (str): The name of the Oracle listener. (in: query)
    protocol_addresses (Any): The protocol addresses of the Oracle listener. (in: query)
    host_id (str): The id of the host on which the Oracle listener runs. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/listeners"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"type": type, "name": name, "protocol_addresses": protocol_addresses, "host_id": host_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_oracle_listener(environmentId: str, listenerId: str) -> dict:
    """
    DELETE /environments/{environmentId}/listeners/{listenerId}

    Args:
    environmentId (str): Path parameter
    listenerId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/listeners/{listenerId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_oracle_listener(environmentId: str, listenerId: str, name: Optional[str] = None, protocol_addresses: Optional[Any] = None) -> dict:
    """
    PATCH /environments/{environmentId}/listeners/{listenerId}

    Args:
    environmentId (str): Path parameter
    listenerId (str): Path parameter
    name (str): The name of the Oracle listener. (in: query)
    protocol_addresses (Any): The protocol addresses of the Oracle listener. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"environments/{environmentId}/listeners/{listenerId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "protocol_addresses": protocol_addresses}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def validate_java_path(engineId: str, java_home: str, port: int, host_name: str, username: Optional[str] = None, password: Optional[str] = None, use_engine_public_key: Optional[bool] = None, vault_id: Optional[str] = None, hashicorp_vault_engine: Optional[str] = None, hashicorp_vault_secret_path: Optional[str] = None, hashicorp_vault_username_key: Optional[str] = None, hashicorp_vault_secret_key: Optional[str] = None, azure_vault_name: Optional[str] = None, azure_vault_username_key: Optional[str] = None, azure_vault_secret_key: Optional[str] = None, cyberark_vault_query_string: Optional[str] = None, use_kerberos_authentication: Optional[bool] = None) -> dict:
    """
    POST /management/engines/{engineId}/validate/java-path

    Args:
    engineId (str): Path parameter
    java_home (str): Path pointing to java home on the remote machine. (in: query)
    port (int): SSH port of the remote host machine that will be used to establish SSH connection. (in: query)
    username (str): The username of the user that will be used to connect to the remote host machine. (in: query)
    password (str): The password of the user that will be used to connect to the remote host machine. (in: query)
    host_name (str): Hostname of the remote host machine that will be used to establish connection. (in: query)
    use_engine_public_key (bool): Whether to use public key authentication. (in: query)
    vault_id (str): The DCT id or name of the vault from which to read the host credentials. (in: query)
    hashicorp_vault_engine (str): Vault engine name where the credential is stored. (in: query)
    hashicorp_vault_secret_path (str): Path in the vault engine where the credential is stored. (in: query)
    hashicorp_vault_username_key (str): Key for the username in the key-value store. (in: query)
    hashicorp_vault_secret_key (str): Key for the password in the key-value store. (in: query)
    azure_vault_name (str): Azure key vault name (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    azure_vault_username_key (str): Azure vault key for the username in the key-value store (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    azure_vault_secret_key (str): Azure vault key for the password in the key-value store (ORACLE, ASE and MSSQL_DOMAIN_USER only). (in: query)
    cyberark_vault_query_string (str): Query to find a credential in the CyberArk vault. (in: query)
    use_kerberos_authentication (bool): Whether to use kerberos authentication. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/engines/{engineId}/validate/java-path"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"java_home": java_home, "port": port, "username": username, "password": password, "host_name": host_name, "use_engine_public_key": use_engine_public_key, "vault_id": vault_id, "hashicorp_vault_engine": hashicorp_vault_engine, "hashicorp_vault_secret_path": hashicorp_vault_secret_path, "hashicorp_vault_username_key": hashicorp_vault_username_key, "hashicorp_vault_secret_key": hashicorp_vault_secret_key, "azure_vault_name": azure_vault_name, "azure_vault_username_key": azure_vault_username_key, "azure_vault_secret_key": azure_vault_secret_key, "cyberark_vault_query_string": cyberark_vault_query_string, "use_kerberos_authentication": use_kerberos_authentication}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_historical_storage_summary_aggregate(start_date: Optional[str] = None, end_date: Optional[str] = None, include_projection: Optional[bool] = None, engine_ids: Optional[Any] = None, dsource_ids: Optional[Any] = None, vdb_ids: Optional[Any] = None, cdb_ids: Optional[Any] = None, vcdb_ids: Optional[Any] = None) -> dict:
    """
    GET /historical-storage-summary-aggregate

    Args:
    start_date (str): Report start date/time. Defaults to first API request. (in: query)
    end_date (str): Report end date/time. Defaults to current time. (in: query)
    include_projection (bool): Whether to compute a projection of future storage usage. (in: query)
    engine_ids (Any): The list of engine ids to aggregate data for. By default aggregating data for all engines. (in: query)
    dsource_ids (Any): The list of dSource ids to aggregate data for. By default aggregating data for all dSources. (in: query)
    vdb_ids (Any): The list of VDB ids to aggregate data for. By default aggregating data for all VDBs. (in: query)
    cdb_ids (Any): The list of CDB ids to aggregate data for. By default aggregating data for all CDBs. (in: query)
    vcdb_ids (Any): The list of VCDB ids to aggregate data for. By default aggregating data for all VCDBs. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"historical-storage-summary-aggregate"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"start_date": start_date, "end_date": end_date, "include_projection": include_projection, "engine_ids": engine_ids, "dsource_ids": dsource_ids, "vdb_ids": vdb_ids, "cdb_ids": cdb_ids, "vcdb_ids": vcdb_ids}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_historical_storage_summary_by_engine(start_date: Optional[str] = None, end_date: Optional[str] = None, include_projection: Optional[bool] = None, engine_ids: Optional[Any] = None) -> dict:
    """
    GET /historical-storage-summary-by-engine

    Args:
    start_date (str): Report start date/time. Defaults to first API request. (in: query)
    end_date (str): Report end date/time. Defaults to current time. (in: query)
    include_projection (bool): Whether to compute a projection of future storage usage. (in: query)
    engine_ids (Any): The list of engine ids to include in the response. By default returning data for all engines. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"historical-storage-summary-by-engine"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"start_date": start_date, "end_date": end_date, "include_projection": include_projection, "engine_ids": engine_ids}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_storage_savings_summary_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /reporting/storage-savings-report/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/storage-savings-report/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_vdb_inventory_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /reporting/vdb-inventory-report

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/vdb-inventory-report"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_vdb_inventory_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /reporting/vdb-inventory-report/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/vdb-inventory-report/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_dsource_usage_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /reporting/dsource-usage-report

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/dsource-usage-report"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_dsource_usage_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /reporting/dsource-usage-report/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/dsource-usage-report/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_dsource_consumption_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /reporting/dsource-consumption-report

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/dsource-consumption-report"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_dsource_consumption_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /reporting/dsource-consumption-report/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/dsource-consumption-report/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_storage_capacity_data(engine_id: Optional[str] = None, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /reporting/storage-capacity-data-report

    Args:
    engine_id (str): ID of a registered engine. (in: query)
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/storage-capacity-data-report"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"engine_id": engine_id, "limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_storage_capacity_data(engine_id: Optional[str] = None, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /reporting/storage-capacity-data-report/search

    Args:
    engine_id (str): ID of a registered engine. (in: query)
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/storage-capacity-data-report/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"engine_id": engine_id, "limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_dataset_performance_analytics_summary(engine_id: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /reporting/dataset-performance-analytics-summary/search

    Args:
    engine_id (str): ID of a registered engine. (in: query)
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/dataset-performance-analytics-summary/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"engine_id": engine_id, "limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_dataset_performance_analytics(dataset_ids: Any, start: str, end: str, interval: int) -> dict:
    """
    POST /reporting/dataset-performance-analytics

    Args:
    dataset_ids (Any): List of dataset ids for which dataset performance analytics should be fetched. (in: query)
    start (str): Start time in UTC from which to fetch analytics data. (in: query)
    end (str): End time in UTC up to which analytics data will be fetched. (in: query)
    interval (int): Desired time interval in timestamp format. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/dataset-performance-analytics"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"dataset_ids": dataset_ids, "start": start, "end": end, "interval": interval}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_database_templates(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /database-templates

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"database-templates"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_database_template(name: str, source_type: str, description: Optional[str] = None, parameters: Optional[Any] = None, make_current_account_owner: Optional[bool] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /database-templates

    Args:
    name (str): The DatabaseTemplate name. (in: query)
    description (str): User provided description for this template. (in: query)
    source_type (str): The type of the source associated with the template. (in: query)
    parameters (Any): A name/value map of string configuration parameters. (in: query)
    make_current_account_owner (bool): Whether the account creating this database template must be configured as owner of the database template. (in: query)
    tags (Any): tags (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"database-templates"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description, "source_type": source_type, "parameters": parameters, "make_current_account_owner": make_current_account_owner, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_database_template_by_id(databaseTemplateId: str) -> dict:
    """
    GET /database-templates/{databaseTemplateId}

    Args:
    databaseTemplateId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"database-templates/{databaseTemplateId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_database_template(databaseTemplateId: str) -> dict:
    """
    DELETE /database-templates/{databaseTemplateId}

    Args:
    databaseTemplateId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"database-templates/{databaseTemplateId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_database_template(databaseTemplateId: str, name: Optional[str] = None, description: Optional[str] = None, source_type: Optional[str] = None, parameters: Optional[Any] = None) -> dict:
    """
    PATCH /database-templates/{databaseTemplateId}

    Args:
    databaseTemplateId (str): Path parameter
    name (str): The DatabaseTemplate name. (in: query)
    description (str): User provided description for this template. (in: query)
    source_type (str): The type of the source associated with the template. (in: query)
    parameters (Any): A name/value map of string configuration parameters. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"database-templates/{databaseTemplateId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description, "source_type": source_type, "parameters": parameters}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_database_template_tags(databaseTemplateId: str) -> dict:
    """
    GET /database-templates/{databaseTemplateId}/tags

    Args:
    databaseTemplateId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"database-templates/{databaseTemplateId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_database_template_tags(databaseTemplateId: str, tags: Any) -> dict:
    """
    POST /database-templates/{databaseTemplateId}/tags

    Args:
    databaseTemplateId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"database-templates/{databaseTemplateId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_database_template_tag(databaseTemplateId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /database-templates/{databaseTemplateId}/tags/delete

    Args:
    databaseTemplateId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"database-templates/{databaseTemplateId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_database_templates(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /database-templates/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"database-templates/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def import_database_templates(engine_id: Optional[str] = None) -> dict:
    """
    POST /database-templates/import

    Args:
    engine_id (str): engine_id (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"database-templates/import"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"engine_id": engine_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def undo_import_database_templates(engine_id: Optional[str] = None) -> dict:
    """
    POST /database-templates/undo-import

    Args:
    engine_id (str): engine_id (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"database-templates/undo-import"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"engine_id": engine_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_cdbs(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /cdbs

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"cdbs"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_cdbs(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /cdbs/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"cdbs/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_cdb_by_id(cdbId: str) -> dict:
    """
    GET /cdbs/{cdbId}

    Args:
    cdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"cdbs/{cdbId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_cdb(cdbId: str, oracle_services: Optional[Any] = None, logsync_enabled: Optional[bool] = None, logsync_mode: Optional[str] = None, logsync_interval: Optional[int] = None, tde_keystore_password: Optional[str] = None, tde_keystore_config_type: Optional[str] = None) -> dict:
    """
    PATCH /cdbs/{cdbId}

    Args:
    cdbId (str): Path parameter
    oracle_services (Any): List of jdbc connection strings which are used to connect with the database. (in: query)
    logsync_enabled (bool): True if LogSync is enabled for this CDB. (in: query)
    logsync_mode (str): LogSync operation mode for this dSource. (in: query)
    logsync_interval (int): Interval between LogSync requests, in seconds. (in: query)
    tde_keystore_password (str): For a CDB using software keystore, this is the password of the software keystore used by this database. For a CDB using OKV, this is the password for the endpoint provided during the installation of the Oracle Key Vault client library (i.e., okvclient.jar) on the host where this database runs. For a CDB using HSM, this is the credential of the external key manager which is managing master encryption keys of this database. (in: query)
    tde_keystore_config_type (str): Oracle TDE keystore configuration type. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"cdbs/{cdbId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"oracle_services": oracle_services, "logsync_enabled": logsync_enabled, "logsync_mode": logsync_mode, "logsync_interval": logsync_interval, "tde_keystore_password": tde_keystore_password, "tde_keystore_config_type": tde_keystore_config_type}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_cdb_by_id(cdbId: str, oracle_services: Optional[Any] = None, logsync_enabled: Optional[bool] = None, logsync_mode: Optional[str] = None, logsync_interval: Optional[int] = None, tde_keystore_password: Optional[str] = None, tde_keystore_config_type: Optional[str] = None) -> dict:
    """
    PATCH /cdbs/{cdbId}/update

    Args:
    cdbId (str): Path parameter
    oracle_services (Any): List of jdbc connection strings which are used to connect with the database. (in: query)
    logsync_enabled (bool): True if LogSync is enabled for this CDB. (in: query)
    logsync_mode (str): LogSync operation mode for this dSource. (in: query)
    logsync_interval (int): Interval between LogSync requests, in seconds. (in: query)
    tde_keystore_password (str): For a CDB using software keystore, this is the password of the software keystore used by this database. For a CDB using OKV, this is the password for the endpoint provided during the installation of the Oracle Key Vault client library (i.e., okvclient.jar) on the host where this database runs. For a CDB using HSM, this is the credential of the external key manager which is managing master encryption keys of this database. (in: query)
    tde_keystore_config_type (str): Oracle TDE keystore configuration type. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"cdbs/{cdbId}/update"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"oracle_services": oracle_services, "logsync_enabled": logsync_enabled, "logsync_mode": logsync_mode, "logsync_interval": logsync_interval, "tde_keystore_password": tde_keystore_password, "tde_keystore_config_type": tde_keystore_config_type}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_tags_cdb(cdbId: str) -> dict:
    """
    GET /cdbs/{cdbId}/tags

    Args:
    cdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"cdbs/{cdbId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_cdb_tags(cdbId: str, tags: Any) -> dict:
    """
    POST /cdbs/{cdbId}/tags

    Args:
    cdbId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"cdbs/{cdbId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_cdb_tags(cdbId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /cdbs/{cdbId}/tags/delete

    Args:
    cdbId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"cdbs/{cdbId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def enable_cdb(cdbId: str, attempt_start: Optional[bool] = None) -> dict:
    """
    POST /cdbs/{cdbId}/enable

    Args:
    cdbId (str): Path parameter
    attempt_start (bool): Whether to attempt a startup of the CDB after the enable. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"cdbs/{cdbId}/enable"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"attempt_start": attempt_start}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def disable_cdb(cdbId: str, attempt_cleanup: Optional[bool] = None) -> dict:
    """
    POST /cdbs/{cdbId}/disable

    Args:
    cdbId (str): Path parameter
    attempt_cleanup (bool): Whether to attempt a cleanup of the CDB before the disable. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"cdbs/{cdbId}/disable"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"attempt_cleanup": attempt_cleanup}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_cdb_deletion_dependencies(cdbId: str) -> dict:
    """
    GET /cdbs/{cdbId}/deletion-dependencies

    Args:
    cdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"cdbs/{cdbId}/deletion-dependencies"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_cdb(cdbId: str, force: Optional[bool] = None, delete_all_dependent_datasets: Optional[bool] = None) -> dict:
    """
    POST /cdbs/{cdbId}/delete

    Args:
    cdbId (str): Path parameter
    force (bool): Whether to continue the operation upon failures. (in: query)
    delete_all_dependent_datasets (bool): Whether to delete all dependent datasets of the CDB. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"cdbs/{cdbId}/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"force": force, "delete_all_dependent_datasets": delete_all_dependent_datasets}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def upgrade_cdb(cdbId: str, repository_id: str, environment_user_id: str) -> dict:
    """
    POST /cdbs/{cdbId}/upgrade

    Args:
    cdbId (str): Path parameter
    repository_id (str): The id of the CDB/vCDB repository to upgrade to. (in: query)
    environment_user_id (str): Reference of the environment user to use for CDB/vCDB upgrade. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"cdbs/{cdbId}/upgrade"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"repository_id": repository_id, "environment_user_id": environment_user_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def detach_cdb(cdbId: str) -> dict:
    """
    POST /cdbs/{cdbId}/detachSource

    Args:
    cdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"cdbs/{cdbId}/detachSource"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def attach_cdb(cdbId: str, dsource_id: str) -> dict:
    """
    POST /cdbs/{cdbId}/attachSource

    Args:
    cdbId (str): Path parameter
    dsource_id (str): Id of the dsource to attach. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"cdbs/{cdbId}/attachSource"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"dsource_id": dsource_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def verify_cdb_jdbc_connection_string(cdbId: str, database_username: str, database_password: str, jdbc_connection_string: str) -> dict:
    """
    POST /cdbs/{cdbId}/jdbc-check

    Args:
    cdbId (str): Path parameter
    database_username (str): oracle database username. (in: query)
    database_password (str): oracle database password. (in: query)
    jdbc_connection_string (str): Oracle jdbc connection string to validate. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"cdbs/{cdbId}/jdbc-check"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"database_username": database_username, "database_password": database_password, "jdbc_connection_string": jdbc_connection_string}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_vcdbs(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /vcdbs

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vcdbs"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_vcdbs(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /vcdbs/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vcdbs/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_vcdb_by_id(vcdbId: str) -> dict:
    """
    GET /vcdbs/{vcdbId}

    Args:
    vcdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vcdbs/{vcdbId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_vcdb(vcdbId: str, oracle_services: Optional[Any] = None, instances: Optional[Any] = None, node_listeners: Optional[Any] = None, invoke_datapatch: Optional[bool] = None, tde_keystore_password: Optional[str] = None, tde_keystore_config_type: Optional[str] = None, tde_key_identifier: Optional[str] = None) -> dict:
    """
    PATCH /vcdbs/{vcdbId}

    Args:
    vcdbId (str): Path parameter
    oracle_services (Any): List of jdbc connection strings which are used to connect with the database. (in: query)
    instances (Any): The instances of this RAC database. (in: query)
    node_listeners (Any): The list of node listener ids for this VCDB. (in: query)
    invoke_datapatch (bool): Indicates whether datapatch should be invoked. (in: query)
    tde_keystore_password (str): For a vCDB using software keystore, this is the password of the software keystore used by this database. For a vCDB using OKV, this is the password for the endpoint provided during the installation of the Oracle Key Vault client library (i.e., okvclient.jar) on the host where this database runs. For a vCDB using HSM, this is the credential of the external key manager which is managing master encryption keys of this database. (in: query)
    tde_keystore_config_type (str): Oracle TDE keystore configuration type. (in: query)
    tde_key_identifier (str): The master encryption key id of this database. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vcdbs/{vcdbId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"oracle_services": oracle_services, "instances": instances, "node_listeners": node_listeners, "invoke_datapatch": invoke_datapatch, "tde_keystore_password": tde_keystore_password, "tde_keystore_config_type": tde_keystore_config_type, "tde_key_identifier": tde_key_identifier}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_tags_vcdb(vcdbId: str) -> dict:
    """
    GET /vcdbs/{vcdbId}/tags

    Args:
    vcdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vcdbs/{vcdbId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_vcdb_tags(vcdbId: str, tags: Any) -> dict:
    """
    POST /vcdbs/{vcdbId}/tags

    Args:
    vcdbId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vcdbs/{vcdbId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_vcdb_tags(vcdbId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /vcdbs/{vcdbId}/tags/delete

    Args:
    vcdbId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vcdbs/{vcdbId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def enable_vcdb(vcdbId: str, attempt_start: Optional[bool] = None) -> dict:
    """
    POST /vcdbs/{vcdbId}/enable

    Args:
    vcdbId (str): Path parameter
    attempt_start (bool): Whether to attempt a startup of the vCDB after the enable. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vcdbs/{vcdbId}/enable"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"attempt_start": attempt_start}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def disable_vcdb(vcdbId: str, attempt_cleanup: Optional[bool] = None) -> dict:
    """
    POST /vcdbs/{vcdbId}/disable

    Args:
    vcdbId (str): Path parameter
    attempt_cleanup (bool): Whether to attempt a cleanup of the vCDB before the disable. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vcdbs/{vcdbId}/disable"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"attempt_cleanup": attempt_cleanup}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_vcdb_deletion_dependencies(vcdbId: str) -> dict:
    """
    GET /vcdbs/{vcdbId}/deletion-dependencies

    Args:
    vcdbId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vcdbs/{vcdbId}/deletion-dependencies"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_vcdb(vcdbId: str, force: Optional[bool] = None, delete_all_dependent_datasets: Optional[bool] = None) -> dict:
    """
    POST /vcdbs/{vcdbId}/delete

    Args:
    vcdbId (str): Path parameter
    force (bool): Whether to continue the operation upon failures. (in: query)
    delete_all_dependent_datasets (bool): Whether to delete all dependent datasets of the CDB. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vcdbs/{vcdbId}/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"force": force, "delete_all_dependent_datasets": delete_all_dependent_datasets}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_vcdb_by_id(vcdbId: str, oracle_services: Optional[Any] = None, instances: Optional[Any] = None, node_listeners: Optional[Any] = None, invoke_datapatch: Optional[bool] = None, tde_keystore_password: Optional[str] = None, tde_keystore_config_type: Optional[str] = None, tde_key_identifier: Optional[str] = None) -> dict:
    """
    PATCH /vcdbs/{vcdbId}/update

    Args:
    vcdbId (str): Path parameter
    oracle_services (Any): List of jdbc connection strings which are used to connect with the database. (in: query)
    instances (Any): The instances of this RAC database. (in: query)
    node_listeners (Any): The list of node listener ids for this VCDB. (in: query)
    invoke_datapatch (bool): Indicates whether datapatch should be invoked. (in: query)
    tde_keystore_password (str): For a vCDB using software keystore, this is the password of the software keystore used by this database. For a vCDB using OKV, this is the password for the endpoint provided during the installation of the Oracle Key Vault client library (i.e., okvclient.jar) on the host where this database runs. For a vCDB using HSM, this is the credential of the external key manager which is managing master encryption keys of this database. (in: query)
    tde_keystore_config_type (str): Oracle TDE keystore configuration type. (in: query)
    tde_key_identifier (str): The master encryption key id of this database. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vcdbs/{vcdbId}/update"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"oracle_services": oracle_services, "instances": instances, "node_listeners": node_listeners, "invoke_datapatch": invoke_datapatch, "tde_keystore_password": tde_keystore_password, "tde_keystore_config_type": tde_keystore_config_type, "tde_key_identifier": tde_key_identifier}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def start_vcdb(vcdbId: str, instances: Optional[Any] = None) -> dict:
    """
    POST /vcdbs/{vcdbId}/start

    Args:
    vcdbId (str): Path parameter
    instances (Any): List of specific Virtual Container Database Instances to start. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vcdbs/{vcdbId}/start"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"instances": instances}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def stop_vcdb(vcdbId: str, instances: Optional[Any] = None, abort: Optional[bool] = None) -> dict:
    """
    POST /vcdbs/{vcdbId}/stop

    Args:
    vcdbId (str): Path parameter
    instances (Any): List of specific Virtual Container Database Instances to stop. (in: query)
    abort (bool): Whether to issue 'shutdown abort' to shutdown Virtual Container DB instances. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vcdbs/{vcdbId}/stop"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"instances": instances, "abort": abort}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def upgrade_vcdb(vcdbId: str, repository_id: str, environment_user_id: str) -> dict:
    """
    POST /vcdbs/{vcdbId}/upgrade

    Args:
    vcdbId (str): Path parameter
    repository_id (str): The id of the CDB/vCDB repository to upgrade to. (in: query)
    environment_user_id (str): Reference of the environment user to use for CDB/vCDB upgrade. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vcdbs/{vcdbId}/upgrade"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"repository_id": repository_id, "environment_user_id": environment_user_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def verify_vcdb_jdbc_connection_string(vcdbId: str, database_username: str, database_password: str, jdbc_connection_string: str) -> dict:
    """
    POST /vcdbs/{vcdbId}/jdbc-check

    Args:
    vcdbId (str): Path parameter
    database_username (str): oracle database username. (in: query)
    database_password (str): oracle database password. (in: query)
    jdbc_connection_string (str): Oracle jdbc connection string to validate. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"vcdbs/{vcdbId}/jdbc-check"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"database_username": database_username, "database_password": database_password, "jdbc_connection_string": jdbc_connection_string}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def list_virtualization_policies(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /virtualization-policies

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-policies"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_virtualization_policy(name: str, policy_type: str, policy_targets: Optional[Any] = None, provision_source: Optional[str] = None, timezone_id: Optional[str] = None, data_duration: Optional[int] = None, data_unit: Optional[str] = None, log_duration: Optional[int] = None, log_unit: Optional[str] = None, num_of_daily: Optional[int] = None, num_of_weekly: Optional[int] = None, day_of_week: Optional[str] = None, num_of_monthly: Optional[int] = None, day_of_month: Optional[int] = None, num_of_yearly: Optional[int] = None, day_of_year: Optional[str] = None, schedules: Optional[Any] = None, size: Optional[int] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /virtualization-policies

    Args:
    name (str): The name of the virtualization policy. (in: query)
    policy_type (str): The type of a virtualization policy. (in: query)
    policy_targets (Any): The target objects that will have this policy applied to them upon creation of the policy. (in: query)
    provision_source (str): The source of the data to provision from [Refresh Policy]. (in: query)
    timezone_id (str): The timezone to use for scheduling. (in: query)
    data_duration (int): Amount of time to keep source data [Retention Policy]. (in: query)
    data_unit (str): Time unit for data_duration [Retention Policy]. (in: query)
    log_duration (int): Amount of time to keep log data [Retention Policy]. (in: query)
    log_unit (str): Time unit for log_duration [Retention Policy]. (in: query)
    num_of_daily (int): Number of daily snapshots to keep [Retention Policy]. (in: query)
    num_of_weekly (int): Number of weekly snapshots to keep [Retention Policy]. (in: query)
    day_of_week (str): Day of week upon which to enforce weekly snapshot retention [Retention Policy]. (in: query)
    num_of_monthly (int): Number of monthly snapshots to keep [Retention Policy]. (in: query)
    day_of_month (int): Day of month upon which to enforce monthly snapshot retention [Retention Policy]. (in: query)
    num_of_yearly (int): Number of yearly snapshots to keep [Retention Policy]. (in: query)
    day_of_year (str): Day of year upon which to enforce yearly snapshot retention, expressed a month / day string (e.g., "Jan 1") [Retention Policy]. (in: query)
    schedules (Any): The schedules for this policy. (in: query)
    size (int): Size of the quota, in bytes. [Quota Policy]. (in: query)
    tags (Any): The tags to be created for the policy. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-policies"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "policy_type": policy_type, "policy_targets": policy_targets, "provision_source": provision_source, "timezone_id": timezone_id, "data_duration": data_duration, "data_unit": data_unit, "log_duration": log_duration, "log_unit": log_unit, "num_of_daily": num_of_daily, "num_of_weekly": num_of_weekly, "day_of_week": day_of_week, "num_of_monthly": num_of_monthly, "day_of_month": day_of_month, "num_of_yearly": num_of_yearly, "day_of_year": day_of_year, "schedules": schedules, "size": size, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_virtualization_policies(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /virtualization-policies/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-policies/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_virtualization_policy_targets(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /virtualization-policies/targets/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-policies/targets/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_virtualization_policy_by_id(policyId: str) -> dict:
    """
    GET /virtualization-policies/{policyId}

    Args:
    policyId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-policies/{policyId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_virtualization_policy(policyId: str) -> dict:
    """
    DELETE /virtualization-policies/{policyId}

    Args:
    policyId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-policies/{policyId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_virtualization_policy(policyId: str, name: Optional[str] = None, timezone_id: Optional[str] = None, data_duration: Optional[int] = None, data_unit: Optional[str] = None, log_duration: Optional[int] = None, log_unit: Optional[str] = None, num_of_daily: Optional[int] = None, num_of_weekly: Optional[int] = None, day_of_week: Optional[str] = None, num_of_monthly: Optional[int] = None, day_of_month: Optional[int] = None, num_of_yearly: Optional[int] = None, day_of_year: Optional[str] = None, schedules: Optional[Any] = None, size: Optional[int] = None) -> dict:
    """
    PATCH /virtualization-policies/{policyId}

    Args:
    policyId (str): Path parameter
    name (str): The name of the virtualization policy. (in: query)
    timezone_id (str): The timezone to use for scheduling. (in: query)
    data_duration (int): Amount of time to keep source data [Retention Policy]. (in: query)
    data_unit (str): Time unit for data_duration [Retention Policy]. (in: query)
    log_duration (int): Amount of time to keep log data [Retention Policy]. (in: query)
    log_unit (str): Time unit for log_duration [Retention Policy]. (in: query)
    num_of_daily (int): Number of daily snapshots to keep [Retention Policy]. (in: query)
    num_of_weekly (int): Number of weekly snapshots to keep [Retention Policy]. (in: query)
    day_of_week (str): Day of week upon which to enforce weekly snapshot retention [Retention Policy]. (in: query)
    num_of_monthly (int): Number of monthly snapshots to keep [Retention Policy]. (in: query)
    day_of_month (int): Day of month upon which to enforce monthly snapshot retention [Retention Policy]. (in: query)
    num_of_yearly (int): Number of yearly snapshots to keep [Retention Policy]. (in: query)
    day_of_year (str): Day of year upon which to enforce yearly snapshot retention, expressed a month / day string (e.g., "Jan 1") [Retention Policy]. (in: query)
    schedules (Any): The schedules for this policy. (in: query)
    size (int): Size of the quota, in bytes. (QUOTA_POLICY only). (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-policies/{policyId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "timezone_id": timezone_id, "data_duration": data_duration, "data_unit": data_unit, "log_duration": log_duration, "log_unit": log_unit, "num_of_daily": num_of_daily, "num_of_weekly": num_of_weekly, "day_of_week": day_of_week, "num_of_monthly": num_of_monthly, "day_of_month": day_of_month, "num_of_yearly": num_of_yearly, "day_of_year": day_of_year, "schedules": schedules, "size": size}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def convert_virtualization_policy(policyId: str) -> dict:
    """
    POST /virtualization-policies/{policyId}/convert

    Args:
    policyId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-policies/{policyId}/convert"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_virtualization_policy_tags(policyId: str) -> dict:
    """
    GET /virtualization-policies/{policyId}/tags

    Args:
    policyId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-policies/{policyId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_virtualization_policy_tags(policyId: str, tags: Any) -> dict:
    """
    POST /virtualization-policies/{policyId}/tags

    Args:
    policyId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-policies/{policyId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_virtualization_policy_tags(policyId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /virtualization-policies/{policyId}/tags/delete

    Args:
    policyId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-policies/{policyId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def apply_virtualization_policy_by_id_or_name(policyId: str) -> dict:
    """
    POST /virtualization-policies/{policyId}/apply

    Args:
    policyId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-policies/{policyId}/apply"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def unapply_virtualization_policy_by_id_or_name(policyId: str) -> dict:
    """
    POST /virtualization-policies/{policyId}/unapply

    Args:
    policyId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-policies/{policyId}/unapply"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_replication_profiles(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /replication-profiles

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"replication-profiles"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_replication_profile(replication_mode: str, engine_id: str, target_engine_id: str, name: Optional[str] = None, target_host: Optional[str] = None, target_port: Optional[int] = None, description: Optional[str] = None, schedule: Optional[str] = None, tags: Optional[Any] = None, enable_tag_replication: Optional[bool] = None, bandwidth_limit: Optional[int] = None, number_of_connections: Optional[int] = None, encrypted: Optional[bool] = None, automatic_replication: Optional[bool] = None, use_system_socks_setting: Optional[bool] = None, vdb_ids: Optional[Any] = None, dsource_ids: Optional[Any] = None, cdb_ids: Optional[Any] = None, vcdb_ids: Optional[Any] = None, group_ids: Optional[Any] = None, replicate_entire_engine: Optional[bool] = None) -> dict:
    """
    POST /replication-profiles

    Args:
    name (str): The ReplicationProfile name. (in: query)
    replication_mode (str): The ReplicationProfile mode. (in: query)
    engine_id (str): The ID of the engine that the ReplicationProfile belongs to. (in: query)
    target_engine_id (str): The ID of the replication target engine. (in: query)
    target_host (str): Hostname of the replication target engine. If none is provided, the hostname for the engine referenced by target_engine_id will be used. (in: query)
    target_port (int): Target TCP port number for the Delphix Session Protocol. (in: query)
    description (str): The ReplicationProfile description. (in: query)
    schedule (str): Replication schedule in the form of a quartz-formatted string. (in: query)
    tags (Any): The tags that are applied to this ReplicationProfile. (in: query)
    enable_tag_replication (bool): Indicates whether tag replication from primary object to replica object is enabled or disabled for this ReplicationProfile. (in: query)
    bandwidth_limit (int): Bandwidth limit (MB/s) for replication network traffic. A value of 0 means no limit. (in: query)
    number_of_connections (int): Total number of transport connections to use. (in: query)
    encrypted (bool): Encrypt replication network traffic. (in: query)
    automatic_replication (bool): Indication whether the replication spec schedule is enabled or not. (in: query)
    use_system_socks_setting (bool): Connect to the replication target host via the system-wide SOCKS proxy. (in: query)
    vdb_ids (Any): The VDBs that are replicated by this ReplicationProfile. (in: query)
    dsource_ids (Any): The dSources that are replicated by this ReplicationProfile. (in: query)
    cdb_ids (Any): The CDBs that are replicated by this ReplicationProfile. (in: query)
    vcdb_ids (Any): The vCDBs that are replicated by this ReplicationProfile. (in: query)
    group_ids (Any): The groups that are replicated by this ReplicationProfile. (in: query)
    replicate_entire_engine (bool): Whether to replicate the entire engine. This is mutually exclusive with the vdb_ids, dsource_ids, cdb_ids, vcdb_ids, and group_ids properties. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"replication-profiles"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "replication_mode": replication_mode, "engine_id": engine_id, "target_engine_id": target_engine_id, "target_host": target_host, "target_port": target_port, "description": description, "schedule": schedule, "tags": tags, "enable_tag_replication": enable_tag_replication, "bandwidth_limit": bandwidth_limit, "number_of_connections": number_of_connections, "encrypted": encrypted, "automatic_replication": automatic_replication, "use_system_socks_setting": use_system_socks_setting, "vdb_ids": vdb_ids, "dsource_ids": dsource_ids, "cdb_ids": cdb_ids, "vcdb_ids": vcdb_ids, "group_ids": group_ids, "replicate_entire_engine": replicate_entire_engine}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_replication_profiles(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /replication-profiles/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"replication-profiles/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def migrate_rerun(job_type: str) -> dict:
    """
    POST /migrate-job/re-run

    Args:
    job_type (str): Job name to rerun. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"migrate-job/re-run"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"job_type": job_type}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_virtualization_job_history(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, object_id: Optional[str] = None, object_type: Optional[str] = None, job_type: Optional[str] = None) -> dict:
    """
    GET /virtualization-jobs/history

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    object_id (str): The object id to filter by. (in: query)
    object_type (str): The object type to filter by. (in: query)
    job_type (str): The job type to filter by. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-jobs/history"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort, "object_id": object_id, "object_type": object_type, "job_type": job_type}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_virtualization_job_history(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /virtualization-jobs/history/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-jobs/history/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_virtualization_action_history(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /virtualization-actions/history

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-actions/history"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_virtualization_action_history(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /virtualization-actions/history/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-actions/history/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def execute_replication_profile(replicationProfileId: str) -> dict:
    """
    POST /replication-profiles/{replicationProfileId}/execute

    Args:
    replicationProfileId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"replication-profiles/{replicationProfileId}/execute"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_replication_profile_by_id(replicationProfileId: str) -> dict:
    """
    GET /replication-profiles/{replicationProfileId}

    Args:
    replicationProfileId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"replication-profiles/{replicationProfileId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_replication_profile(replicationProfileId: str) -> dict:
    """
    DELETE /replication-profiles/{replicationProfileId}

    Args:
    replicationProfileId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"replication-profiles/{replicationProfileId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_replication_profile(replicationProfileId: str, name: Optional[str] = None, description: Optional[str] = None, target_engine_id: Optional[str] = None, target_host: Optional[str] = None, target_port: Optional[int] = None, replication_mode: Optional[str] = None, schedule: Optional[str] = None, vdb_ids: Optional[Any] = None, dsource_ids: Optional[Any] = None, cdb_ids: Optional[Any] = None, vcdb_ids: Optional[Any] = None, group_ids: Optional[Any] = None, enable_tag_replication: Optional[bool] = None, replicate_entire_engine: Optional[bool] = None, bandwidth_limit: Optional[int] = None, number_of_connections: Optional[int] = None, encrypted: Optional[bool] = None, automatic_replication: Optional[bool] = None, use_system_socks_setting: Optional[bool] = None) -> dict:
    """
    PATCH /replication-profiles/{replicationProfileId}

    Args:
    replicationProfileId (str): Path parameter
    name (str): The ReplicationProfile name. (in: query)
    description (str): The ReplicationProfile description. (in: query)
    target_engine_id (str): The ID of the replication target engine. (in: query)
    target_host (str): Hostname of the replication target engine. If none is provided and the target_engine_id is set, the hostname for the engine referenced by target_engine_id will be used. (in: query)
    target_port (int): Target TCP port number for the Delphix Session Protocol. (in: query)
    replication_mode (str): The ReplicationProfile mode. (in: query)
    schedule (str): Replication schedule in the form of a quartz-formatted string. (in: query)
    vdb_ids (Any): The VDBs that are replicated by this ReplicationProfile. (in: query)
    dsource_ids (Any): The dSources that are replicated by this ReplicationProfile. (in: query)
    cdb_ids (Any): The CDBs that are replicated by this ReplicationProfile. (in: query)
    vcdb_ids (Any): The vCDBs that are replicated by this ReplicationProfile. (in: query)
    group_ids (Any): The groups that are replicated by this ReplicationProfile. (in: query)
    enable_tag_replication (bool): Indicates whether tag replication from primary object to replica object is enabled or disabled for this ReplicationProfile. (in: query)
    replicate_entire_engine (bool): Whether to replicate the entire engine. This is mutually exclusive with the vdb_ids, dsource_ids, cdb_ids, vcdb_ids, and group_ids properties. (in: query)
    bandwidth_limit (int): Bandwidth limit (MB/s) for replication network traffic. A value of 0 means no limit. (in: query)
    number_of_connections (int): Total number of transport connections to use. (in: query)
    encrypted (bool): Encrypt replication network traffic. (in: query)
    automatic_replication (bool): Indication whether the replication spec schedule is enabled or not. (in: query)
    use_system_socks_setting (bool): Connect to the replication target host via the system-wide SOCKS proxy. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"replication-profiles/{replicationProfileId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description, "target_engine_id": target_engine_id, "target_host": target_host, "target_port": target_port, "replication_mode": replication_mode, "schedule": schedule, "vdb_ids": vdb_ids, "dsource_ids": dsource_ids, "cdb_ids": cdb_ids, "vcdb_ids": vcdb_ids, "group_ids": group_ids, "enable_tag_replication": enable_tag_replication, "replicate_entire_engine": replicate_entire_engine, "bandwidth_limit": bandwidth_limit, "number_of_connections": number_of_connections, "encrypted": encrypted, "automatic_replication": automatic_replication, "use_system_socks_setting": use_system_socks_setting}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_replication_profile_tags(replicationProfileId: str) -> dict:
    """
    GET /replication-profiles/{replicationProfileId}/tags

    Args:
    replicationProfileId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"replication-profiles/{replicationProfileId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_replication_profile_tags(replicationProfileId: str, tags: Any) -> dict:
    """
    POST /replication-profiles/{replicationProfileId}/tags

    Args:
    replicationProfileId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"replication-profiles/{replicationProfileId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_replication_profile_tags(replicationProfileId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /replication-profiles/{replicationProfileId}/tags/delete

    Args:
    replicationProfileId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"replication-profiles/{replicationProfileId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def enable_tag_replication(replicationProfileId: str) -> dict:
    """
    POST /replication-profiles/{replicationProfileId}/enable-tag-replication

    Args:
    replicationProfileId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"replication-profiles/{replicationProfileId}/enable-tag-replication"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def disable_tag_replication(replicationProfileId: str) -> dict:
    """
    POST /replication-profiles/{replicationProfileId}/disable-tag-replication

    Args:
    replicationProfileId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"replication-profiles/{replicationProfileId}/disable-tag-replication"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def list_namespaces(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /namespaces

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"namespaces"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_namespaces(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /namespaces/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"namespaces/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_namespace_by_id(namespaceId: str) -> dict:
    """
    GET /namespace/{namespaceId}

    Args:
    namespaceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"namespace/{namespaceId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_namespace(namespaceId: str) -> dict:
    """
    DELETE /namespace/{namespaceId}

    Args:
    namespaceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"namespace/{namespaceId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_namespace(namespaceId: str, name: Optional[str] = None, description: Optional[str] = None) -> dict:
    """
    PATCH /namespace/{namespaceId}

    Args:
    namespaceId (str): Path parameter
    name (str): The Namespace name. (in: query)
    description (str): The description of the namespace. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"namespace/{namespaceId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def failover_namespace(namespaceId: str, enable_failback: Optional[bool] = None) -> dict:
    """
    POST /namespace/{namespaceId}/failover

    Args:
    namespaceId (str): Path parameter
    enable_failback (bool): Whether to enable failback for the datasets being failed over. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"namespace/{namespaceId}/failover"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"enable_failback": enable_failback}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def commit_failover_namespace(namespaceId: str) -> dict:
    """
    POST /namespace/{namespaceId}/commitFailover

    Args:
    namespaceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"namespace/{namespaceId}/commitFailover"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def failback_namespace(namespaceId: str) -> dict:
    """
    POST /namespace/{namespaceId}/failback

    Args:
    namespaceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"namespace/{namespaceId}/failback"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def discard_namespace(namespaceId: str) -> dict:
    """
    POST /namespace/{namespaceId}/discard

    Args:
    namespaceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"namespace/{namespaceId}/discard"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_virtualization_alerts_history(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /virtualization-alerts/history

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-alerts/history"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_virtualization_alerts_history(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /virtualization-alerts/history/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-alerts/history/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_virtualization_faults_history(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /virtualization-faults/history

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-faults/history"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_virtualization_faults_history(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /virtualization-faults/history/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-faults/history/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def resolve_or_ignore_virtualization_faults(engine_id: Optional[str] = None, ignore: Optional[bool] = None, fault_ids: Optional[Any] = None) -> dict:
    """
    POST /virtualization-faults/resolveOrIgnore

    Args:
    engine_id (str): The ID of the engine that the faults belong to. (in: query)
    ignore (bool): Flag indicating whether to ignore the selected faults if they are detected on the same objects in the future. (in: query)
    fault_ids (Any): The IDs of the faults to resolve or ignore. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-faults/resolveOrIgnore"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"engine_id": engine_id, "ignore": ignore, "fault_ids": fault_ids}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def resolve_all_virtualization_faults(engineId: str) -> dict:
    """
    POST /virtualization-faults/{engineId}/resolveAll

    Args:
    engineId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-faults/{engineId}/resolveAll"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def resolve_virtualization_fault(faultId: str, ignore: Optional[bool] = None, resolution_comments: Optional[str] = None) -> dict:
    """
    POST /virtualization-fault/{faultId}/resolve

    Args:
    faultId (str): Path parameter
    ignore (bool): Flag indicating whether to ignore this fault if it is detected on the same object in the future. (in: query)
    resolution_comments (str): The comments describing the steps taken to resolve a fault. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"virtualization-fault/{faultId}/resolve"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"ignore": ignore, "resolution_comments": resolution_comments}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_heldspace_deletion_dependencies(heldspaceId: str) -> dict:
    """
    GET /heldspace/{heldspaceId}/deletion-dependencies

    Args:
    heldspaceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"heldspace/{heldspaceId}/deletion-dependencies"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_heldspace_by_id(heldspaceId: str) -> dict:
    """
    POST /heldspace/{heldspaceId}/delete

    Args:
    heldspaceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"heldspace/{heldspaceId}/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def list_hook_templates(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /hook-templates

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hook-templates"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_hook_template(name: str, command: str, description: Optional[str] = None, shell: Optional[str] = None, credentials_env_vars: Optional[Any] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /hook-templates

    Args:
    name (str): Name of the hook template. (in: query)
    description (str): Description of the hook template. (in: query)
    shell (str): shell (in: query)
    command (str): command (in: query)
    credentials_env_vars (Any): List of environment variables that will contain credentials for this operation. (in: query)
    tags (Any): The tags to be created for the hook template. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hook-templates"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description, "shell": shell, "command": command, "credentials_env_vars": credentials_env_vars, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hook_template_by_id(hookTemplateId: str) -> dict:
    """
    GET /hook-templates/{hookTemplateId}

    Args:
    hookTemplateId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hook-templates/{hookTemplateId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_hook_template(hookTemplateId: str) -> dict:
    """
    DELETE /hook-templates/{hookTemplateId}

    Args:
    hookTemplateId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hook-templates/{hookTemplateId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_hook_template(hookTemplateId: str, name: Optional[str] = None, description: Optional[str] = None, shell: Optional[str] = None, command: Optional[str] = None, credentials_env_vars: Optional[Any] = None) -> dict:
    """
    PATCH /hook-templates/{hookTemplateId}

    Args:
    hookTemplateId (str): Path parameter
    name (str): Name of the hook template. (in: query)
    description (str): Description of the hook template. (in: query)
    shell (str): shell (in: query)
    command (str): command (in: query)
    credentials_env_vars (Any): List of environment variables that will contain credentials for this operation. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hook-templates/{hookTemplateId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description, "shell": shell, "command": command, "credentials_env_vars": credentials_env_vars}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_hook_templates(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /hook-templates/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hook-templates/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hook_template_tags(hookTemplateId: str) -> dict:
    """
    GET /hook-templates/{hookTemplateId}/tags

    Args:
    hookTemplateId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hook-templates/{hookTemplateId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_hook_template_tags(hookTemplateId: str, tags: Any) -> dict:
    """
    POST /hook-templates/{hookTemplateId}/tags

    Args:
    hookTemplateId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hook-templates/{hookTemplateId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_hook_template_tags(hookTemplateId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /hook-templates/{hookTemplateId}/tags/delete

    Args:
    hookTemplateId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hook-templates/{hookTemplateId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_registered_engines(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /management/engines

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/engines"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def register_engine(name: str, hostname: str, username: Optional[str] = None, password: Optional[str] = None, masking_username: Optional[str] = None, masking_password: Optional[str] = None, hashicorp_vault_username_command_args: Optional[Any] = None, hashicorp_vault_masking_username_command_args: Optional[Any] = None, hashicorp_vault_password_command_args: Optional[Any] = None, hashicorp_vault_masking_password_command_args: Optional[Any] = None, hashicorp_vault_id: Optional[int] = None, masking_hashicorp_vault_id: Optional[int] = None, insecure_ssl: Optional[bool] = None, unsafe_ssl_hostname_check: Optional[bool] = None, auto_tagging_config: Optional[Any] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /management/engines

    Args:
    name (str): name (in: query)
    hostname (str): hostname (in: query)
    username (str): The virtualization domain admin username. (in: query)
    password (str): The virtualization domain admin password. (in: query)
    masking_username (str): The masking admin username. (in: query)
    masking_password (str): The masking admin password. (in: query)
    hashicorp_vault_username_command_args (Any): Arguments to pass to the Vault CLI tool to retrieve the virtualzation username for the engine. (in: query)
    hashicorp_vault_masking_username_command_args (Any): Arguments to pass to the Vault CLI tool to retrieve the masking username for the engine. (in: query)
    hashicorp_vault_password_command_args (Any): Arguments to pass to the Vault CLI tool to retrieve the virtualization password for the engine. (in: query)
    hashicorp_vault_masking_password_command_args (Any): Arguments to pass to the Vault CLI tool to retrieve the masking password for the engine. (in: query)
    hashicorp_vault_id (int): Reference to the Hashicorp vault to use to retrieve virtualization engine credentials. (in: query)
    masking_hashicorp_vault_id (int): Reference to the Hashicorp vault to use to retrieve masking engine credentials. (in: query)
    insecure_ssl (bool): Allow connections to the engine over HTTPs without validating the TLS certificate. Even though
the connection to the engine might be performed over HTTPs, setting this property eliminates
the protection against a man-in-the-middle attach for connections to this engine. Instead,
consider configuring DCT with Certificate Authority certificates.. (in: query)
    unsafe_ssl_hostname_check (bool): Ignore validation of the name associated to the TLS certificate when connecting to the engine over HTTPs.
Setting this value must only be done if the TLS certificate of the engine does not match the hostname,
and the TLS configuration of the engine cannot be fixed. Setting this property reduces the protection
against a man-in-the-middle attack for connections to this engine.
This is ignored if insecure_ssl is set. (in: query)
    auto_tagging_config (Any): Configuration settings for auto tagging. (in: query)
    tags (Any): The tags to be created for this engine. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/engines"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "hostname": hostname, "username": username, "password": password, "masking_username": masking_username, "masking_password": masking_password, "hashicorp_vault_username_command_args": hashicorp_vault_username_command_args, "hashicorp_vault_masking_username_command_args": hashicorp_vault_masking_username_command_args, "hashicorp_vault_password_command_args": hashicorp_vault_password_command_args, "hashicorp_vault_masking_password_command_args": hashicorp_vault_masking_password_command_args, "hashicorp_vault_id": hashicorp_vault_id, "masking_hashicorp_vault_id": masking_hashicorp_vault_id, "insecure_ssl": insecure_ssl, "unsafe_ssl_hostname_check": unsafe_ssl_hostname_check, "auto_tagging_config": auto_tagging_config, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_jobs(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /jobs

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"jobs"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_jobs(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /jobs/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"jobs/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_job_by_id(jobId: str) -> dict:
    """
    GET /jobs/{jobId}

    Args:
    jobId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"jobs/{jobId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def abandon_job(jobId: str) -> dict:
    """
    Abandoning a job means that the system will no longer track ongoing progress. The system will not attempt to stop the process in any way. The job will be moved to the ABANDONED terminal state.


    Args:
    jobId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"jobs/{jobId}/abandon"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_job_result(jobId: str) -> dict:
    """
    Get job result.

    Args:
    jobId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"jobs/{jobId}/result"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_job_tags(jobId: str) -> dict:
    """
    GET /jobs/{jobId}/tags

    Args:
    jobId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"jobs/{jobId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_job_tags(jobId: str, tags: Any) -> dict:
    """
    POST /jobs/{jobId}/tags

    Args:
    jobId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"jobs/{jobId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_job_tag(jobId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /jobs/{jobId}/tags/delete

    Args:
    jobId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"jobs/{jobId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_registered_engine(engineId: str) -> dict:
    """
    GET /management/engines/{engineId}

    Args:
    engineId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/engines/{engineId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_registered_engine(engineId: str, id: Optional[str] = None, uuid: Optional[str] = None, type: Optional[str] = None, version: Optional[str] = None, name: Optional[str] = None, ssh_public_key: Optional[str] = None, hostname: Optional[str] = None, cpu_core_count: Optional[int] = None, memory_size: Optional[int] = None, data_storage_capacity: Optional[int] = None, data_storage_used: Optional[int] = None, insecure_ssl: Optional[bool] = None, unsafe_ssl_hostname_check: Optional[bool] = None, status: Optional[str] = None, connection_status: Optional[str] = None, engine_connection_status: Optional[str] = None, connection_status_details: Optional[str] = None, engine_connection_status_details: Optional[str] = None, username: Optional[str] = None, password: Optional[str] = None, masking_username: Optional[str] = None, masking_password: Optional[str] = None, hashicorp_vault_username_command_args: Optional[Any] = None, hashicorp_vault_masking_username_command_args: Optional[Any] = None, hashicorp_vault_password_command_args: Optional[Any] = None, hashicorp_vault_masking_password_command_args: Optional[Any] = None, masking_hashicorp_vault_id: Optional[int] = None, hashicorp_vault_id: Optional[int] = None, tags: Optional[Any] = None, masking_memory_used: Optional[int] = None, masking_allocated_memory: Optional[int] = None, masking_jobs_running: Optional[int] = None, masking_max_concurrent_jobs: Optional[int] = None, masking_available_cores: Optional[int] = None, hyperscale_instance_ids: Optional[Any] = None, hyperscale_truststore_filename: Optional[str] = None, hyperscale_truststore_password: Optional[str] = None) -> dict:
    """
    PUT /management/engines/{engineId}

    Args:
    engineId (str): Path parameter
    id (str): The Engine object entity ID. (in: query)
    uuid (str): The unique identifier generated by this engine. (in: query)
    type (str): The type of this engine. (in: query)
    version (str): The engine version. (in: query)
    name (str): The name of this engine. (in: query)
    ssh_public_key (str): The ssh public key of this engine. (in: query)
    hostname (str): The hostname of this engine. (in: query)
    cpu_core_count (int): The total number of CPU cores on this engine. (in: query)
    memory_size (int): The total amount of memory on this engine, in bytes. (in: query)
    data_storage_capacity (int): The total amount of storage allocated for engine objects and system metadata, in bytes. (in: query)
    data_storage_used (int): The amount of storage used by engine objects and system metadata, in bytes. (in: query)
    insecure_ssl (bool): Allow connections to the engine over HTTPs without validating the TLS certificate. Even though
the connection to the engine might be performed over HTTPs, setting this property eliminates
the protection against a man-in-the-middle attach for connections to this engine. Instead,
consider configuring DCT with Certificate Authority certificates. (in: query)
    unsafe_ssl_hostname_check (bool): Ignore validation of the name associated to the TLS certificate when connecting to the engine over HTTPs.
Setting this value must only be done if the TLS certificate of the engine does not match the hostname,
and the TLS configuration of the engine cannot be fixed. Setting this property reduces the protection
against a man-in-the-middle attack for connections to this engine.
This is ignored if insecure_ssl is set. (in: query)
    status (str): the status of the engine (in: query)
    connection_status (str): The status of the connection to the engine. Deprecated; use "engine_connection_status" instead. (in: query)
    engine_connection_status (str): The state of the connection to the engine. (in: query)
    connection_status_details (str): If set, details about the status of the connection to the engine. Deprecated; use "engine_connection_status_details" instead. (in: query)
    engine_connection_status_details (str): If set, details about the state of the connection to the engine. (in: query)
    username (str): The virtualization domain admin username. (in: query)
    password (str): The virtualization domain admin password. (in: query)
    masking_username (str): The masking admin username. (in: query)
    masking_password (str): The masking admin password. (in: query)
    hashicorp_vault_username_command_args (Any): Arguments to pass to the Vault CLI tool to retrieve the virtualization username for the engine. (in: query)
    hashicorp_vault_masking_username_command_args (Any): Arguments to pass to the Vault CLI tool to retrieve the masking username for the engine. (in: query)
    hashicorp_vault_password_command_args (Any): Arguments to pass to the Vault CLI tool to retrieve the virtualization password for the engine. (in: query)
    hashicorp_vault_masking_password_command_args (Any): Arguments to pass to the Vault CLI tool to retrieve the masking password for the engine. (in: query)
    masking_hashicorp_vault_id (int): Reference to the Hashicorp vault to use to retrieve masking engine credentials. (in: query)
    hashicorp_vault_id (int): Reference to the Hashicorp vault to use to retrieve virtualization engine credentials. (in: query)
    tags (Any): The tags to be created for this engine. (in: query)
    masking_memory_used (int): The current amount of memory used by running masking jobs in bytes. (in: query)
    masking_allocated_memory (int): The maximum amount of memory available for running masking jobs in bytes. (in: query)
    masking_jobs_running (int): The number of masking jobs currently running. (in: query)
    masking_max_concurrent_jobs (int): The maximum number of masking jobs that can be running at the same time. (in: query)
    masking_available_cores (int): The number of CPU cores available to the masking engine. (in: query)
    hyperscale_instance_ids (Any): List of Hyperscale Instances that this engine is connected to. (in: query)
    hyperscale_truststore_filename (str): File name of a truststore which can be used to validate the TLS certificate of the engine as expected by associated hyperscale instances. (in: query)
    hyperscale_truststore_password (str): Password to read the truststore as expected by associated hyperscale instances. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/engines/{engineId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"id": id, "uuid": uuid, "type": type, "version": version, "name": name, "ssh_public_key": ssh_public_key, "hostname": hostname, "cpu_core_count": cpu_core_count, "memory_size": memory_size, "data_storage_capacity": data_storage_capacity, "data_storage_used": data_storage_used, "insecure_ssl": insecure_ssl, "unsafe_ssl_hostname_check": unsafe_ssl_hostname_check, "status": status, "connection_status": connection_status, "engine_connection_status": engine_connection_status, "connection_status_details": connection_status_details, "engine_connection_status_details": engine_connection_status_details, "username": username, "password": password, "masking_username": masking_username, "masking_password": masking_password, "hashicorp_vault_username_command_args": hashicorp_vault_username_command_args, "hashicorp_vault_masking_username_command_args": hashicorp_vault_masking_username_command_args, "hashicorp_vault_password_command_args": hashicorp_vault_password_command_args, "hashicorp_vault_masking_password_command_args": hashicorp_vault_masking_password_command_args, "masking_hashicorp_vault_id": masking_hashicorp_vault_id, "hashicorp_vault_id": hashicorp_vault_id, "tags": tags, "masking_memory_used": masking_memory_used, "masking_allocated_memory": masking_allocated_memory, "masking_jobs_running": masking_jobs_running, "masking_max_concurrent_jobs": masking_max_concurrent_jobs, "masking_available_cores": masking_available_cores, "hyperscale_instance_ids": hyperscale_instance_ids, "hyperscale_truststore_filename": hyperscale_truststore_filename, "hyperscale_truststore_password": hyperscale_truststore_password}

    try:
        response = requests.put(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def unregister_engine(engineId: str) -> dict:
    """
    DELETE /management/engines/{engineId}

    Args:
    engineId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/engines/{engineId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_registered_engine_partial(engineId: str, id: Optional[str] = None, uuid: Optional[str] = None, type: Optional[str] = None, version: Optional[str] = None, name: Optional[str] = None, ssh_public_key: Optional[str] = None, hostname: Optional[str] = None, cpu_core_count: Optional[int] = None, memory_size: Optional[int] = None, data_storage_capacity: Optional[int] = None, data_storage_used: Optional[int] = None, insecure_ssl: Optional[bool] = None, unsafe_ssl_hostname_check: Optional[bool] = None, status: Optional[str] = None, connection_status: Optional[str] = None, engine_connection_status: Optional[str] = None, connection_status_details: Optional[str] = None, engine_connection_status_details: Optional[str] = None, username: Optional[str] = None, password: Optional[str] = None, masking_username: Optional[str] = None, masking_password: Optional[str] = None, hashicorp_vault_username_command_args: Optional[Any] = None, hashicorp_vault_masking_username_command_args: Optional[Any] = None, hashicorp_vault_password_command_args: Optional[Any] = None, hashicorp_vault_masking_password_command_args: Optional[Any] = None, masking_hashicorp_vault_id: Optional[int] = None, hashicorp_vault_id: Optional[int] = None, tags: Optional[Any] = None, masking_memory_used: Optional[int] = None, masking_allocated_memory: Optional[int] = None, masking_jobs_running: Optional[int] = None, masking_max_concurrent_jobs: Optional[int] = None, masking_available_cores: Optional[int] = None, hyperscale_instance_ids: Optional[Any] = None, hyperscale_truststore_filename: Optional[str] = None, hyperscale_truststore_password: Optional[str] = None) -> dict:
    """
    PATCH /management/engines/{engineId}

    Args:
    engineId (str): Path parameter
    id (str): The Engine object entity ID. (in: query)
    uuid (str): The unique identifier generated by this engine. (in: query)
    type (str): The type of this engine. (in: query)
    version (str): The engine version. (in: query)
    name (str): The name of this engine. (in: query)
    ssh_public_key (str): The ssh public key of this engine. (in: query)
    hostname (str): The hostname of this engine. (in: query)
    cpu_core_count (int): The total number of CPU cores on this engine. (in: query)
    memory_size (int): The total amount of memory on this engine, in bytes. (in: query)
    data_storage_capacity (int): The total amount of storage allocated for engine objects and system metadata, in bytes. (in: query)
    data_storage_used (int): The amount of storage used by engine objects and system metadata, in bytes. (in: query)
    insecure_ssl (bool): Allow connections to the engine over HTTPs without validating the TLS certificate. Even though
the connection to the engine might be performed over HTTPs, setting this property eliminates
the protection against a man-in-the-middle attach for connections to this engine. Instead,
consider configuring DCT with Certificate Authority certificates. (in: query)
    unsafe_ssl_hostname_check (bool): Ignore validation of the name associated to the TLS certificate when connecting to the engine over HTTPs.
Setting this value must only be done if the TLS certificate of the engine does not match the hostname,
and the TLS configuration of the engine cannot be fixed. Setting this property reduces the protection
against a man-in-the-middle attack for connections to this engine.
This is ignored if insecure_ssl is set. (in: query)
    status (str): the status of the engine (in: query)
    connection_status (str): The status of the connection to the engine. Deprecated; use "engine_connection_status" instead. (in: query)
    engine_connection_status (str): The state of the connection to the engine. (in: query)
    connection_status_details (str): If set, details about the status of the connection to the engine. Deprecated; use "engine_connection_status_details" instead. (in: query)
    engine_connection_status_details (str): If set, details about the state of the connection to the engine. (in: query)
    username (str): The virtualization domain admin username. (in: query)
    password (str): The virtualization domain admin password. (in: query)
    masking_username (str): The masking admin username. (in: query)
    masking_password (str): The masking admin password. (in: query)
    hashicorp_vault_username_command_args (Any): Arguments to pass to the Vault CLI tool to retrieve the virtualization username for the engine. (in: query)
    hashicorp_vault_masking_username_command_args (Any): Arguments to pass to the Vault CLI tool to retrieve the masking username for the engine. (in: query)
    hashicorp_vault_password_command_args (Any): Arguments to pass to the Vault CLI tool to retrieve the virtualization password for the engine. (in: query)
    hashicorp_vault_masking_password_command_args (Any): Arguments to pass to the Vault CLI tool to retrieve the masking password for the engine. (in: query)
    masking_hashicorp_vault_id (int): Reference to the Hashicorp vault to use to retrieve masking engine credentials. (in: query)
    hashicorp_vault_id (int): Reference to the Hashicorp vault to use to retrieve virtualization engine credentials. (in: query)
    tags (Any): The tags to be created for this engine. (in: query)
    masking_memory_used (int): The current amount of memory used by running masking jobs in bytes. (in: query)
    masking_allocated_memory (int): The maximum amount of memory available for running masking jobs in bytes. (in: query)
    masking_jobs_running (int): The number of masking jobs currently running. (in: query)
    masking_max_concurrent_jobs (int): The maximum number of masking jobs that can be running at the same time. (in: query)
    masking_available_cores (int): The number of CPU cores available to the masking engine. (in: query)
    hyperscale_instance_ids (Any): List of Hyperscale Instances that this engine is connected to. (in: query)
    hyperscale_truststore_filename (str): File name of a truststore which can be used to validate the TLS certificate of the engine as expected by associated hyperscale instances. (in: query)
    hyperscale_truststore_password (str): Password to read the truststore as expected by associated hyperscale instances. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/engines/{engineId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"id": id, "uuid": uuid, "type": type, "version": version, "name": name, "ssh_public_key": ssh_public_key, "hostname": hostname, "cpu_core_count": cpu_core_count, "memory_size": memory_size, "data_storage_capacity": data_storage_capacity, "data_storage_used": data_storage_used, "insecure_ssl": insecure_ssl, "unsafe_ssl_hostname_check": unsafe_ssl_hostname_check, "status": status, "connection_status": connection_status, "engine_connection_status": engine_connection_status, "connection_status_details": connection_status_details, "engine_connection_status_details": engine_connection_status_details, "username": username, "password": password, "masking_username": masking_username, "masking_password": masking_password, "hashicorp_vault_username_command_args": hashicorp_vault_username_command_args, "hashicorp_vault_masking_username_command_args": hashicorp_vault_masking_username_command_args, "hashicorp_vault_password_command_args": hashicorp_vault_password_command_args, "hashicorp_vault_masking_password_command_args": hashicorp_vault_masking_password_command_args, "masking_hashicorp_vault_id": masking_hashicorp_vault_id, "hashicorp_vault_id": hashicorp_vault_id, "tags": tags, "masking_memory_used": masking_memory_used, "masking_allocated_memory": masking_allocated_memory, "masking_jobs_running": masking_jobs_running, "masking_max_concurrent_jobs": masking_max_concurrent_jobs, "masking_available_cores": masking_available_cores, "hyperscale_instance_ids": hyperscale_instance_ids, "hyperscale_truststore_filename": hyperscale_truststore_filename, "hyperscale_truststore_password": hyperscale_truststore_password}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_engine_auto_tagging_config(engineId: str) -> dict:
    """
    GET /management/engines/{engineId}/auto-tagging

    Args:
    engineId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/engines/{engineId}/auto-tagging"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_engine_auto_tagging_config(engineId: str, enable_virtualization_dataset_groups: Optional[bool] = None, enable_masking_environments: Optional[bool] = None, enable_masking_applications: Optional[bool] = None, enable_engine_name: Optional[bool] = None, custom_tags_to_add: Optional[Any] = None, custom_tags_to_remove: Optional[Any] = None) -> dict:
    """
    PATCH /management/engines/{engineId}/auto-tagging

    Args:
    engineId (str): Path parameter
    enable_virtualization_dataset_groups (bool): Include dataset group names as tags for dSources, VDBs, and vCDBs (key 'dlpx-dataset-group'). (in: query)
    enable_masking_environments (bool): Include masking environment names as tags for masking Jobs and Connectors (key 'dlpx-environment'). (in: query)
    enable_masking_applications (bool): Include masking app names as tags for masking Jobs and Connectors (key 'dlpx-application'). (in: query)
    enable_engine_name (bool): Include the engine name as a tag on discovered objects (key 'dlpx-engine'). (in: query)
    custom_tags_to_add (Any): List of new custom tags to be added to discovered objects. These are appended to the AutoTaggingConfig's custom_tags list. (in: query)
    custom_tags_to_remove (Any): List of tags to remove from the AutoTaggingConfig's custom_tags list (applied AFTER custom_tags_to_add). (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/engines/{engineId}/auto-tagging"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"enable_virtualization_dataset_groups": enable_virtualization_dataset_groups, "enable_masking_environments": enable_masking_environments, "enable_masking_applications": enable_masking_applications, "enable_engine_name": enable_engine_name, "custom_tags_to_add": custom_tags_to_add, "custom_tags_to_remove": custom_tags_to_remove}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_compliance_application_settings(engineId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /management/engines/{engineId}/compliance-application-settings

    Args:
    engineId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/engines/{engineId}/compliance-application-settings"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_compliance_application_settings(engineId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /management/engines/{engineId}/compliance-application-settings/search

    Args:
    engineId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/engines/{engineId}/compliance-application-settings/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_engines(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /management/engines/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/engines/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_engine_tags(engineId: str) -> dict:
    """
    GET /management/engines/{engineId}/tags

    Args:
    engineId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/engines/{engineId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_engine_tags(engineId: str, tags: Any) -> dict:
    """
    POST /management/engines/{engineId}/tags

    Args:
    engineId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/engines/{engineId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_engine_tags(engineId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /management/engines/{engineId}/tags/delete

    Args:
    engineId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/engines/{engineId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hashicorp_vaults(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /management/vaults/hashicorp

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/vaults/hashicorp"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_hashicorp_vault(id: Optional[int] = None, env_variables: Optional[Any] = None, login_command_args: Optional[Any] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /management/vaults/hashicorp

    Args:
    id (int): id (in: query)
    env_variables (Any): Environment variables to set when invoking the Vault CLI tool. The environment variables will be used both
to login to the vault (if this step is required) and to retrieve engine username and passwords. (in: query)
    login_command_args (Any): Arguments to the "vault" CLI tool to be used to fetch a client token (or "login").
If supporting files, such as TLS certificates, must be used to authenticate, they can be
mounted to the /etc/config directory.
This property must not be set when using the TOKEN authentication method as login is not required. (in: query)
    tags (Any): tags (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/vaults/hashicorp"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"id": id, "env_variables": env_variables, "login_command_args": login_command_args, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_hashicorp_vaults(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /management/vaults/hashicorp/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/vaults/hashicorp/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hashicorp_vault(vaultId: str) -> dict:
    """
    GET /management/vaults/hashicorp/{vaultId}

    Args:
    vaultId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/vaults/hashicorp/{vaultId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_hashicorp_vault(vaultId: str) -> dict:
    """
    DELETE /management/vaults/hashicorp/{vaultId}

    Args:
    vaultId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/vaults/hashicorp/{vaultId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hashicorp_vault_tags(vaultId: str) -> dict:
    """
    GET /management/vaults/hashicorp/{vaultId}/tags

    Args:
    vaultId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/vaults/hashicorp/{vaultId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_hashicorp_vault_tags(vaultId: str, tags: Any) -> dict:
    """
    POST /management/vaults/hashicorp/{vaultId}/tags

    Args:
    vaultId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/vaults/hashicorp/{vaultId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_hashicorp_vault_tag(vaultId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /management/vaults/hashicorp/{vaultId}/tags/delete

    Args:
    vaultId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/vaults/hashicorp/{vaultId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_accounts(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /management/accounts

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_account(is_admin: Optional[bool] = None, generate_api_key: Optional[bool] = None, api_client_id: Optional[str] = None, first_name: Optional[str] = None, last_name: Optional[str] = None, email: Optional[str] = None, username: Optional[str] = None, password: Optional[str] = None, ldap_principal: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /management/accounts

    Args:
    is_admin (bool): Whether the created account must be granted to admin role. (in: query)
    generate_api_key (bool): Whether an API key must be generated for this Account. This must be set if the Account will be used for API key based authentication, and unset otherwise. (in: query)
    api_client_id (str): The unique ID which is used to identify the identity of an API request. The web server (nginx) configuration must be configured so as to include the external ID as the value of the X_CLIENT_ID HTTP request header when requests are proxied. If this value isn't set, the application will automatically generate one. For OAuth2/JWT based authentication, this typically corresponds to a value extracted from the JWT, uniquely identifying the Account. (in: query)
    first_name (str): An optional first name for the Account. (in: query)
    last_name (str): An optional last name for the Account. (in: query)
    email (str): An optional email for the Account. (in: query)
    username (str): The username for username/password authentication. This can also be used to provide an optional logical name for the Account. (in: query)
    password (str): The password for username/password authentication. (in: query)
    ldap_principal (str): This value will be used for linking this account to an LDAP user when authenticated with the same LDAP principal. When accounts authenticate with LDAP, an LDAP principal value is calculated based on the username, msad_domain_name, search_base and username_pattern. (in: query)
    tags (Any): The tags to be created for this Account. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"is_admin": is_admin, "generate_api_key": generate_api_key, "api_client_id": api_client_id, "first_name": first_name, "last_name": last_name, "email": email, "username": username, "password": password, "ldap_principal": ldap_principal, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def api_key_reset(id: str) -> dict:
    """
    POST /management/accounts/{id}/api-key-reset

    Args:
    id (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/{id}/api-key-reset"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def api_key_delete(id: str) -> dict:
    """
    DELETE /management/accounts/{id}/api-key-delete

    Args:
    id (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/{id}/api-key-delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def api_key_regenerate(token: str) -> dict:
    """
    POST /management/accounts/api-key-regenerate

    Args:
    token (str): Current api key for the account (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/api-key-regenerate"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"token": token}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_account(id: str) -> dict:
    """
    GET /management/accounts/{id}

    Args:
    id (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/{id}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_account(id: str, api_client_id: Optional[str] = None, first_name: Optional[str] = None, last_name: Optional[str] = None, email: Optional[str] = None, username: Optional[str] = None, ldap_principal: Optional[str] = None) -> dict:
    """
    PUT /management/accounts/{id}

    Args:
    id (str): Path parameter
    api_client_id (str): The unique ID which is used to identify the identity of an API request. The web server (nginx) configuration must be configured so as to include the external ID as the value of the X_CLIENT_ID HTTP request header when requests are proxied. For OAuth2/JWT based authentication, this typically corresponds to a value extracted from the JWT, uniquely identifying the Account. (in: query)
    first_name (str): An optional first name for the Account. (in: query)
    last_name (str): An optional last name for the Account. (in: query)
    email (str): An optional email for the Account. (in: query)
    username (str): The username for username/password authentication. This can also be used to provide an optional logical name for the Account. (in: query)
    ldap_principal (str): This value will be used for linking this account to an LDAP user when authenticated with the same LDAP principal. When accounts authenticate with LDAP, an LDAP principal value is calculated based on the username, msad_domain_name, search_base and username_pattern. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/{id}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"api_client_id": api_client_id, "first_name": first_name, "last_name": last_name, "email": email, "username": username, "ldap_principal": ldap_principal}

    try:
        response = requests.put(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_account(id: str) -> dict:
    """
    DELETE /management/accounts/{id}

    Args:
    id (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/{id}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def enable_account(id: str) -> dict:
    """
    POST /management/accounts/{id}/enable

    Args:
    id (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/{id}/enable"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def disable(id: str) -> dict:
    """
    POST /management/accounts/{id}/disable

    Args:
    id (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/{id}/disable"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def change_account_password(id: str, old_password: str, new_password: Optional[str] = None) -> dict:
    """
    POST /management/accounts/{id}/change_password

    Args:
    id (str): Path parameter
    old_password (str): Old password that needs to be changed for the Account. (in: query)
    new_password (str): New password that needs to be set for the Account. Set this to null for unsetting the current password. Not including this property also results in unsetting of the current password. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/{id}/change_password"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"old_password": old_password, "new_password": new_password}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def reset_account_password(id: str, new_password: Optional[str] = None) -> dict:
    """
    POST /management/accounts/{id}/reset_password

    Args:
    id (str): Path parameter
    new_password (str): New password that needs to be set for the Account. Set this to null for unsetting the current password. Not including this property also results in unsetting of the current password. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/{id}/reset_password"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"new_password": new_password}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_account_tags(id: str) -> dict:
    """
    GET /management/accounts/{id}/tags

    Args:
    id (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/{id}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_account_tags(id: str, tags: Any) -> dict:
    """
    POST /management/accounts/{id}/tags

    Args:
    id (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/{id}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_account_tags(id: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /management/accounts/{id}/tags/delete

    Args:
    id (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/{id}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_account_ui_profiles(id: str) -> dict:
    """
    GET /management/accounts/{id}/ui-profiles

    Args:
    id (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/{id}/ui-profiles"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_password_policies(args: Optional[dict] = None) -> dict:
    """
    GET /management/accounts/password-policies

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/password-policies"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_password_policies(enabled: Optional[bool] = None, min_length: Optional[int] = None, reuse_disallow_limit: Optional[int] = None, digit: Optional[bool] = None, uppercase_letter: Optional[bool] = None, lowercase_letter: Optional[bool] = None, special_character: Optional[bool] = None, disallow_username_as_password: Optional[bool] = None, maximum_password_attempts: Optional[int] = None) -> dict:
    """
    PATCH /management/accounts/password-policies

    Args:
    enabled (bool): True if password policies are enforced/enabled. (in: query)
    min_length (int): Minimum length for password. (in: query)
    reuse_disallow_limit (int): The password can not be the same as any of the previous n passwords. (in: query)
    digit (bool): Mandate at least one digit in password. (in: query)
    uppercase_letter (bool): Mandate at least one uppercase letter in password. (in: query)
    lowercase_letter (bool): Mandate at least one lower letter in password. (in: query)
    special_character (bool): Mandate at least one special character in password. (in: query)
    disallow_username_as_password (bool): Disallows password containing case-insensitive user name or reversed user name. (in: query)
    maximum_password_attempts (int): The number of allowed attempts for incorrect password, after which the account gets locked. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/password-policies"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"enabled": enabled, "min_length": min_length, "reuse_disallow_limit": reuse_disallow_limit, "digit": digit, "uppercase_letter": uppercase_letter, "lowercase_letter": lowercase_letter, "special_character": special_character, "disallow_username_as_password": disallow_username_as_password, "maximum_password_attempts": maximum_password_attempts}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_license(args: Optional[dict] = None) -> dict:
    """
    GET /management/license

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/license"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def change_license(tier: str) -> dict:
    """
    POST /management/license/change-license

    Args:
    tier (str): The DCT license tiers. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/license/change-license"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tier": tier}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def list_properties(args: Optional[dict] = None) -> dict:
    """
    GET /management/properties

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/properties"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_properties(disable_username_password: Optional[bool] = None, phonehome_upload_cadence: Optional[int] = None, phonehome_maximum_transfer_size: Optional[int] = None, token_expiry_time: Optional[int] = None, token_maximum_inactivity_time: Optional[int] = None, feature_flags: Optional[Any] = None, api_key_expiry_time: Optional[int] = None, allowed_ip_ranges: Optional[Any] = None) -> dict:
    """
    PATCH /management/properties

    Args:
    disable_username_password (bool): Property to define either username & password based authentication disabled or not. (in: query)
    phonehome_upload_cadence (int): Property to define the phonehome bundle upload cadence, in days, if Delphix services are reachable. (in: query)
    phonehome_maximum_transfer_size (int): Property to define the maximum uncompressed bundle transfer size, in bytes, for phonehome. (in: query)
    token_expiry_time (int): Property to define the expiry time for login token, in seconds. Specify -1 to indicate never expiry of token. (in: query)
    token_maximum_inactivity_time (int): Property to define the maximum user inactivity time for login token, in seconds. Specify -1 to indicate never invalidate of token due to inactivity. (in: query)
    feature_flags (Any): List of enabled features. (in: query)
    api_key_expiry_time (int): Property to define the expiry time for API key, in seconds. Specify -1 to indicate never expiry of tapi key. (in: query)
    allowed_ip_ranges (Any): Restricts the IP ranges DCT will connect to when registering engines. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/properties"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"disable_username_password": disable_username_password, "phonehome_upload_cadence": phonehome_upload_cadence, "phonehome_maximum_transfer_size": phonehome_maximum_transfer_size, "token_expiry_time": token_expiry_time, "token_maximum_inactivity_time": token_maximum_inactivity_time, "feature_flags": feature_flags, "api_key_expiry_time": api_key_expiry_time, "allowed_ip_ranges": allowed_ip_ranges}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_api_classification(args: Optional[dict] = None) -> dict:
    """
    GET /management/api-classification

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/api-classification"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_api_classification(version: Optional[str] = None, api_classification: Optional[Any] = None) -> dict:
    """
    PUT /management/api-classification

    Args:
    version (str): Api Classification Config Version. (in: query)
    api_classification (Any): The classification of each APIs, either it is automation or not. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/api-classification"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"version": version, "api_classification": api_classification}

    try:
        response = requests.put(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def account_login(username: Optional[str] = None, password: Optional[str] = None, api_key: Optional[str] = None) -> dict:
    """
    POST /login

    Args:
    username (str): Username of the account that needs to login (in: query)
    password (str): Password of the account that needs to login. (in: query)
    api_key (str): API key (without 'apk ' prefix) of the account that needs to login. When api_key is set then username/password would be ignored if provided. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"login"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"username": username, "password": password, "api_key": api_key}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def account_logout(Authorization: str) -> dict:
    """
    POST /logout

    Args:
    Authorization (str): Access token (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"logout"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"Authorization": Authorization}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_accounts(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /management/accounts/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/accounts/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_tags(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /management/tags

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_tags(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /management/tags/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/tags/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_tag(tagId: str) -> dict:
    """
    GET /management/tags/{tagId}

    Args:
    tagId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/tags/{tagId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_tag_usages(tagId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /management/tags/{tagId}/usages

    Args:
    tagId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/tags/{tagId}/usages"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_tag_usages(tagId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /management/tags/{tagId}/usages/search

    Args:
    tagId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/tags/{tagId}/usages/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_tag_permissions(tagId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /management/tags/{tagId}/permissions

    Args:
    tagId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/tags/{tagId}/permissions"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_tag_permissions(tagId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /management/tags/{tagId}/permissions/search

    Args:
    tagId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/tags/{tagId}/permissions/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def token_info(token: str) -> dict:
    """
    POST /token-info

    Args:
    token (str): API Key or JWT token for fetching information (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"token-info"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"token": token}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def checkSaml(args: Optional[dict] = None) -> dict:
    """
    GET /is-saml-enabled

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"is-saml-enabled"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_smtp_config(args: Optional[dict] = None) -> dict:
    """
    GET /management/smtp

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/smtp"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_smtp_config(enabled: Optional[bool] = None, server: Optional[str] = None, port: Optional[int] = None, authentication_enabled: Optional[bool] = None, tls_enabled: Optional[bool] = None, username: Optional[str] = None, password: Optional[str] = None, from_address: Optional[str] = None, send_timeout: Optional[int] = None) -> dict:
    """
    PUT /management/smtp

    Args:
    enabled (bool): True if outbound email is enabled. (in: query)
    server (str): IP address or hostname of SMTP relay server. (in: query)
    port (int): Port number to use. A value of -1 indicates the default (25 or 587 for TLS). (in: query)
    authentication_enabled (bool): True if username/password authentication should be used. (in: query)
    tls_enabled (bool): True if TLS (transport layer security) should be used. (in: query)
    username (str): If authentication is enabled, username to use when authenticating to the server. (in: query)
    password (str): If authentication is enabled, password to use when authenticating to the server. (in: query)
    from_address (str): From address to use when sending mail. If unspecified, 'noreply@delphix.com' is used. (in: query)
    send_timeout (int): Maximum timeout to wait, in seconds, when sending mail. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/smtp"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"enabled": enabled, "server": server, "port": port, "authentication_enabled": authentication_enabled, "tls_enabled": tls_enabled, "username": username, "password": password, "from_address": from_address, "send_timeout": send_timeout}

    try:
        response = requests.put(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def validate_smtp_config(to_address: str) -> dict:
    """
    POST /management/smtp/validate

    Args:
    to_address (str): to_address (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/smtp/validate"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"to_address": to_address}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_metadata_database(args: Optional[dict] = None) -> dict:
    """
    GET /management/metadata-database

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/metadata-database"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_ldap_config(args: Optional[dict] = None) -> dict:
    """
    GET /management/ldap-config

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/ldap-config"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_ldap_config(enabled: Optional[bool] = None, auto_create_users: Optional[bool] = None, hostname: Optional[str] = None, port: Optional[int] = None, domains: Optional[Any] = None, enable_ssl: Optional[bool] = None, insecure_ssl: Optional[bool] = None, unsafe_ssl_hostname_check: Optional[bool] = None) -> dict:
    """
    PUT /management/ldap-config

    Args:
    enabled (bool): When set, these settings are enabled. True by default. (in: query)
    auto_create_users (bool): When set, the system will automatically create new Accounts for those who have logged in using LDAP. This must be true if LDAP user is not already registered in system. True by default. (in: query)
    hostname (str): The hostname of the LDAP server. (in: query)
    port (int): The port of the LDAP server. Default port is 389 for non-SSL and 636 for SSL. (in: query)
    domains (Any): DCT will try to authenticate using each Domain given in this list. (in: query)
    enable_ssl (bool): True if LDAP should be used over SSL. (in: query)
    insecure_ssl (bool): Allow connections to the LDAP server over LDAPS without validating the TLS certificate. Even though
the connection to the server might be performed over LDAPS, setting this property eliminates
the protection against a man-in-the-middle attach for connections to this server. Instead,
consider configuring DCT with Certificate Authority certificates. (in: query)
    unsafe_ssl_hostname_check (bool): Ignore validation of the name associated to the TLS certificate when connecting to the LDAP server over LDAPS.
Setting this value must only be done if the TLS certificate of the server does not match the hostname,
and the TLS configuration of the server cannot be fixed. Setting this property reduces the protection
against a man-in-the-middle attack for connections to this server.
This is ignored if insecure_ssl is set. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/ldap-config"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"enabled": enabled, "auto_create_users": auto_create_users, "hostname": hostname, "port": port, "domains": domains, "enable_ssl": enable_ssl, "insecure_ssl": insecure_ssl, "unsafe_ssl_hostname_check": unsafe_ssl_hostname_check}

    try:
        response = requests.put(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def validate_ldap_config(username: Optional[str] = None, password: Optional[str] = None) -> dict:
    """
    POST /management/ldap-config/validate

    Args:
    username (str): Username of the account to validate the ldap optional attributes. (in: query)
    password (str): Password of the account to validate the ldap optional attributes. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/ldap-config/validate"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"username": username, "password": password}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_saml_config(args: Optional[dict] = None) -> dict:
    """
    GET /management/saml-config

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/saml-config"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_saml_config(enabled: Optional[bool] = None, auto_create_users: Optional[bool] = None, metadata: Optional[str] = None, entity_id: Optional[str] = None, response_skew: Optional[int] = None, group_attr: Optional[str] = None, first_name_attr: Optional[str] = None, last_name_attr: Optional[str] = None) -> dict:
    """
    PUT /management/saml-config

    Args:
    enabled (bool): When set, SAML settings are enabled. False by default. (in: query)
    auto_create_users (bool): When set, the system will automatically create new Accounts for those who have logged in using SAML. This must be true if SAML user is not already registered in system. True by default. (in: query)
    metadata (str): IdP metadata for this service provider. This is a required property for successful SAML authentication. (in: query)
    entity_id (str): Unique identifier of this instance as a SAML/SSO service provider. (in: query)
    response_skew (int): Maximum time difference allowed between a SAML response and the DCT's current time, in seconds. If not set, it defaults to 120 seconds. (in: query)
    group_attr (str): Group mapped attribute on SAML to create account tags in DCT. (in: query)
    first_name_attr (str): First name attribute mapped on SAML used for mapping on DCT account. (in: query)
    last_name_attr (str): Last name attribute mapped on SAML used for mapping on DCT account. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/saml-config"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"enabled": enabled, "auto_create_users": auto_create_users, "metadata": metadata, "entity_id": entity_id, "response_skew": response_skew, "group_attr": group_attr, "first_name_attr": first_name_attr, "last_name_attr": last_name_attr}

    try:
        response = requests.put(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_phonehome_events(limit: Optional[int] = None) -> dict:
    """
    GET /management/phonehome/events

    Args:
    limit (int): The maximum number of items to return. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/phonehome/events"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def trigger_phonehome_bundle_upload(args: Optional[dict] = None) -> dict:
    """
    POST /management/phonehome/upload

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/phonehome/upload"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_proxy_configuration(args: Optional[dict] = None) -> dict:
    """
    GET /management/proxy

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/proxy"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_proxy_configuration(host: str, port: int, enabled: bool, username: Optional[str] = None, password: Optional[str] = None) -> dict:
    """
    PUT /management/proxy

    Args:
    host (str): The host name or IP address of the proxy server. (in: query)
    port (int): The port number of the proxy server. (in: query)
    username (str): The username to use when authenticating with the proxy server. (in: query)
    password (str): The password to use when authenticating with the proxy server. (in: query)
    enabled (bool): When set, these settings are enabled. True by default. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/proxy"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"host": host, "port": port, "username": username, "password": password, "enabled": enabled}

    try:
        response = requests.put(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_product_registration_delphix_connectivity_check(args: Optional[dict] = None) -> dict:
    """
    GET /management/product-registration-delphix-connectivity-check

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/product-registration-delphix-connectivity-check"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_product_registration_status(args: Optional[dict] = None) -> dict:
    """
    GET /management/product-registration-status

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/product-registration-status"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_product_registration_key(args: Optional[dict] = None) -> dict:
    """
    GET /management/product-registration-offline

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/product-registration-offline"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def register_product_offline(data_key: str, authentication_token: str) -> dict:
    """
    POST /management/product-registration-offline

    Args:
    data_key (str): data_key (in: query)
    authentication_token (str): authentication_token (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/product-registration-offline"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"data_key": data_key, "authentication_token": authentication_token}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def unregister_product(args: Optional[dict] = None) -> dict:
    """
    DELETE /management/product-registration-offline

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/product-registration-offline"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def register_product_online(token: str) -> dict:
    """
    POST /management/product-registration-online

    Args:
    token (str): token (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/product-registration-online"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"token": token}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_phonehome_service_url(args: Optional[dict] = None) -> dict:
    """
    PATCH /management/product-registration-online

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"management/product-registration-online"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_audit_logs_summary_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /reporting/audit-logs-summary-report

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/audit-logs-summary-report"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_virtualization_storage_summary_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /reporting/virtualization-storage-summary-report

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/virtualization-storage-summary-report"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_virtualization_storage_summary_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /reporting/virtualization-storage-summary-report/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/virtualization-storage-summary-report/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_api_usage_report(start_date: Optional[str] = None, end_date: Optional[str] = None, api_metric_kind: Optional[str] = None, group_by: Optional[Any] = None, client_name: Optional[Any] = None, user_agent: Optional[Any] = None, dct_version: Optional[Any] = None) -> dict:
    """
    GET /reporting/api-usage-report

    Args:
    start_date (str): Report start date/time. Defaults to first API request. (in: query)
    end_date (str): Report end date/time. Defaults to current time. (in: query)
    api_metric_kind (str): Restrict the list to API usage metric of the given kind (in: query)
    group_by (Any): The field to group results by. (in: query)
    client_name (Any): The Client names to be included in the report. (in: query)
    user_agent (Any): The UserAgent names to be included in the report. (in: query)
    dct_version (Any): The DCT versions to be included in the report. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/api-usage-report"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"start_date": start_date, "end_date": end_date, "api_metric_kind": api_metric_kind, "group_by": group_by, "client_name": client_name, "user_agent": user_agent, "dct_version": dct_version}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_reporting_schedules(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /reporting/schedule

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/schedule"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_reporting_schedule(report_type: str, cron_expression: str, message: str, file_format: str, enabled: bool, recipients: Any, time_zone: Optional[str] = None, sort_column: Optional[str] = None, row_count: Optional[int] = None, make_current_account_owner: Optional[bool] = None) -> dict:
    """
    POST /reporting/schedule

    Args:
    report_type (str): report_type (in: query)
    cron_expression (str): Standard cron expressions are supported e.g. 0 15 10 L * ?  - Schedule at 10:15 AM on the last day of every month, 0 0 2 ? * Mon-Fri - Schedule at 2:00 AM every Monday, Tuesday, Wednesday, Thursday and Friday. For more details kindly refer- "http://www.quartz-scheduler.org/documentation/" (in: query)
    time_zone (str): Timezones are specified according to the Olson tzinfo database - "https://en.wikipedia.org/wiki/List_of_tz_database_time_zones". (in: query)
    message (str): message (in: query)
    file_format (str): file_format (in: query)
    enabled (bool): enabled (in: query)
    recipients (Any): recipients (in: query)
    sort_column (str): sort_column (in: query)
    row_count (int): row_count (in: query)
    make_current_account_owner (bool): Whether the account creating this reporting schedule must be configured as owner of the reporting schedule. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/schedule"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"report_type": report_type, "cron_expression": cron_expression, "time_zone": time_zone, "message": message, "file_format": file_format, "enabled": enabled, "recipients": recipients, "sort_column": sort_column, "row_count": row_count, "make_current_account_owner": make_current_account_owner}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_reporting_schedules(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /reporting/schedule/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/schedule/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_reporting_schedule_by_id(reportId: str) -> dict:
    """
    GET /reporting/schedule/{reportId}

    Args:
    reportId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/schedule/{reportId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_reporting_schedule(reportId: str, report_type: str, cron_expression: str, message: str, file_format: str, enabled: bool, recipients: Any, report_id: Optional[int] = None, time_zone: Optional[str] = None, tags: Optional[Any] = None, sort_column: Optional[str] = None, row_count: Optional[int] = None) -> dict:
    """
    PUT /reporting/schedule/{reportId}

    Args:
    reportId (str): Path parameter
    report_id (int): report_id (in: query)
    report_type (str): report_type (in: query)
    cron_expression (str): Standard cron expressions are supported e.g. 0 15 10 L * ?  - Schedule at 10:15 AM on the last day of every month, 0 0 2 ? * Mon-Fri - Schedule at 2:00 AM every Monday, Tuesday, Wednesday, Thursday and Friday. For more details kindly refer- "http://www.quartz-scheduler.org/documentation/" (in: query)
    time_zone (str): Timezones are specified according to the Olson tzinfo database - "https://en.wikipedia.org/wiki/List_of_tz_database_time_zones". (in: query)
    message (str): message (in: query)
    file_format (str): file_format (in: query)
    enabled (bool): enabled (in: query)
    recipients (Any): recipients (in: query)
    tags (Any): tags (in: query)
    sort_column (str): sort_column (in: query)
    row_count (int): row_count (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/schedule/{reportId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"report_id": report_id, "report_type": report_type, "cron_expression": cron_expression, "time_zone": time_zone, "message": message, "file_format": file_format, "enabled": enabled, "recipients": recipients, "tags": tags, "sort_column": sort_column, "row_count": row_count}

    try:
        response = requests.put(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_reporting_schedule(reportId: str) -> dict:
    """
    DELETE /reporting/schedule/{reportId}

    Args:
    reportId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/schedule/{reportId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_reporting_schedule_tags(reportId: str) -> dict:
    """
    GET /reporting/schedule/{reportId}/tags

    Args:
    reportId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/schedule/{reportId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_reporting_schedule_tags(reportId: str, tags: Any) -> dict:
    """
    POST /reporting/schedule/{reportId}/tags

    Args:
    reportId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/schedule/{reportId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_reporting_schedule_tag(reportId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /reporting/schedule/{reportId}/tags/delete

    Args:
    reportId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/schedule/{reportId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_engine_performance_analytics_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /reporting/engine-performance-analytic-report

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/engine-performance-analytic-report"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_engine_performance_analytics_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /reporting/engine-performance-analytic-report/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/engine-performance-analytic-report/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_engine_performance_analytic_trends(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /reporting/engine-performance-analytic-trends/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/engine-performance-analytic-trends/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_product_info(args: Optional[dict] = None) -> dict:
    """
    GET /reporting/product_info

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/product_info"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_data_connections(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /data-connections

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-connections"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_data_connections(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /data-connections/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-connections/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_data_connection_by_id(dataConnectionId: str) -> dict:
    """
    GET /data-connections/{dataConnectionId}

    Args:
    dataConnectionId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-connections/{dataConnectionId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_data_connection(dataConnectionId: str, name: Optional[str] = None) -> dict:
    """
    PATCH /data-connections/{dataConnectionId}

    Args:
    dataConnectionId (str): Path parameter
    name (str): The data connection name (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-connections/{dataConnectionId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_data_connection_tags(dataConnectionId: str) -> dict:
    """
    GET /data-connections/{dataConnectionId}/tags

    Args:
    dataConnectionId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-connections/{dataConnectionId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_data_connection_tags(dataConnectionId: str, tags: Any) -> dict:
    """
    POST /data-connections/{dataConnectionId}/tags

    Args:
    dataConnectionId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-connections/{dataConnectionId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_data_connection_tags(dataConnectionId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /data-connections/{dataConnectionId}/tags/delete

    Args:
    dataConnectionId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-connections/{dataConnectionId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_sub_connections(dataConnectionId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /data-connections/{dataConnectionId}/sub-connections

    Args:
    dataConnectionId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-connections/{dataConnectionId}/sub-connections"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def reassign_sub_connection(dataConnectionId: str, subConnectionId: str, new_data_connection_id: Optional[str] = None, name: Optional[str] = None, tags: Optional[Any] = None, make_current_account_owner: Optional[bool] = None) -> dict:
    """
    POST /data-connections/{dataConnectionId}/sub-connections/{subConnectionId}/reassign

    Args:
    dataConnectionId (str): Path parameter
    subConnectionId (str): Path parameter
    new_data_connection_id (str): The ID of the existing DataConnection to move the SubConnection to. If null, then a new DataConnection will be created. (in: query)
    name (str): The new DataConnection name. Only applicable if new_data_connection_id is null. (in: query)
    tags (Any): The tags to add to the newly created DataConnection. Only applicable if new_data_connection_id is null. (in: query)
    make_current_account_owner (bool): Whether the current Account must be configured as owner of the newly created DataConnection. Only applicable if new_data_connection_id is null. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-connections/{dataConnectionId}/sub-connections/{subConnectionId}/reassign"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"new_data_connection_id": new_data_connection_id, "name": name, "tags": tags, "make_current_account_owner": make_current_account_owner}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_sub_connections(dataConnectionId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /data-connections/{dataConnectionId}/sub-connections/search

    Args:
    dataConnectionId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-connections/{dataConnectionId}/sub-connections/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_roles(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /roles

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"roles"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_role(name: str, permission_objects: Any, description: Optional[str] = None, immutable: Optional[bool] = None, tags: Optional[Any] = None, ui_profiles: Optional[Any] = None) -> dict:
    """
    POST /roles

    Args:
    name (str): The Role name. (in: query)
    description (str): Role description. (in: query)
    permission_objects (Any): The list of permissions granted by this role. (in: query)
    immutable (bool): If set to true, adding or removing permission is not allowed. (in: query)
    tags (Any): tags (in: query)
    ui_profiles (Any): The list of profiles that influence the navigation menus shown in the UI. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"roles"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description, "permission_objects": permission_objects, "immutable": immutable, "tags": tags, "ui_profiles": ui_profiles}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_role_by_id(roleId: str) -> dict:
    """
    GET /roles/{roleId}

    Args:
    roleId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"roles/{roleId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_role(roleId: str) -> dict:
    """
    DELETE /roles/{roleId}

    Args:
    roleId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"roles/{roleId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_role(roleId: str, name: Optional[str] = None, description: Optional[str] = None) -> dict:
    """
    PATCH /roles/{roleId}

    Args:
    roleId (str): Path parameter
    name (str): The role name (in: query)
    description (str): The role description (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"roles/{roleId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_roles(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /roles/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"roles/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def add_role_permissions(roleId: str, permission_objects: Any) -> dict:
    """
    POST /roles/{roleId}/permissions

    Args:
    roleId (str): Path parameter
    permission_objects (Any): Array of permissions with object type and their permission. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"roles/{roleId}/permissions"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"permission_objects": permission_objects}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def remove_role_permissions(roleId: str, permission_objects: Any) -> dict:
    """
    POST /roles/{roleId}/permissions/delete

    Args:
    roleId (str): Path parameter
    permission_objects (Any): Array of permissions with object type and their permission. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"roles/{roleId}/permissions/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"permission_objects": permission_objects}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_role_tags(roleId: str) -> dict:
    """
    GET /roles/{roleId}/tags

    Args:
    roleId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"roles/{roleId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_role_tags(roleId: str, tags: Any) -> dict:
    """
    POST /roles/{roleId}/tags

    Args:
    roleId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"roles/{roleId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_role_tag(roleId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /roles/{roleId}/tags/delete

    Args:
    roleId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"roles/{roleId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def add_role_ui_profiles(roleId: str, ui_profiles: Any) -> dict:
    """
    POST /roles/{roleId}/ui-profiles

    Args:
    roleId (str): Path parameter
    ui_profiles (Any): List of UI profiles (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"roles/{roleId}/ui-profiles"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"ui_profiles": ui_profiles}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_role_ui_profiles(roleId: str, ui_profiles: Any) -> dict:
    """
    POST /roles/{roleId}/ui-profiles/delete

    Args:
    roleId (str): Path parameter
    ui_profiles (Any): List of UI profiles (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"roles/{roleId}/ui-profiles/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"ui_profiles": ui_profiles}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_object_permissions(objectType: str, objectId: str) -> dict:
    """
    GET /auth/permissions/objects/{objectType}/{objectId}

    Args:
    objectType (str): Path parameter
    objectId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"auth/permissions/objects/{objectType}/{objectId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_all_object_permissions(args: Optional[dict] = None) -> dict:
    """
    GET /auth/object-permissions

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"auth/object-permissions"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_access_groups(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /access-groups

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_access_group(name: str, id: Optional[str] = None, single_account: Optional[bool] = None, account_ids: Optional[Any] = None, tagged_account_ids: Optional[Any] = None, account_tags: Optional[Any] = None, scopes: Optional[Any] = None) -> dict:
    """
    POST /access-groups

    Args:
    id (str): The Access group ID. (in: query)
    name (str): The Access group name (in: query)
    single_account (bool): Indicates that this Access group defines the permissions of a single account, and thus account and account tags cannot be modified. Instead create a new Access group to manage permissions of multiple accounts. (in: query)
    account_ids (Any): List of accounts ids included individually (as opposed to added by tags) in the Access group. (in: query)
    tagged_account_ids (Any): List of accounts ids included by tags in the Access group. (in: query)
    account_tags (Any): List of account tags. Accounts matching any of these tags will be automatically added to the Access group. (in: query)
    scopes (Any): The Access group scopes. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"id": id, "name": name, "single_account": single_account, "account_ids": account_ids, "tagged_account_ids": tagged_account_ids, "account_tags": account_tags, "scopes": scopes}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_access_groups(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /access-groups/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_access_group_by_id(accessGroupId: str) -> dict:
    """
    GET /access-groups/{accessGroupId}

    Args:
    accessGroupId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_access_group(accessGroupId: str) -> dict:
    """
    DELETE /access-groups/{accessGroupId}

    Args:
    accessGroupId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_access_group(accessGroupId: str, name: Optional[str] = None) -> dict:
    """
    PATCH /access-groups/{accessGroupId}

    Args:
    accessGroupId (str): Path parameter
    name (str): The Access group name (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def add_access_group_account_tags(accessGroupId: str, tags: Any) -> dict:
    """
    POST /access-groups/{accessGroupId}/tags

    Args:
    accessGroupId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def remove_access_group_account_tags(accessGroupId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /access-groups/{accessGroupId}/tags/delete

    Args:
    accessGroupId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def add_access_group_account_ids(accessGroupId: str, account_ids: Any) -> dict:
    """
    POST /access-groups/{accessGroupId}/account-ids

    Args:
    accessGroupId (str): Path parameter
    account_ids (Any): account_ids (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}/account-ids"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"account_ids": account_ids}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def remove_access_group_account_id(accessGroupId: str, accountId: str) -> dict:
    """
    DELETE /access-groups/{accessGroupId}/account-ids/{accountId}

    Args:
    accessGroupId (str): Path parameter
    accountId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}/account-ids/{accountId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def add_access_group_scopes(accessGroupId: str, scopes: Any) -> dict:
    """
    POST /access-groups/{accessGroupId}/scopes

    Args:
    accessGroupId (str): Path parameter
    scopes (Any): scopes (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}/scopes"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"scopes": scopes}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_access_group_scope(accessGroupId: str, scopeId: str) -> dict:
    """
    GET /access-groups/{accessGroupId}/scopes/{scopeId}

    Args:
    accessGroupId (str): Path parameter
    scopeId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}/scopes/{scopeId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def remove_access_group_scope(accessGroupId: str, scopeId: str) -> dict:
    """
    DELETE /access-groups/{accessGroupId}/scopes/{scopeId}

    Args:
    accessGroupId (str): Path parameter
    scopeId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}/scopes/{scopeId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_access_group_scope(accessGroupId: str, scopeId: str, name: Optional[str] = None, scope_type: Optional[str] = None) -> dict:
    """
    PATCH /access-groups/{accessGroupId}/scopes/{scopeId}

    Args:
    accessGroupId (str): Path parameter
    scopeId (str): Path parameter
    name (str): The Access group scope name. (in: query)
    scope_type (str): Specifies the type of the scope. Scope of type SIMPLE would grant access to all DCT objects. Scope of type SCOPED would grant access to all objects based on objects and object-tags and permissions defined in linked role. Scope of type ADVANCED would grant access to DCT objects based on objects and object-tags and the individual permissions. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}/scopes/{scopeId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "scope_type": scope_type}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def add_tags_to_scope(accessGroupId: str, scopeId: str, tags: Any) -> dict:
    """
    POST /access-groups/{accessGroupId}/scopes/{scopeId}/object-tags

    Args:
    accessGroupId (str): Path parameter
    scopeId (str): Path parameter
    tags (Any): Array of tags with key value pairs along with optional object_type and permissions (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}/scopes/{scopeId}/object-tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_access_group_scope_object_tags(accessGroupId: str, scopeId: str, tags: Optional[Any] = None) -> dict:
    """
    POST /access-groups/{accessGroupId}/scopes/{scopeId}/object-tags/delete

    Args:
    accessGroupId (str): Path parameter
    scopeId (str): Path parameter
    tags (Any): List of scope tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}/scopes/{scopeId}/object-tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def add_objects_to_access_group_scope(accessGroupId: str, scopeId: str, objects: Any) -> dict:
    """
    POST /access-groups/{accessGroupId}/scopes/{scopeId}/objects

    Args:
    accessGroupId (str): Path parameter
    scopeId (str): Path parameter
    objects (Any): An array of scoped objects (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}/scopes/{scopeId}/objects"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"objects": objects}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_access_group_scope_objects(accessGroupId: str, scopeId: str, objects: Any) -> dict:
    """
    POST /access-groups/{accessGroupId}/scopes/{scopeId}/objects/delete

    Args:
    accessGroupId (str): Path parameter
    scopeId (str): Path parameter
    objects (Any): List of scoped objects to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}/scopes/{scopeId}/objects/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"objects": objects}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def add_always_allowed_permissions(accessGroupId: str, scopeId: str, always_allowed_permissions: Any) -> dict:
    """
    POST /access-groups/{accessGroupId}/scopes/{scopeId}/always_allowed_permissions

    Args:
    accessGroupId (str): Path parameter
    scopeId (str): Path parameter
    always_allowed_permissions (Any): An array of always allowed permissions (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}/scopes/{scopeId}/always_allowed_permissions"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"always_allowed_permissions": always_allowed_permissions}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def remove_always_allowed_permissions(accessGroupId: str, scopeId: str, always_allowed_permissions: Any) -> dict:
    """
    POST /access-groups/{accessGroupId}/scopes/{scopeId}/always_allowed_permissions/delete

    Args:
    accessGroupId (str): Path parameter
    scopeId (str): Path parameter
    always_allowed_permissions (Any): An array of always allowed permissions (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"access-groups/{accessGroupId}/scopes/{scopeId}/always_allowed_permissions/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"always_allowed_permissions": always_allowed_permissions}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_enabled_features_flag(args: Optional[dict] = None) -> dict:
    """
    GET /enabled-features-flag

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"enabled-features-flag"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def connectors_test(connectorId: str) -> dict:
    """
    POST /connectors/{connectorId}/test

    Args:
    connectorId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"connectors/{connectorId}/test"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hyperscale_instances(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /hyperscale-instances

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-instances"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def register_hyperscale_instance(name: str, hostname: str, api_key: str, data_type: str, insecure_ssl: Optional[bool] = None, unsafe_ssl_hostname_check: Optional[bool] = None, tags: Optional[Any] = None, make_current_account_owner: Optional[bool] = None) -> dict:
    """
    POST /hyperscale-instances

    Args:
    name (str): Name in DCT of the Hyperscale instance. (in: query)
    hostname (str): Hostname of the Hyperscale instance. If the Hyperscale instance is running on a custom port (not 443), the port can be specified using the "hostname:port" format, for instance "hyperscale-1.mycompany.co:1765" (in: query)
    api_key (str): API key to connect to the Hyperscale instance. (in: query)
    data_type (str): The data type designation for the hyperscale deployment. (in: query)
    insecure_ssl (bool): Allow connections to the hyperscale instance over HTTPs without validating the TLS certificate. Even though
the connection to the hyperscale instance might be performed over HTTPs, setting this property eliminates
the protection against a man-in-the-middle attach for connections to this engine. Instead,
consider configuring DCT with Certificate Authority certificates. (in: query)
    unsafe_ssl_hostname_check (bool): Ignore validation of the name associated to the TLS certificate when connecting to the hyperscale instance over HTTPs.
Setting this value must only be done if the TLS certificate of the hyperscale instance does not match the hostname,
and the TLS configuration of the hyperscale instance cannot be fixed. Setting this property reduces the protection
against a man-in-the-middle attack for connections to this engine.
This is ignored if insecure_ssl is set. (in: query)
    tags (Any): The tags to be created for this engine. (in: query)
    make_current_account_owner (bool): Whether the account creating this Hyperscale instance must be configured as owner of it. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-instances"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "hostname": hostname, "api_key": api_key, "data_type": data_type, "insecure_ssl": insecure_ssl, "unsafe_ssl_hostname_check": unsafe_ssl_hostname_check, "tags": tags, "make_current_account_owner": make_current_account_owner}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_hyperscale_instances(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /hyperscale-instances/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-instances/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hyperscale_instance_by_id(hyperscaleInstanceId: str) -> dict:
    """
    GET /hyperscale-instances/{hyperscaleInstanceId}

    Args:
    hyperscaleInstanceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-instances/{hyperscaleInstanceId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def unregister_hyperscale_instance(hyperscaleInstanceId: str) -> dict:
    """
    DELETE /hyperscale-instances/{hyperscaleInstanceId}

    Args:
    hyperscaleInstanceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-instances/{hyperscaleInstanceId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_hyperscale_instance(hyperscaleInstanceId: str, name: Optional[str] = None, hostname: Optional[str] = None, api_key: Optional[str] = None, data_type: Optional[str] = None, insecure_ssl: Optional[bool] = None, unsafe_ssl_hostname_check: Optional[bool] = None) -> dict:
    """
    PATCH /hyperscale-instances/{hyperscaleInstanceId}

    Args:
    hyperscaleInstanceId (str): Path parameter
    name (str): Name in DCT of the Hyperscale instance. (in: query)
    hostname (str): Hostname of the Hyperscale instance. If the Hyperscale instance is running on a custom port (not 443), the port can be specified using the "hostname:port" format, for instance "hyperscale-1.mycompany.co:1765" (in: query)
    api_key (str): API key to connect to the Hyperscale instance. (in: query)
    data_type (str): The data type designation for the hyperscale deployment. (in: query)
    insecure_ssl (bool): Allow connections to the hyperscale instance over HTTPs without validating the TLS certificate. Even though
the connection to the hyperscale instance might be performed over HTTPs, setting this property eliminates
the protection against a man-in-the-middle attach for connections to this engine. Instead,
consider configuring DCT with Certificate Authority certificates. (in: query)
    unsafe_ssl_hostname_check (bool): Ignore validation of the name associated to the TLS certificate when connecting to the hyperscale instance over HTTPs.
Setting this value must only be done if the TLS certificate of the hyperscale instance does not match the hostname,
and the TLS configuration of the hyperscale instance cannot be fixed. Setting this property reduces the protection
against a man-in-the-middle attack for connections to this engine.
This is ignored if insecure_ssl is set. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-instances/{hyperscaleInstanceId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "hostname": hostname, "api_key": api_key, "data_type": data_type, "insecure_ssl": insecure_ssl, "unsafe_ssl_hostname_check": unsafe_ssl_hostname_check}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hyperscale_instance_tags(hyperscaleInstanceId: str) -> dict:
    """
    GET /hyperscale-instances/{hyperscaleInstanceId}/tags

    Args:
    hyperscaleInstanceId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-instances/{hyperscaleInstanceId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_hyperscale_instance_tags(hyperscaleInstanceId: str, tags: Any) -> dict:
    """
    POST /hyperscale-instances/{hyperscaleInstanceId}/tags

    Args:
    hyperscaleInstanceId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-instances/{hyperscaleInstanceId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_hyperscale_instance_tags(hyperscaleInstanceId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /hyperscale-instances/{hyperscaleInstanceId}/tags/delete

    Args:
    hyperscaleInstanceId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-instances/{hyperscaleInstanceId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def sync_engines_hyperscale_instance(hyperscaleInstanceId: str, source_engine_id: str, target_engine_ids: Any) -> dict:
    """
    POST /hyperscale-instances/{hyperscaleInstanceId}/sync-engines

    Args:
    hyperscaleInstanceId (str): Path parameter
    source_engine_id (str): The ID of the engine to copy the data from. (in: query)
    target_engine_ids (Any): The IDs of the target engines to copy the data into. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-instances/{hyperscaleInstanceId}/sync-engines"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"source_engine_id": source_engine_id, "target_engine_ids": target_engine_ids}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def add_engine_to_hyperscale_instance(hyperscaleInstanceId: str, engine_id: Optional[str] = None) -> dict:
    """
    POST /hyperscale-instances/{hyperscaleInstanceId}/add-engine

    Args:
    hyperscaleInstanceId (str): Path parameter
    engine_id (str): engine_id (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-instances/{hyperscaleInstanceId}/add-engine"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"engine_id": engine_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def remove_engine_from_hyperscale_instance(hyperscaleInstanceId: str, engine_id: Optional[str] = None) -> dict:
    """
    POST /hyperscale-instances/{hyperscaleInstanceId}/remove-engine

    Args:
    hyperscaleInstanceId (str): Path parameter
    engine_id (str): engine_id (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-instances/{hyperscaleInstanceId}/remove-engine"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"engine_id": engine_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hyperscale_mount_points(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /hyperscale-mount-points

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-mount-points"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_hyperscale_mount_point(hyperscale_instance_id: str, id: Optional[str] = None, name: Optional[str] = None, hostname: Optional[str] = None, mount_path: Optional[str] = None, mount_type: Optional[str] = None, options: Optional[str] = None, staging_storage_type: Optional[str] = None, auth_mechanism: Optional[str] = None, aws_bucket_name: Optional[str] = None, aws_bucket_region: Optional[str] = None, aws_bucket_prefix: Optional[str] = None, aws_bucket_delimiter: Optional[str] = None, blob_auth_type: Optional[str] = None, blob_account_name: Optional[str] = None, blob_container_name: Optional[str] = None, blob_container_prefix: Optional[str] = None, blob_container_delimiter: Optional[str] = None) -> dict:
    """
    POST /hyperscale-mount-points

    Args:
    id (str): The ID of the Hyperscale Mount Point. (in: query)
    hyperscale_instance_id (str): The ID of the Hyperscale instance of this Mount Point. (in: query)
    name (str): Name of the mount, unique for a hyperscale instance. This name will be used as a directory name by the Hyperscale instance. (in: query)
    hostname (str): The host name of the server. (in: query)
    mount_path (str): The path to the directory on the filesystem to mount. (in: query)
    mount_type (str): The type of mount filesystem. Enum having values- CIFS, NFS3, NFS4. (in: query)
    options (str): The options for mount. The endpoint will return all default options and user specified options. (in: query)
    staging_storage_type (str): The type of staging storage. (in: query)
    auth_mechanism (str): The authentication mechanism for AWS_S3 storage. (in: query)
    aws_bucket_name (str): The aws bucket name for AWS_S3 storage. (in: query)
    aws_bucket_region (str): The aws bucket region for AWS_S3 storage. (in: query)
    aws_bucket_prefix (str): The aws bucket prefix for AWS_S3 storage. (in: query)
    aws_bucket_delimiter (str): The aws bucket delimiter for AWS_S3 storage. (in: query)
    blob_auth_type (str): The authentication type for Azure blob storage. (in: query)
    blob_account_name (str): The storage account name for Azure blob storage. (in: query)
    blob_container_name (str): The blob container name for Azure blob storage. (in: query)
    blob_container_prefix (str): The blob container prefix for Azure blob storage. (in: query)
    blob_container_delimiter (str): The blob container delimiter for Azure blob storage. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-mount-points"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"id": id, "hyperscale_instance_id": hyperscale_instance_id, "name": name, "hostname": hostname, "mount_path": mount_path, "mount_type": mount_type, "options": options, "staging_storage_type": staging_storage_type, "auth_mechanism": auth_mechanism, "aws_bucket_name": aws_bucket_name, "aws_bucket_region": aws_bucket_region, "aws_bucket_prefix": aws_bucket_prefix, "aws_bucket_delimiter": aws_bucket_delimiter, "blob_auth_type": blob_auth_type, "blob_account_name": blob_account_name, "blob_container_name": blob_container_name, "blob_container_prefix": blob_container_prefix, "blob_container_delimiter": blob_container_delimiter}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hyperscale_mount_point_by_id(hyperscaleMountPointId: str) -> dict:
    """
    GET /hyperscale-mount-points/{hyperscaleMountPointId}

    Args:
    hyperscaleMountPointId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-mount-points/{hyperscaleMountPointId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_hyperscale_mount_point(hyperscaleMountPointId: str) -> dict:
    """
    DELETE /hyperscale-mount-points/{hyperscaleMountPointId}

    Args:
    hyperscaleMountPointId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-mount-points/{hyperscaleMountPointId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_hyperscale_mount_point_by_id(hyperscaleMountPointId: str, name: Optional[str] = None, hostname: Optional[str] = None, mount_path: Optional[str] = None, mount_type: Optional[str] = None, options: Optional[str] = None) -> dict:
    """
    PATCH /hyperscale-mount-points/{hyperscaleMountPointId}

    Args:
    hyperscaleMountPointId (str): Path parameter
    name (str): Name of the mount, unique for a hyperscale instance. (in: query)
    hostname (str): The host name of the server. (in: query)
    mount_path (str): The path to the directory on the filesystem to mount. (in: query)
    mount_type (str): The type of filesystem. (in: query)
    options (str): The mount options. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-mount-points/{hyperscaleMountPointId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "hostname": hostname, "mount_path": mount_path, "mount_type": mount_type, "options": options}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_hyperscale_mount_points(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /hyperscale-mount-points/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-mount-points/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hyperscale_connectors(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /hyperscale-connectors

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-connectors"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_hyperscale_connector(hyperscale_instance_id: Optional[str] = None, data_type: Optional[str] = None, name: Optional[str] = None, source_username: Optional[str] = None, source_password: Optional[str] = None, source_jdbc_url: Optional[str] = None, source_mongo_url: Optional[str] = None, source_filesystem_path: Optional[str] = None, source_connection_properties: Optional[Any] = None, target_username: Optional[str] = None, target_password: Optional[str] = None, target_jdbc_url: Optional[str] = None, target_mongo_url: Optional[str] = None, target_filesystem_path: Optional[str] = None, target_connection_properties: Optional[Any] = None, tags: Optional[Any] = None, make_current_account_owner: Optional[bool] = None) -> dict:
    """
    POST /hyperscale-connectors

    Args:
    hyperscale_instance_id (str): The ID of the Hyperscale instance of this Connector. (in: query)
    data_type (str): The data type designation for the hyperscale deployment. (in: query)
    name (str): name (in: query)
    source_username (str): The username this Connector will use to connect to the source database. (in: query)
    source_password (str): The password this Connector will use to connect to the source database. (in: query)
    source_jdbc_url (str): The JDBC URL used to connect to the source database. (in: query)
    source_mongo_url (str): The MongoDB URL used to connect to the source database. (in: query)
    source_filesystem_path (str): The path on the filesystem where source files must be read (Delimited files Only). (in: query)
    source_connection_properties (Any): source_connection_properties (in: query)
    target_username (str): The username this Connector will use to connect to the target database. (in: query)
    target_password (str): The username this Connector will use to connect to the target database. (in: query)
    target_jdbc_url (str): The JDBC URL used to connect to the target database. (in: query)
    target_mongo_url (str): The MongoDB URL used to connect to the target database. (in: query)
    target_filesystem_path (str): The path on the filesystem where target files must be written (Delimited files Only). (in: query)
    target_connection_properties (Any): target_connection_properties (in: query)
    tags (Any): tags (in: query)
    make_current_account_owner (bool): Whether the account creating this Hyperscale Connector must be configured as owner of it. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-connectors"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"hyperscale_instance_id": hyperscale_instance_id, "data_type": data_type, "name": name, "source_username": source_username, "source_password": source_password, "source_jdbc_url": source_jdbc_url, "source_mongo_url": source_mongo_url, "source_filesystem_path": source_filesystem_path, "source_connection_properties": source_connection_properties, "target_username": target_username, "target_password": target_password, "target_jdbc_url": target_jdbc_url, "target_mongo_url": target_mongo_url, "target_filesystem_path": target_filesystem_path, "target_connection_properties": target_connection_properties, "tags": tags, "make_current_account_owner": make_current_account_owner}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hyperscale_connector_by_id(hyperscaleConnectorId: str) -> dict:
    """
    GET /hyperscale-connectors/{hyperscaleConnectorId}

    Args:
    hyperscaleConnectorId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-connectors/{hyperscaleConnectorId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_hyperscale_connector(hyperscaleConnectorId: str) -> dict:
    """
    DELETE /hyperscale-connectors/{hyperscaleConnectorId}

    Args:
    hyperscaleConnectorId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-connectors/{hyperscaleConnectorId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_hyperscale_connector_by_id(hyperscaleConnectorId: str, name: Optional[str] = None, source_username: Optional[str] = None, source_password: Optional[str] = None, source_jdbc_url: Optional[str] = None, source_mongo_url: Optional[str] = None, source_filesystem_path: Optional[str] = None, source_connection_properties: Optional[Any] = None, target_username: Optional[str] = None, target_password: Optional[str] = None, target_jdbc_url: Optional[str] = None, target_mongo_url: Optional[str] = None, target_filesystem_path: Optional[str] = None, target_connection_properties: Optional[Any] = None) -> dict:
    """
    PATCH /hyperscale-connectors/{hyperscaleConnectorId}

    Args:
    hyperscaleConnectorId (str): Path parameter
    name (str): name (in: query)
    source_username (str): The username this Connector will use to connect to the source database. (in: query)
    source_password (str): The password this Connector will use to connect to the source database. (in: query)
    source_jdbc_url (str): The JDBC URL used to connect to the source database. (in: query)
    source_mongo_url (str): The MongoDB URL used to connect to the source database. (in: query)
    source_filesystem_path (str): The path on the filesystem where source files must be read (Delimited files Only). (in: query)
    source_connection_properties (Any): source_connection_properties (in: query)
    target_username (str): The username this Connector will use to connect to the target database. (in: query)
    target_password (str): The username this Connector will use to connect to the target database. (in: query)
    target_jdbc_url (str): The JDBC URL used to connect to the target database. (in: query)
    target_mongo_url (str): The MongoDB URL used to connect to the target database. (in: query)
    target_filesystem_path (str): The path on the filesystem where target files must be written (Delimited files Only). (in: query)
    target_connection_properties (Any): target_connection_properties (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-connectors/{hyperscaleConnectorId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "source_username": source_username, "source_password": source_password, "source_jdbc_url": source_jdbc_url, "source_mongo_url": source_mongo_url, "source_filesystem_path": source_filesystem_path, "source_connection_properties": source_connection_properties, "target_username": target_username, "target_password": target_password, "target_jdbc_url": target_jdbc_url, "target_mongo_url": target_mongo_url, "target_filesystem_path": target_filesystem_path, "target_connection_properties": target_connection_properties}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hyperscale_connector_tags(hyperscaleConnectorId: str) -> dict:
    """
    GET /hyperscale-connectors/{hyperscaleConnectorId}/tags

    Args:
    hyperscaleConnectorId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-connectors/{hyperscaleConnectorId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_hyperscale_connector_tags(hyperscaleConnectorId: str, tags: Any) -> dict:
    """
    POST /hyperscale-connectors/{hyperscaleConnectorId}/tags

    Args:
    hyperscaleConnectorId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-connectors/{hyperscaleConnectorId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_hyperscale_connector_tags(hyperscaleConnectorId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /hyperscale-connectors/{hyperscaleConnectorId}/tags/delete

    Args:
    hyperscaleConnectorId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-connectors/{hyperscaleConnectorId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_hyperscale_connectors(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /hyperscale-connectors/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-connectors/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hyperscale_datasets(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /hyperscale-datasets

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-datasets"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hyperscale_dataset_by_id(hyperscaleDatasetId: str) -> dict:
    """
    GET /hyperscale-datasets/{hyperscaleDatasetId}

    Args:
    hyperscaleDatasetId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-datasets/{hyperscaleDatasetId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_hyperscale_dataset_by_id(hyperscaleDatasetId: str, mount_point_id: Optional[str] = None, connector_id: Optional[str] = None) -> dict:
    """
    PATCH /hyperscale-datasets/{hyperscaleDatasetId}

    Args:
    hyperscaleDatasetId (str): Path parameter
    mount_point_id (str): The Id of the Hyperscale Mount Point used for this Dataset. (in: query)
    connector_id (str): Id the Hyperscale Connector used to read sensitive data and write masked data. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-datasets/{hyperscaleDatasetId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"mount_point_id": mount_point_id, "connector_id": connector_id}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hyperscale_dataset_tags(hyperscaleDatasetId: str) -> dict:
    """
    GET /hyperscale-datasets/{hyperscaleDatasetId}/tags

    Args:
    hyperscaleDatasetId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-datasets/{hyperscaleDatasetId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_hyperscale_dataset_tags(hyperscaleDatasetId: str, tags: Any) -> dict:
    """
    POST /hyperscale-datasets/{hyperscaleDatasetId}/tags

    Args:
    hyperscaleDatasetId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-datasets/{hyperscaleDatasetId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_hyperscale_dataset_tags(hyperscaleDatasetId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /hyperscale-datasets/{hyperscaleDatasetId}/tags/delete

    Args:
    hyperscaleDatasetId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-datasets/{hyperscaleDatasetId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hyperscale_dataset_table_or_file_by_id(hyperscaleDatasetId: str, hyperscaleDatasetTableOrFileId: str) -> dict:
    """
    GET /hyperscale-datasets/{hyperscaleDatasetId}/tables-or-files/{hyperscaleDatasetTableOrFileId}

    Args:
    hyperscaleDatasetId (str): Path parameter
    hyperscaleDatasetTableOrFileId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-datasets/{hyperscaleDatasetId}/tables-or-files/{hyperscaleDatasetTableOrFileId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_hyperscale_dataset_table_or_file_by_id(hyperscaleDatasetId: str, hyperscaleDatasetTableOrFileId: str, filter_key: Optional[str] = None, column_array_rows: Optional[int] = None, unload_split: Optional[int] = None, stream_size: Optional[int] = None, end_of_record: Optional[str] = None, delimiter: Optional[str] = None, enclosure: Optional[str] = None, enclosure_escape_character: Optional[str] = None, escape_enclosure_escape_character: Optional[bool] = None, has_headers: Optional[bool] = None, unique_source_files_identifier: Optional[str] = None, source_files: Optional[Any] = None, perform_join: Optional[bool] = None) -> dict:
    """
    PATCH /hyperscale-datasets/{hyperscaleDatasetId}/tables-or-files/{hyperscaleDatasetTableOrFileId}

    Args:
    hyperscaleDatasetId (str): Path parameter
    hyperscaleDatasetTableOrFileId (str): Path parameter
    filter_key (str): The unique database column field to filter the source data. Set this property to an empty string to clear the value. (in: query)
    column_array_rows (int): The number of column array rows to be used by the sqlldr oracle utility which determines the number of rows loaded before the stream buffer is built. (in: query)
    unload_split (int): The number of unloaded files to be generated from the source database. (in: query)
    stream_size (int): Long The stream size to be used by the sqlldr oracle utility which specifies the size (in bytes) of the data stream sent from the client to the server. (in: query)
    end_of_record (str): The end of line character. Support values are \n, \r  and \r\n (Delimited files only). (in: query)
    delimiter (str): The single character length delimiter used in source files (Delimited files only). (in: query)
    enclosure (str): The single character length quote character used in the source files (Delimited files only). (in: query)
    enclosure_escape_character (str): The escape character used to escape quote characters (Delimited files only). (in: query)
    escape_enclosure_escape_character (bool): Whether to escape the enclosure escape character (Delimited files only). (in: query)
    has_headers (bool): Whether source files have header column names or not (Delimited files only). If set to true, format files with the same column names are created and the same can be used for the masking inventory. If set to false, the column names of pattern f0, f1, f2, and so on are used to create the format files for delimited file masking. (in: query)
    unique_source_files_identifier (str): This is the source key that maps the load-service and masking-service data sets with the unload-service data set (Delimited files only). Please ensure that this value is different for each HyperscaleDatasetTableOrFile. (in: query)
    source_files (Any): List of all source files that need to be masked (Delimited files only). All files should have the same delimiter character and other helper characters. All files should have the same number of columns and same column names if it has a header line. (in: query)
    perform_join (bool): Whether the split files must be joined (Delimited files only). (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-datasets/{hyperscaleDatasetId}/tables-or-files/{hyperscaleDatasetTableOrFileId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"filter_key": filter_key, "column_array_rows": column_array_rows, "unload_split": unload_split, "stream_size": stream_size, "end_of_record": end_of_record, "delimiter": delimiter, "enclosure": enclosure, "enclosure_escape_character": enclosure_escape_character, "escape_enclosure_escape_character": escape_enclosure_escape_character, "has_headers": has_headers, "unique_source_files_identifier": unique_source_files_identifier, "source_files": source_files, "perform_join": perform_join}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_hyperscale_dataset_tables_or_files(hyperscaleDatasetId: str) -> dict:
    """
    GET /hyperscale-datasets/{hyperscaleDatasetId}/tables-or-files

    Args:
    hyperscaleDatasetId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-datasets/{hyperscaleDatasetId}/tables-or-files"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_hyperscale_dataset_tables_or_files(hyperscaleDatasetId: str, filter_expression: Optional[str] = None) -> dict:
    """
    POST /hyperscale-datasets/{hyperscaleDatasetId}/tables-or-files/search

    Args:
    hyperscaleDatasetId (str): Path parameter
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-datasets/{hyperscaleDatasetId}/tables-or-files/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_hyperscale_datasets(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /hyperscale-datasets/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"hyperscale-datasets/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_masking_execution_metrics_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /reporting/masking-execution-metrics

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/masking-execution-metrics"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_masking_execution_metrics_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /reporting/masking-execution-metrics/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/masking-execution-metrics/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_engine_global_object_state_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /reporting/engine-global-object-state-report

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/engine-global-object-state-report"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_engine_global_object_state_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /reporting/engine-global-object-state-report/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/engine-global-object-state-report/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_data_risk_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /reporting/data-risk-report

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/data-risk-report"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_data_risk_report(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /reporting/data-risk-report/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 10000. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"reporting/data-risk-report/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_classifiers(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /classifiers

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"classifiers"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_classifiers(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /classifiers/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"classifiers/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_classifier_by_id(classifierId: str) -> dict:
    """
    GET /classifiers/{classifierId}

    Args:
    classifierId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"classifiers/{classifierId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_classifier_discovery_policies(classifierId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /classifiers/{classifierId}/discovery-policies

    Args:
    classifierId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"classifiers/{classifierId}/discovery-policies"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_classifier_discovery_policies(classifierId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /classifiers/{classifierId}/discovery-policies/search

    Args:
    classifierId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"classifiers/{classifierId}/discovery-policies/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_classifier_tags(classifierId: str) -> dict:
    """
    GET /classifiers/{classifierId}/tags

    Args:
    classifierId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"classifiers/{classifierId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_classifier_tags(classifierId: str, tags: Any) -> dict:
    """
    POST /classifiers/{classifierId}/tags

    Args:
    classifierId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"classifiers/{classifierId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_classifier_tags(classifierId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /classifiers/{classifierId}/tags/delete

    Args:
    classifierId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"classifiers/{classifierId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_connectors(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /connectors

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"connectors"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_connector(name: str, type: str, hostname: Optional[str] = None, port: Optional[int] = None, username: Optional[str] = None, password: Optional[str] = None, database_type: Optional[str] = None, jdbc_url: Optional[str] = None, schema_name: Optional[str] = None, sid: Optional[str] = None, tags: Optional[Any] = None, make_current_account_owner: Optional[bool] = None) -> dict:
    """
    POST /connectors

    Args:
    name (str): The Connector name. (in: query)
    type (str): type (in: query)
    hostname (str): The network hostname or IP address of the database server. (in: query)
    port (int): The TCP port of the server. (in: query)
    username (str): The username this Connector will use to connect to the database. (in: query)
    password (str): The password this Connector will use to connect to the database. (in: query)
    database_type (str): The database variant, such as Oracle, Postgres, MSSQL Server, etc. Currently supports Oracle only. (in: query)
    jdbc_url (str): The jdbc URL for this connector (in: query)
    schema_name (str): The schema name for this connector (in: query)
    sid (str): The SID value for this connector. This field is specific to Oracle database connectors (in: query)
    tags (Any): tags (in: query)
    make_current_account_owner (bool): Whether the account creating this connector must be configured as owner of it. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"connectors"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "type": type, "hostname": hostname, "port": port, "username": username, "password": password, "database_type": database_type, "jdbc_url": jdbc_url, "schema_name": schema_name, "sid": sid, "tags": tags, "make_current_account_owner": make_current_account_owner}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_connector_by_id(connectorId: str) -> dict:
    """
    GET /connectors/{connectorId}

    Args:
    connectorId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"connectors/{connectorId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_connector(connectorId: str) -> dict:
    """
    DELETE /connectors/{connectorId}

    Args:
    connectorId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"connectors/{connectorId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_connector_by_id(connectorId: str, name: Optional[str] = None, hostname: Optional[str] = None, port: Optional[int] = None, username: Optional[str] = None, password: Optional[str] = None, jdbc_url: Optional[str] = None, schema_name: Optional[str] = None, sid: Optional[str] = None) -> dict:
    """
    PATCH /connectors/{connectorId}

    Args:
    connectorId (str): Path parameter
    name (str): The Connector name. (in: query)
    hostname (str): The network hostname or IP address of the database server. (in: query)
    port (int): The TCP port of the server. (in: query)
    username (str): The username this Connector will use to connect to the database. (in: query)
    password (str): The password this Connector will use to connect to the database. (in: query)
    jdbc_url (str): The jdbc URL for this connector (in: query)
    schema_name (str): The schema name for this connector (in: query)
    sid (str): The SID value for this connector. This field is specific to Oracle database connectors (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"connectors/{connectorId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "hostname": hostname, "port": port, "username": username, "password": password, "jdbc_url": jdbc_url, "schema_name": schema_name, "sid": sid}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_connector_jobs(connectorId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /connectors/{connectorId}/masking-jobs/search

    Args:
    connectorId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"connectors/{connectorId}/masking-jobs/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_connector_tags(connectorId: str) -> dict:
    """
    GET /connectors/{connectorId}/tags

    Args:
    connectorId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"connectors/{connectorId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_connector_tags(connectorId: str, tags: Any) -> dict:
    """
    POST /connectors/{connectorId}/tags

    Args:
    connectorId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"connectors/{connectorId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_connector_tag(connectorId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /connectors/{connectorId}/tags/delete

    Args:
    connectorId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"connectors/{connectorId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_connectors(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /connectors/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"connectors/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_data_classes(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /data-classes

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-classes"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_data_class(name: Optional[str] = None, default_algorithm_id: Optional[str] = None, default_token_algorithm_id: Optional[str] = None, algorithm_ids: Optional[Any] = None, description: Optional[str] = None, example: Optional[str] = None, tags: Optional[Any] = None, make_current_account_owner: Optional[bool] = None) -> dict:
    """
    POST /data-classes

    Args:
    name (str): The name of this data class. (in: query)
    default_algorithm_id (str): The ID of the default masking algorithm for this data class. (in: query)
    default_token_algorithm_id (str): The ID of the default tokenization algorithm for this data class. (in: query)
    algorithm_ids (Any): The list of algorithm IDs available for this data class. (in: query)
    description (str): A description of this data class. (in: query)
    example (str): An example data value for this data class. (in: query)
    tags (Any): The tags for this data class. (in: query)
    make_current_account_owner (bool): Whether the account creating this data class must be configured as owner of it. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-classes"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "default_algorithm_id": default_algorithm_id, "default_token_algorithm_id": default_token_algorithm_id, "algorithm_ids": algorithm_ids, "description": description, "example": example, "tags": tags, "make_current_account_owner": make_current_account_owner}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_data_classes(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /data-classes/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-classes/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_data_class_by_id(dataClassId: str) -> dict:
    """
    GET /data-classes/{dataClassId}

    Args:
    dataClassId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-classes/{dataClassId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_data_class(dataClassId: str) -> dict:
    """
    DELETE /data-classes/{dataClassId}

    Args:
    dataClassId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-classes/{dataClassId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_data_class(dataClassId: str, name: Optional[str] = None, default_algorithm_id: Optional[str] = None, default_token_algorithm_id: Optional[str] = None, algorithm_ids: Optional[Any] = None, description: Optional[str] = None, example: Optional[str] = None) -> dict:
    """
    PATCH /data-classes/{dataClassId}

    Args:
    dataClassId (str): Path parameter
    name (str): The name of this data class. (in: query)
    default_algorithm_id (str): The ID of the default masking algorithm for this data class. (in: query)
    default_token_algorithm_id (str): The ID of the default tokenization algorithm for this data class. (in: query)
    algorithm_ids (Any): The list of algorithm IDs available for this data class. (in: query)
    description (str): A description of this data class. (in: query)
    example (str): An example data value for this data class. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-classes/{dataClassId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "default_algorithm_id": default_algorithm_id, "default_token_algorithm_id": default_token_algorithm_id, "algorithm_ids": algorithm_ids, "description": description, "example": example}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_data_class_algorithms(dataClassId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /data-classes/{dataClassId}/algorithms

    Args:
    dataClassId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-classes/{dataClassId}/algorithms"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_data_class_algorithms(dataClassId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /data-classes/{dataClassId}/algorithms/search

    Args:
    dataClassId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-classes/{dataClassId}/algorithms/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_data_class_tags(dataClassId: str) -> dict:
    """
    GET /data-classes/{dataClassId}/tags

    Args:
    dataClassId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-classes/{dataClassId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_data_class_tags(dataClassId: str, tags: Any) -> dict:
    """
    POST /data-classes/{dataClassId}/tags

    Args:
    dataClassId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-classes/{dataClassId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_data_class_tags(dataClassId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /data-classes/{dataClassId}/tags/delete

    Args:
    dataClassId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"data-classes/{dataClassId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_discovery_policies(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /discovery-policies

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"discovery-policies"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_discovery_policies(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /discovery-policies/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"discovery-policies/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_discovery_policy_by_id(discoveryPolicyId: str) -> dict:
    """
    GET /discovery-policies/{discoveryPolicyId}

    Args:
    discoveryPolicyId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"discovery-policies/{discoveryPolicyId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_discovery_policy_classifiers(discoveryPolicyId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /discovery-policies/{discoveryPolicyId}/classifiers

    Args:
    discoveryPolicyId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"discovery-policies/{discoveryPolicyId}/classifiers"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_discovery_policy_classifiers(discoveryPolicyId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /discovery-policies/{discoveryPolicyId}/classifiers/search

    Args:
    discoveryPolicyId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"discovery-policies/{discoveryPolicyId}/classifiers/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_discovery_policy_expressions(discoveryPolicyId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /discovery-policies/{discoveryPolicyId}/expressions

    Args:
    discoveryPolicyId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"discovery-policies/{discoveryPolicyId}/expressions"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_discovery_policy_expressions(discoveryPolicyId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /discovery-policies/{discoveryPolicyId}/expressions/search

    Args:
    discoveryPolicyId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"discovery-policies/{discoveryPolicyId}/expressions/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_discovery_policy_tags(discoveryPolicyId: str) -> dict:
    """
    GET /discovery-policies/{discoveryPolicyId}/tags

    Args:
    discoveryPolicyId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"discovery-policies/{discoveryPolicyId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_discovery_policy_tags(discoveryPolicyId: str, tags: Any) -> dict:
    """
    POST /discovery-policies/{discoveryPolicyId}/tags

    Args:
    discoveryPolicyId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"discovery-policies/{discoveryPolicyId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_discovery_policy_tags(discoveryPolicyId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /discovery-policies/{discoveryPolicyId}/tags/delete

    Args:
    discoveryPolicyId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"discovery-policies/{discoveryPolicyId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_executions(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /executions

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"executions"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_executions(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /executions/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"executions/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_execution_by_id(executionId: str) -> dict:
    """
    GET /executions/{executionId}

    Args:
    executionId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"executions/{executionId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def cancel_execution(executionId: str, expected_status: Optional[str] = None) -> dict:
    """
    POST /executions/{executionId}/cancel

    Args:
    executionId (str): Path parameter
    expected_status (str): The expected status of the execution to cancel to prevent cancelling a queued job that has transitioned to a running state since the request was issued (Standard Job only). (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"executions/{executionId}/cancel"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"expected_status": expected_status}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def restart_execution(executionId: str) -> dict:
    """
    POST /executions/{executionId}/restart

    Args:
    executionId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"executions/{executionId}/restart"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def cleanup_execution(executionId: str) -> dict:
    """
    POST /executions/{executionId}/cleanup

    Args:
    executionId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"executions/{executionId}/cleanup"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_execution_events(executionId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /executions/{executionId}/events

    Args:
    executionId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"executions/{executionId}/events"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_execution_events(executionId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /executions/{executionId}/events/search

    Args:
    executionId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"executions/{executionId}/events/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_execution_log(executionId: str) -> dict:
    """
    GET /executions/{executionId}/log

    Args:
    executionId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"executions/{executionId}/log"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_execution_components(executionId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /executions/{executionId}/execution-components

    Args:
    executionId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"executions/{executionId}/execution-components"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_execution_components(executionId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /executions/{executionId}/execution-components/search

    Args:
    executionId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"executions/{executionId}/execution-components/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_execution_component_by_id(executionId: str, executionComponentId: str) -> dict:
    """
    GET /executions/{executionId}/execution-components/{executionComponentId}

    Args:
    executionId (str): Path parameter
    executionComponentId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"executions/{executionId}/execution-components/{executionComponentId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_execution_component_log(executionId: str, executionComponentId: str) -> dict:
    """
    GET /executions/{executionId}/execution-components/{executionComponentId}/log

    Args:
    executionId (str): Path parameter
    executionComponentId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"executions/{executionId}/execution-components/{executionComponentId}/log"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_discovery_results(executionId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /executions/{executionId}/discovery-results

    Args:
    executionId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"executions/{executionId}/discovery-results"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_discovery_results(executionId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /executions/{executionId}/discovery-results/search

    Args:
    executionId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"executions/{executionId}/discovery-results/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_masking_files(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /masking-file-uploads

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-file-uploads"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def upload_masking_file(args: Optional[dict] = None) -> dict:
    """
    POST /masking-file-uploads

    Args:

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-file-uploads"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_masking_file_by_id(maskingFileId: str) -> dict:
    """
    GET /masking-file-uploads/{maskingFileId}

    Args:
    maskingFileId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-file-uploads/{maskingFileId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_masking_file_upload_by_id(maskingFileId: str, description: str) -> dict:
    """
    PATCH /masking-file-uploads/{maskingFileId}

    Args:
    maskingFileId (str): Path parameter
    description (str): A description for this masking file. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-file-uploads/{maskingFileId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"description": description}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_masking_files(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /masking-file-uploads/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-file-uploads/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_masking_file_tags(maskingFileId: str) -> dict:
    """
    GET /masking-file-uploads/{maskingFileId}/tags

    Args:
    maskingFileId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-file-uploads/{maskingFileId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_masking_file_tags(maskingFileId: str, tags: Any) -> dict:
    """
    POST /masking-file-uploads/{maskingFileId}/tags

    Args:
    maskingFileId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-file-uploads/{maskingFileId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_masking_file_tags(maskingFileId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /masking-file-uploads/{maskingFileId}/tags/delete

    Args:
    maskingFileId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-file-uploads/{maskingFileId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_masking_file_consumers(maskingFileId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /masking-file-uploads/{maskingFileId}/consumers

    Args:
    maskingFileId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-file-uploads/{maskingFileId}/consumers"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_masking_file_consumers(maskingFileId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /masking-file-uploads/{maskingFileId}/consumers/search

    Args:
    maskingFileId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-file-uploads/{maskingFileId}/consumers/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_masking_jobs(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /masking-jobs

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_masking_job(name: Optional[str] = None, description: Optional[str] = None, job_type: Optional[str] = None, hyperscale_instance_id: Optional[str] = None, source_masking_job_id: Optional[str] = None, hyperscale_source_connector_username: Optional[str] = None, hyperscale_source_connector_password: Optional[str] = None, hyperscale_target_connector_username: Optional[str] = None, hyperscale_target_connector_password: Optional[str] = None, mount_point_id: Optional[str] = None, unload_split: Optional[int] = None, stream_size: Optional[int] = None, retain_execution_data: Optional[str] = None, max_memory: Optional[int] = None, min_memory: Optional[int] = None, feedback_size: Optional[int] = None, stream_row_limit: Optional[int] = None, num_input_streams: Optional[int] = None, max_concurrent_source_connections: Optional[int] = None, max_concurrent_target_connections: Optional[int] = None, parallelism_degree: Optional[int] = None, tags: Optional[Any] = None, make_current_account_owner: Optional[bool] = None) -> dict:
    """
    POST /masking-jobs

    Args:
    name (str): The name to give the Masking Job. (in: query)
    description (str): The description of the Job (Hyperscale Job only). (in: query)
    job_type (str): The type of Job. (in: query)
    hyperscale_instance_id (str): The ID of the HyperscaleInstance to create this Job on (Hyperscale Job only). (in: query)
    source_masking_job_id (str): The ID of the Masking Job to use as the source (Hyperscale Job only). (in: query)
    hyperscale_source_connector_username (str): The username to set for the Source Connector that will be imported (Hyperscale Job only). (in: query)
    hyperscale_source_connector_password (str): The password to set for the Source Connector that will be imported (Hyperscale Job only). (in: query)
    hyperscale_target_connector_username (str): The username to set for the Target Connector that will be imported (Hyperscale Job only). (in: query)
    hyperscale_target_connector_password (str): The password to set for the Target Connector that will be imported (Hyperscale Job only). (in: query)
    mount_point_id (str): The ID of the MountPoint to use for the resulting dataset (Hyperscale Job only). (in: query)
    unload_split (int): The number of unloaded files to be generated from the source database (Hyperscale Job only). (in: query)
    stream_size (int): The stream size to be used by the sqlldr oracle utility which specifies the size (in bytes) of the data stream sent from the client to the server (Hyperscale Job only). (in: query)
    retain_execution_data (str): Defines whether execution data will be stored after execution is complete (Hyperscale Job only). (in: query)
    max_memory (int): Maximum memory, in MB, to be allocated for each Masking job (Hyperscale Job only). (in: query)
    min_memory (int): Minimum memory, in MB, to be allocated for each Masking job (Hyperscale Job only). (in: query)
    feedback_size (int): The granularity with which the masking engine provides updates on the progress of the masking job. For instance, a feedbackSize of 50000 results in log updates whenever 50000 rows are processed during the masking phase (Hyperscale Job only). (in: query)
    stream_row_limit (int): The stream row limit constrains the total number of rows that may enter the job for each masking stream. Setting this value to 0 allows unlimited rows into each stream, while leaving it blank will select a default limit based on job type (Hyperscale Job only). (in: query)
    num_input_streams (int): Number of input streams to be configured for Masking Job (Hyperscale Job only). (in: query)
    max_concurrent_source_connections (int): Maximum number of parallel connection that the Hyperscale instance can have with the source datasource (Hyperscale Job only). (in: query)
    max_concurrent_target_connections (int): Maximum number of parallel connection that the Hyperscale instance can have with the target datasource (Hyperscale Job only). (in: query)
    parallelism_degree (int): The degree of parallelism (DOP) per Oracle job to recreate the index in the post-load process (Hyperscale Job only). (in: query)
    tags (Any): tags (in: query)
    make_current_account_owner (bool): Whether the account creating this Masking job must be configured as owner of it (Hyperscale Job only). (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description, "job_type": job_type, "hyperscale_instance_id": hyperscale_instance_id, "source_masking_job_id": source_masking_job_id, "hyperscale_source_connector_username": hyperscale_source_connector_username, "hyperscale_source_connector_password": hyperscale_source_connector_password, "hyperscale_target_connector_username": hyperscale_target_connector_username, "hyperscale_target_connector_password": hyperscale_target_connector_password, "mount_point_id": mount_point_id, "unload_split": unload_split, "stream_size": stream_size, "retain_execution_data": retain_execution_data, "max_memory": max_memory, "min_memory": min_memory, "feedback_size": feedback_size, "stream_row_limit": stream_row_limit, "num_input_streams": num_input_streams, "max_concurrent_source_connections": max_concurrent_source_connections, "max_concurrent_target_connections": max_concurrent_target_connections, "parallelism_degree": parallelism_degree, "tags": tags, "make_current_account_owner": make_current_account_owner}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_masking_jobs(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /masking-jobs/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_masking_job_source_engines(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /masking-jobs/source-engines

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs/source-engines"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_masking_job_source_engines(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /masking-jobs/source-engines/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs/source-engines/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_masking_job_by_id(maskingJobId: str) -> dict:
    """
    GET /masking-jobs/{maskingJobId}

    Args:
    maskingJobId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs/{maskingJobId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_masking_job(maskingJobId: str, force: Optional[bool] = None) -> dict:
    """
    DELETE /masking-jobs/{maskingJobId}

    Args:
    maskingJobId (str): Path parameter
    force (bool): If true, ignores any failures to remove a masking job on an engine. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs/{maskingJobId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"force": force}

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_masking_job_by_id(maskingJobId: str, name: Optional[str] = None, connector_username: Optional[str] = None, connector_password: Optional[str] = None, on_the_fly_source_connector_username: Optional[str] = None, on_the_fly_source_connector_password: Optional[str] = None, description: Optional[str] = None, dataset_id: Optional[str] = None, retain_execution_data: Optional[str] = None, max_memory: Optional[int] = None, min_memory: Optional[int] = None, feedback_size: Optional[int] = None, stream_row_limit: Optional[int] = None, num_input_streams: Optional[int] = None, max_concurrent_source_connections: Optional[int] = None, max_concurrent_target_connections: Optional[int] = None, parallelism_degree: Optional[int] = None) -> dict:
    """
    PATCH /masking-jobs/{maskingJobId}

    Args:
    maskingJobId (str): Path parameter
    name (str): The name of the MaskingJob. (in: query)
    connector_username (str): The username of the Connector used by the MaskingJob. (Standard Job only). (in: query)
    connector_password (str): The password of the Connector used by the MaskingJob. (Standard Job only). (in: query)
    on_the_fly_source_connector_username (str): The username of the source Connector used by the on-the-fly MaskingJob. (Standard Job only). (in: query)
    on_the_fly_source_connector_password (str): The password of the source Connector used by the on-the-fly MaskingJob. (Standard Job only). (in: query)
    description (str): Description of the Job (Hyperscale Job only). (in: query)
    dataset_id (str): Dataset of the Hyperscale Job (Hyperscale Job only). (in: query)
    retain_execution_data (str): Defines whether execution data will be stored after execution is complete (Hyperscale Job only). (in: query)
    max_memory (int): Maximum memory to be allocated for each Masking job (Hyperscale Job only). (in: query)
    min_memory (int): Minimum memory to be allocated for each Masking job (Hyperscale Job only). (in: query)
    feedback_size (int): Feedback Size for each Masking job (Hyperscale Job only). (in: query)
    stream_row_limit (int): Stream Row Limit for each Masking job (Hyperscale Job only). (in: query)
    num_input_streams (int): Number of input streams to be configured for Masking Job (Hyperscale Job only). (in: query)
    max_concurrent_source_connections (int): Maximum number of parallel connection that the Hyperscale instance can have with the source datasource (Hyperscale Job only). (in: query)
    max_concurrent_target_connections (int): Maximum number of parallel connection that the Hyperscale instance can have with the target datasource (Hyperscale Job only). (in: query)
    parallelism_degree (int): The degree of parallelism (DOP) per Oracle job to recreate the index in the post-load process (Hyperscale Job only). (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs/{maskingJobId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "connector_username": connector_username, "connector_password": connector_password, "on_the_fly_source_connector_username": on_the_fly_source_connector_username, "on_the_fly_source_connector_password": on_the_fly_source_connector_password, "description": description, "dataset_id": dataset_id, "retain_execution_data": retain_execution_data, "max_memory": max_memory, "min_memory": min_memory, "feedback_size": feedback_size, "stream_row_limit": stream_row_limit, "num_input_streams": num_input_streams, "max_concurrent_source_connections": max_concurrent_source_connections, "max_concurrent_target_connections": max_concurrent_target_connections, "parallelism_degree": parallelism_degree}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def copy_masking_job(maskingJobId: str, target_engine_id: str, source_environment_id: Optional[str] = None, target_environment_id: Optional[str] = None, force_overwrite: Optional[bool] = None) -> dict:
    """
    POST /masking-jobs/{maskingJobId}/copy

    Args:
    maskingJobId (str): Path parameter
    target_engine_id (str): The ID of the engine to copy the job to. (in: query)
    source_environment_id (str): The ID or name of the source environment on the target engine. This only applies to On-The-Fly jobs. (in: query)
    target_environment_id (str): The ID or name of the target environment on the target engine to copy the job into. (in: query)
    force_overwrite (bool): Whether to overwrite objects that already exist on the target engine. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs/{maskingJobId}/copy"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"target_engine_id": target_engine_id, "source_environment_id": source_environment_id, "target_environment_id": target_environment_id, "force_overwrite": force_overwrite}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def migrate_masking_job(maskingJobId: str, target_engine_id: str, source_environment_id: Optional[str] = None, target_environment_id: Optional[str] = None, force_overwrite: Optional[bool] = None) -> dict:
    """
    POST /masking-jobs/{maskingJobId}/migrate

    Args:
    maskingJobId (str): Path parameter
    target_engine_id (str): The ID of the engine to migrate the job to. (in: query)
    source_environment_id (str): The ID or name of the source environment on the target engine. This only applies to On-The-Fly jobs. (in: query)
    target_environment_id (str): The ID or name of the target environment on the target engine to migrate the job into. (in: query)
    force_overwrite (bool): Whether to overwrite objects that already exist on the target engine. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs/{maskingJobId}/migrate"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"target_engine_id": target_engine_id, "source_environment_id": source_environment_id, "target_environment_id": target_environment_id, "force_overwrite": force_overwrite}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_masking_job_connectors(maskingJobId: str) -> dict:
    """
    GET /masking-jobs/{maskingJobId}/connectors

    Args:
    maskingJobId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs/{maskingJobId}/connectors"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def execute_masking_job(maskingJobId: str, engine_id: Optional[str] = None) -> dict:
    """
    POST /masking-jobs/{maskingJobId}/execute

    Args:
    maskingJobId (str): Path parameter
    engine_id (str): The ID of the Engine to execute this MaskingJob on (Standard job only). (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs/{maskingJobId}/execute"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"engine_id": engine_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def re_import_masking_job(maskingJobId: str) -> dict:
    """
    POST /masking-jobs/{maskingJobId}/re-import

    Args:
    maskingJobId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs/{maskingJobId}/re-import"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_masking_job_tag(maskingJobId: str) -> dict:
    """
    GET /masking-jobs/{maskingJobId}/tags

    Args:
    maskingJobId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs/{maskingJobId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_masking_job_tag(maskingJobId: str, tags: Any) -> dict:
    """
    POST /masking-jobs/{maskingJobId}/tags

    Args:
    maskingJobId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs/{maskingJobId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_masking_job_tag(maskingJobId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /masking-jobs/{maskingJobId}/tags/delete

    Args:
    maskingJobId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs/{maskingJobId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def add_engine_to_masking_job(maskingJobId: str, engine_id: Optional[str] = None) -> dict:
    """
    POST /masking-jobs/{maskingJobId}/add-engine

    Args:
    maskingJobId (str): Path parameter
    engine_id (str): engine_id (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs/{maskingJobId}/add-engine"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"engine_id": engine_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def remove_engine_from_masking_job(maskingJobId: str, engine_id: Optional[str] = None) -> dict:
    """
    POST /masking-jobs/{maskingJobId}/remove-engine

    Args:
    maskingJobId (str): Path parameter
    engine_id (str): engine_id (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-jobs/{maskingJobId}/remove-engine"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"engine_id": engine_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_algorithms(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /algorithms

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"algorithms"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_algorithm(name: str, config: Any, framework_id: str, description: Optional[str] = None, data_class_ids: Optional[Any] = None, make_current_account_owner: Optional[bool] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /algorithms

    Args:
    name (str): The name of this Algorithm. (in: query)
    description (str): A description of this algorithm. (in: query)
    config (Any): The configuration of this algorithm. (in: query)
    framework_id (str): Id for the framework of this algorithm. (in: query)
    data_class_ids (Any): The data classes this algorithm to be associated with. (in: query)
    make_current_account_owner (bool): Whether the account creating this algorithm must be configured as owner of it. (in: query)
    tags (Any): The tags of this algorithm. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"algorithms"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description, "config": config, "framework_id": framework_id, "data_class_ids": data_class_ids, "make_current_account_owner": make_current_account_owner, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_algorithm_by_id(algorithmId: str) -> dict:
    """
    GET /algorithms/{algorithmId}

    Args:
    algorithmId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"algorithms/{algorithmId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_algorithm(algorithmId: str) -> dict:
    """
    DELETE /algorithms/{algorithmId}

    Args:
    algorithmId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"algorithms/{algorithmId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_algorithm(algorithmId: str, name: Optional[str] = None, description: Optional[str] = None, config: Optional[Any] = None) -> dict:
    """
    PATCH /algorithms/{algorithmId}

    Args:
    algorithmId (str): Path parameter
    name (str): The name of this Algorithm. (in: query)
    description (str): A description of this algorithm. (in: query)
    config (Any): The configuration of this algorithm. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"algorithms/{algorithmId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description, "config": config}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_algorithms(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /algorithms/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"algorithms/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_algorithm_tags(algorithmId: str) -> dict:
    """
    GET /algorithms/{algorithmId}/tags

    Args:
    algorithmId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"algorithms/{algorithmId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_algorithm_tags(algorithmId: str, tags: Any) -> dict:
    """
    POST /algorithms/{algorithmId}/tags

    Args:
    algorithmId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"algorithms/{algorithmId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_algorithm_tags(algorithmId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /algorithms/{algorithmId}/tags/delete

    Args:
    algorithmId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"algorithms/{algorithmId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_algorithm_dependencies_by_id(algorithmId: str) -> dict:
    """
    GET /algorithms/{algorithmId}/dependencies

    Args:
    algorithmId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"algorithms/{algorithmId}/dependencies"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_algorithm_dependencies(algorithmId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /algorithms/{algorithmId}/dependencies/search

    Args:
    algorithmId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"algorithms/{algorithmId}/dependencies/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def validate_algorithm_config(name: str, config: Any, framework_id: str) -> dict:
    """
    POST /algorithms/validate-config

    Args:
    name (str): The name of this Algorithm. (in: query)
    config (Any): The configuration of this algorithm. (in: query)
    framework_id (str): Id for the framework of this algorithm. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"algorithms/validate-config"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "config": config, "framework_id": framework_id}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_masking_environments(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /masking-environments

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-environments"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_masking_environments(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /masking-environments/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-environments/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_masking_environment_by_id(maskingEnvironmentId: str) -> dict:
    """
    GET /masking-environments/{maskingEnvironmentId}

    Args:
    maskingEnvironmentId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-environments/{maskingEnvironmentId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_masking_plugins(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /masking-plugins

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-plugins"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_masking_plugin_by_id(maskingPluginId: str) -> dict:
    """
    GET /masking-plugins/{maskingPluginId}

    Args:
    maskingPluginId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-plugins/{maskingPluginId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_masking_plugins(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /masking-plugins/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"masking-plugins/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_algorithm_framework_by_id(algorithmFrameworkId: str) -> dict:
    """
    GET /algorithm-frameworks/{algorithmFrameworkId}

    Args:
    algorithmFrameworkId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"algorithm-frameworks/{algorithmFrameworkId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_rule_sets(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /rule-sets

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"rule-sets"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_rule_set(name: str, connector_id: str, refresh_drops_tables: Optional[bool] = None, make_current_account_owner: Optional[bool] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /rule-sets

    Args:
    name (str): The name of this rule set. (in: query)
    connector_id (str): The ID of the connector this rule set uses. (in: query)
    refresh_drops_tables (bool): This applies when table metadata exists in DCT, but the corresponding table no longer exists in the external database. In that event, true will cause the refresh operation to delete the invalid table metadata, whereas false will fail the refresh instead. (in: query)
    make_current_account_owner (bool): Whether the account creating this rule set must be configured as owner of it. (in: query)
    tags (Any): The tags for this rule set. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"rule-sets"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "connector_id": connector_id, "refresh_drops_tables": refresh_drops_tables, "make_current_account_owner": make_current_account_owner, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_rule_sets(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /rule-sets/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"rule-sets/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_rule_set_by_id(ruleSetId: str) -> dict:
    """
    GET /rule-sets/{ruleSetId}

    Args:
    ruleSetId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"rule-sets/{ruleSetId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_rule_set(ruleSetId: str) -> dict:
    """
    DELETE /rule-sets/{ruleSetId}

    Args:
    ruleSetId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"rule-sets/{ruleSetId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_rule_set(ruleSetId: str, name: Optional[str] = None, refresh_drops_tables: Optional[bool] = None) -> dict:
    """
    PATCH /rule-sets/{ruleSetId}

    Args:
    ruleSetId (str): Path parameter
    name (str): The name of this rule set. (in: query)
    refresh_drops_tables (bool): This applies when table metadata exists in DCT, but the corresponding table no longer exists in the external database. In that event, true will cause the refresh operation to delete the invalid table metadata, whereas false will fail the refresh instead. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"rule-sets/{ruleSetId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "refresh_drops_tables": refresh_drops_tables}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_rule_set_tags(ruleSetId: str) -> dict:
    """
    GET /rule-sets/{ruleSetId}/tags

    Args:
    ruleSetId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"rule-sets/{ruleSetId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_rule_set_tags(ruleSetId: str, tags: Any) -> dict:
    """
    POST /rule-sets/{ruleSetId}/tags

    Args:
    ruleSetId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"rule-sets/{ruleSetId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_rule_set_tags(ruleSetId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /rule-sets/{ruleSetId}/tags/delete

    Args:
    ruleSetId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"rule-sets/{ruleSetId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_database_table_metadata(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /database-table-metadata

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"database-table-metadata"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_database_table_metadata(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /database-table-metadata/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"database-table-metadata/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_database_column_metadata(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /database-column-metadata

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"database-column-metadata"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_database_column_metadata(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /database-column-metadata/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"database-column-metadata/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_discovery_expressions(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /discovery-expressions

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"discovery-expressions"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_discovery_expressions(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /discovery-expressions/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"discovery-expressions/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_discovery_expression_by_id(expressionId: str) -> dict:
    """
    GET /discovery-expressions/{expressionId}

    Args:
    expressionId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"discovery-expressions/{expressionId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_discovery_expression_tags(expressionId: str) -> dict:
    """
    GET /discovery-expressions/{expressionId}/tags

    Args:
    expressionId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"discovery-expressions/{expressionId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_discovery_expression_tags(expressionId: str, tags: Any) -> dict:
    """
    POST /discovery-expressions/{expressionId}/tags

    Args:
    expressionId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"discovery-expressions/{expressionId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_discovery_expression_tags(expressionId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /discovery-expressions/{expressionId}/tags/delete

    Args:
    expressionId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"discovery-expressions/{expressionId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_compliance_jobs(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /compliance-jobs

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-jobs"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_compliance_job(name: str, rule_set_id: str, description: Optional[str] = None, max_memory: Optional[int] = None, min_memory: Optional[int] = None, feedback_size: Optional[int] = None, stream_row_limit: Optional[int] = None, num_input_streams: Optional[int] = None, fail_immediately: Optional[bool] = None, batch_update: Optional[bool] = None, commit_size: Optional[int] = None, num_output_threads_per_stream: Optional[int] = None, make_current_account_owner: Optional[bool] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /compliance-jobs

    Args:
    name (str): The name of this compliance job. (in: query)
    description (str): A description of the compliance job. (in: query)
    rule_set_id (str): The ID of the Rule Set used by this compliance job. (in: query)
    max_memory (int): The maximum amount of memory, in MB, that the compliance job can consume during execution. (in: query)
    min_memory (int): The minimum amount of memory, in MB, that the compliance job can consume during execution. (in: query)
    feedback_size (int): The granularity with which the system provides updates on the progress of the compliance job. For instance, a feedback size of 50000 results in log updates whenever 50000 rows are processed during the masking phase. (in: query)
    stream_row_limit (int): This value constrains the total number of rows that may enter the job for each masking stream. A setting of 0 means unlimited. A value of -1 selects the default value. The minimum explicit value allowed is 20. (in: query)
    num_input_streams (int): This field controls the amount of parallelism that the masking job uses to extract out the data to be masked. For instance, when masking a database, specifying 5 input streams results in the compliance job reading up to 5 database tables in parallel and then masking those 5 streams of data in parallel. The higher the value of this field, the more potential parallelism there will be in the job, but the masking job will consume more memory. If the number of input streams exceeds the number of units being masked (e.g. tables or files), then the excess streams will do nothing. (in: query)
    fail_immediately (bool): Whether to fail immediately or delay failure until job completion when a masking algorithm fails to mask its data. (in: query)
    batch_update (bool): Whether the database load phase to output the masked data will be performed in batches. The size of the batches is determined by the field 'commit_size'. (in: query)
    commit_size (int): The size of the database commits when performing batch updates. (in: query)
    num_output_threads_per_stream (int): The amount of parallelism, per input stream, that the job uses to load back the masked data. For example, specifying 4 output threads per stream with 5 input streams results in a total of 20 output threads for the whole job. (in: query)
    make_current_account_owner (bool): Whether the account creating this compliance job should be configured as its owner. (in: query)
    tags (Any): The tags to set on the compliance job. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-jobs"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description, "rule_set_id": rule_set_id, "max_memory": max_memory, "min_memory": min_memory, "feedback_size": feedback_size, "stream_row_limit": stream_row_limit, "num_input_streams": num_input_streams, "fail_immediately": fail_immediately, "batch_update": batch_update, "commit_size": commit_size, "num_output_threads_per_stream": num_output_threads_per_stream, "make_current_account_owner": make_current_account_owner, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_compliance_jobs(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /compliance-jobs/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-jobs/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_compliance_job_by_id(complianceJobId: str) -> dict:
    """
    GET /compliance-jobs/{complianceJobId}

    Args:
    complianceJobId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-jobs/{complianceJobId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_compliance_job(complianceJobId: str) -> dict:
    """
    DELETE /compliance-jobs/{complianceJobId}

    Args:
    complianceJobId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-jobs/{complianceJobId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_compliance_job(complianceJobId: str, name: Optional[str] = None, description: Optional[str] = None, rule_set_id: Optional[str] = None, max_memory: Optional[int] = None, min_memory: Optional[int] = None, feedback_size: Optional[int] = None, stream_row_limit: Optional[int] = None, num_input_streams: Optional[int] = None, fail_immediately: Optional[bool] = None, batch_update: Optional[bool] = None, commit_size: Optional[int] = None, num_output_threads_per_stream: Optional[int] = None) -> dict:
    """
    PATCH /compliance-jobs/{complianceJobId}

    Args:
    complianceJobId (str): Path parameter
    name (str): The name of this compliance job. (in: query)
    description (str): A description of the compliance job. (in: query)
    rule_set_id (str): The ID of the Rule Set used by this compliance job. (in: query)
    max_memory (int): The maximum amount of memory, in MB, that the compliance job can consume during execution. (in: query)
    min_memory (int): The minimum amount of memory, in MB, that the compliance job can consume during execution. (in: query)
    feedback_size (int): The granularity with which the system provides updates on the progress of the compliance job. For instance, a feedback size of 50000 results in log updates whenever 50000 rows are processed during the masking phase. (in: query)
    stream_row_limit (int): This value constrains the total number of rows that may enter the job for each masking stream. A setting of 0 means unlimited. A value of -1 selects the default value. The minimum explicit value allowed is 20. (in: query)
    num_input_streams (int): This field controls the amount of parallelism that the masking job uses to extract out the data to be masked. For instance, when masking a database, specifying 5 input streams results in the compliance job reading up to 5 database tables in parallel and then masking those 5 streams of data in parallel. The higher the value of this field, the more potential parallelism there will be in the job, but the masking job will consume more memory. If the number of input streams exceeds the number of units being masked (e.g. tables or files), then the excess streams will do nothing. (in: query)
    fail_immediately (bool): Whether to fail immediately or delay failure until job completion when a masking algorithm fails to mask its data. (in: query)
    batch_update (bool): Whether the database load phase to output the masked data will be performed in batches. The size of the batches is determined by the field 'commit_size'. (in: query)
    commit_size (int): The size of the database commits when performing batch updates. (in: query)
    num_output_threads_per_stream (int): The amount of parallelism, per input stream, that the job uses to load back the masked data. For example, specifying 4 output threads per stream with 5 input streams results in a total of 20 output threads for the whole job. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-jobs/{complianceJobId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description, "rule_set_id": rule_set_id, "max_memory": max_memory, "min_memory": min_memory, "feedback_size": feedback_size, "stream_row_limit": stream_row_limit, "num_input_streams": num_input_streams, "fail_immediately": fail_immediately, "batch_update": batch_update, "commit_size": commit_size, "num_output_threads_per_stream": num_output_threads_per_stream}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_compliance_job_connectors(complianceJobId: str) -> dict:
    """
    GET /compliance-jobs/{complianceJobId}/connectors

    Args:
    complianceJobId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-jobs/{complianceJobId}/connectors"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_compliance_job_tag(complianceJobId: str) -> dict:
    """
    GET /compliance-jobs/{complianceJobId}/tags

    Args:
    complianceJobId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-jobs/{complianceJobId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_compliance_job_tag(complianceJobId: str, tags: Any) -> dict:
    """
    POST /compliance-jobs/{complianceJobId}/tags

    Args:
    complianceJobId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-jobs/{complianceJobId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_compliance_job_tag(complianceJobId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /compliance-jobs/{complianceJobId}/tags/delete

    Args:
    complianceJobId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-jobs/{complianceJobId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def execute_compliance_job(complianceJobId: str, _placeholder: Optional[bool] = None) -> dict:
    """
    POST /compliance-jobs/{complianceJobId}/execute

    Args:
    complianceJobId (str): Path parameter
    _placeholder (bool): Internal property added to force the generator to generate model. This can be removed when actual properties are added. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-jobs/{complianceJobId}/execute"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"_placeholder": _placeholder}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_compliance_job_collections(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /compliance-job-collections

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-job-collections"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_compliance_job_collection(name: str, description: Optional[str] = None, failure_handling: Optional[str] = None, members: Optional[Any] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /compliance-job-collections

    Args:
    name (str): The name of the compliance job collection. (in: query)
    description (str): The description of the compliance job collection. (in: query)
    failure_handling (str): failure_handling (in: query)
    members (Any): The list of compliance job IDs and their collection sequence to be included in the collection. (in: query)
    tags (Any): The tags to be created for this compliance job collection. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-job-collections"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description, "failure_handling": failure_handling, "members": members, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_compliance_job_collections(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /compliance-job-collections/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-job-collections/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_compliance_job_collection_by_id(complianceJobCollectionId: str) -> dict:
    """
    GET /compliance-job-collections/{complianceJobCollectionId}

    Args:
    complianceJobCollectionId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-job-collections/{complianceJobCollectionId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_compliance_job_collection(complianceJobCollectionId: str) -> dict:
    """
    DELETE /compliance-job-collections/{complianceJobCollectionId}

    Args:
    complianceJobCollectionId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-job-collections/{complianceJobCollectionId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_compliance_job_collection(complianceJobCollectionId: str, name: Optional[str] = None, description: Optional[str] = None, failure_handling: Optional[str] = None, members: Optional[Any] = None) -> dict:
    """
    PATCH /compliance-job-collections/{complianceJobCollectionId}

    Args:
    complianceJobCollectionId (str): Path parameter
    name (str): The name of the compliance job collection. (in: query)
    description (str): The description of the compliance job collection. (in: query)
    failure_handling (str): failure_handling (in: query)
    members (Any): The list of compliance job IDs and their collection sequence to be included in the collection. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-job-collections/{complianceJobCollectionId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description, "failure_handling": failure_handling, "members": members}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def execute_compliance_job_collection(complianceJobCollectionId: str, _placeholder: Optional[bool] = None) -> dict:
    """
    POST /compliance-job-collections/{complianceJobCollectionId}/execute

    Args:
    complianceJobCollectionId (str): Path parameter
    _placeholder (bool): Internal property added to force the generator to generate model. This can be removed when actual properties are added. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-job-collections/{complianceJobCollectionId}/execute"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"_placeholder": _placeholder}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_compliance_job_collection_jobs(complianceJobCollectionId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /compliance-job-collections/{complianceJobCollectionId}/jobs

    Args:
    complianceJobCollectionId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-job-collections/{complianceJobCollectionId}/jobs"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_compliance_job_collection_jobs(complianceJobCollectionId: str, limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /compliance-job-collections/{complianceJobCollectionId}/jobs/search

    Args:
    complianceJobCollectionId (str): Path parameter
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-job-collections/{complianceJobCollectionId}/jobs/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_compliance_job_collection_tags(complianceJobCollectionId: str) -> dict:
    """
    GET /compliance-job-collections/{complianceJobCollectionId}/tags

    Args:
    complianceJobCollectionId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-job-collections/{complianceJobCollectionId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_compliance_job_collection_tags(complianceJobCollectionId: str, tags: Any) -> dict:
    """
    POST /compliance-job-collections/{complianceJobCollectionId}/tags

    Args:
    complianceJobCollectionId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-job-collections/{complianceJobCollectionId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_compliance_job_collection_tags(complianceJobCollectionId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /compliance-job-collections/{complianceJobCollectionId}/tags/delete

    Args:
    complianceJobCollectionId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"compliance-job-collections/{complianceJobCollectionId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_job_collection_executions(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /job-collection-executions

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"job-collection-executions"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_job_collection_executions(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /job-collection-executions/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"job-collection-executions/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_job_collection_execution_by_id(jobCollectionExecutionId: str) -> dict:
    """
    GET /job-collection-executions/{jobCollectionExecutionId}

    Args:
    jobCollectionExecutionId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"job-collection-executions/{jobCollectionExecutionId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def cancel_job_collection_execution(jobCollectionExecutionId: str, _placeholder: Optional[bool] = None) -> dict:
    """
    POST /job-collection-executions/{jobCollectionExecutionId}/cancel

    Args:
    jobCollectionExecutionId (str): Path parameter
    _placeholder (bool): Internal property added to force the generator to generate model. This can be removed when actual properties are added. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"job-collection-executions/{jobCollectionExecutionId}/cancel"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"_placeholder": _placeholder}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_job_orchestrators(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None) -> dict:
    """
    GET /job-orchestrators

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"job-orchestrators"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = {"limit": limit, "cursor": cursor, "sort": sort}
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_job_orchestrator(name: str, description: Optional[str] = None, tags: Optional[Any] = None, make_current_account_owner: Optional[bool] = None) -> dict:
    """
    POST /job-orchestrators

    Args:
    name (str): The name of the job orchestrator. (in: query)
    description (str): The description of the job orchestrator. (in: query)
    tags (Any): The tags to be created for this compliance job collection. (in: query)
    make_current_account_owner (bool): Whether the account creating this Job Orchestrator must be configured as its owner. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"job-orchestrators"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description, "tags": tags, "make_current_account_owner": make_current_account_owner}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def search_job_orchestrators(limit: Optional[int] = None, cursor: Optional[str] = None, sort: Optional[str] = None, filter_expression: Optional[str] = None) -> dict:
    """
    POST /job-orchestrators/search

    Args:
    limit (int): Maximum number of objects to return per query. The value must be between 1 and 1000. Default is 100. (in: query)
    cursor (str): Cursor to fetch the next or previous page of results. The value of this property must be extracted from the 'prev_cursor' or 'next_cursor' property of a PaginatedResponseMetadata which is contained in the response of list and search API endpoints. (in: query)
    sort (str): The field to sort results by. A property name with a prepended '-' signifies a descending order. (in: query)
    filter_expression (str): filter_expression (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"job-orchestrators/search"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"limit": limit, "cursor": cursor, "sort": sort, "filter_expression": filter_expression}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_job_orchestrator_by_id(jobOrchestratorId: str) -> dict:
    """
    GET /job-orchestrators/{jobOrchestratorId}

    Args:
    jobOrchestratorId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"job-orchestrators/{jobOrchestratorId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_job_orchestrator(jobOrchestratorId: str) -> dict:
    """
    DELETE /job-orchestrators/{jobOrchestratorId}

    Args:
    jobOrchestratorId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"job-orchestrators/{jobOrchestratorId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.delete(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def update_job_orchestrator(jobOrchestratorId: str, name: Optional[str] = None, description: Optional[str] = None) -> dict:
    """
    PATCH /job-orchestrators/{jobOrchestratorId}

    Args:
    jobOrchestratorId (str): Path parameter
    name (str): The name of the job orchestrator. (in: query)
    description (str): The description of the job orchestrator. (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"job-orchestrators/{jobOrchestratorId}"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"name": name, "description": description}

    try:
        response = requests.patch(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def get_job_orchestrator_tags(jobOrchestratorId: str) -> dict:
    """
    GET /job-orchestrators/{jobOrchestratorId}/tags

    Args:
    jobOrchestratorId (str): Path parameter

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"job-orchestrators/{jobOrchestratorId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = None

    try:
        response = requests.get(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def create_job_orchestrator_tags(jobOrchestratorId: str, tags: Any) -> dict:
    """
    POST /job-orchestrators/{jobOrchestratorId}/tags

    Args:
    jobOrchestratorId (str): Path parameter
    tags (Any): Array of tags with key value pairs (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"job-orchestrators/{jobOrchestratorId}/tags"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def delete_job_orchestrator_tags(jobOrchestratorId: str, key: Optional[str] = None, value: Optional[str] = None, tags: Optional[Any] = None) -> dict:
    """
    POST /job-orchestrators/{jobOrchestratorId}/tags/delete

    Args:
    jobOrchestratorId (str): Path parameter
    key (str): Key of the tag (in: query)
    value (str): Value of the tag (in: query)
    tags (Any): List of tags to be deleted (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"job-orchestrators/{jobOrchestratorId}/tags/delete"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"key": key, "value": value, "tags": tags}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }

@tool
def sync_export(engine_id: Optional[str] = None, application_name: Optional[str] = None, object_type: Optional[str] = None, object_ids: Optional[Any] = None) -> dict:
    """
    POST /sync-export

    Args:
    engine_id (str): engine_id (in: query)
    application_name (str): application_name (in: query)
    object_type (str): object_type (in: query)
    object_ids (Any): object_ids (in: query)

    Returns:
        dict: API response or error details
    """
    import requests
    import json
    from urllib.parse import urljoin
    from typing import Optional, Any

    # Prepare headers - combine defaults with environment headers
    headers = {
    "X-CLIENT-ID": "1",
    "Content-Type": "application/json"
}
    try:
        env_headers = json.loads(os.getenv("HEADERS", "{}"))
        headers.update(env_headers)
    except json.JSONDecodeError:
        pass

    # Build URL
    base_url = "http://localhost:8080/v3"
    path = f"sync-export"
    url = urljoin(base_url + "/", path)

    # Prepare request parameters
    params = None
    json_data = {"engine_id": engine_id, "application_name": application_name, "object_type": object_type, "object_ids": object_ids}

    try:
        response = requests.post(
            url,
            headers=headers,
            params=params,
            json=json_data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        return {
            "error": "API request failed",
            "details": str(e),
            "status_code": getattr(e.response, "status_code", None),
            "response_text": getattr(e.response, "text", None)
        }
    except Exception as e:
        return {
            "error": "Unexpected error",
            "details": str(e)
        }
